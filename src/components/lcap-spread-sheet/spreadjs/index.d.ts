declare module GCTYPE{
    module Data{

        export interface IColumn{
            name: string; // the unique name of the column
            value?: string; // the value of the column, could be a field name of table from database, or formula which uses the fields names
            caption?: string; // the caption of the column, which is the key of row data
            width?: number; // the width of the column, support number in pixel, or star size
            style?: GCTYPE.Data.StyleOptions;
            conditionalFormats?: Array<GCTYPE.Data.CellValueRuleOptions | GCTYPE.Data.SpecificTextRuleOptions | GCTYPE.Data.FormulaRuleOptions | GCTYPE.Data.DateOccurringRuleOptions | GCTYPE.Data.Top10RuleOptions | GCTYPE.Data.UniqueRuleOptions | GCTYPE.Data.DuplicateRuleOptions | GCTYPE.Data.AverageRuleOptions | GCTYPE.Data.TwoScaleRuleOptions | GCTYPE.Data.ThreeScaleRuleOptions | GCTYPE.Data.DataBarRuleOptions | GCTYPE.Data.IconSetRuleOptions>;
            validator?: GCTYPE.Data.NumberValidatorOptions | GCTYPE.Data.DateValidatorOptions | GCTYPE.Data.TimeValidatorOptions | GCTYPE.Data.TextLengthValidatorOptions | GCTYPE.Data.FormulaValidatorOptions | GCTYPE.Data.FormulaListValidatorOptions | GCTYPE.Data.ListValidatorOptions;
            isPrimaryKey?: boolean; // mark the column as primary key column
            readonly?: boolean; // mark the column is readonly
            required?: boolean; // mark the column is required when insert a new row
            defaultValue?: any; // provide the default value when insert a new row, could be a const or a formula
        }


        export interface IColumnCollection{
            [key: string]: GCTYPE.Data.IColumn;
        }


        export interface IDataSourceOption{
            data?: any; // local data source, which could be an object array for JSON, a string for CSV or XML
            remote?: GCTYPE.Data.IRemoteTransportOption; // remote data source, which supports REST API, OData, GraphQL
            autoSync?: boolean; // in auto sync mode, data changes will be synced to server immediately
            batch?: boolean; // in batch mode, data changes will be held in data source, user need invoke submitChanges method to sync server
            schema?: {
            type?: string; // supports 'json', 'csv', 'xml', 'columnJson'
            count?: string; // data reader use this to get data source collection length, return the current data source collection length if this is not specified
            data?: string; // data reader use this to get data source collection after parse, return entire parsed object if this is not specified.
            };
        }


        export interface IRelationship{
            sourceTable: GCTYPE.Data.Table;
            sourceFieldName: string;
            sourceRelationshipName: string;
            targetTable: GCTYPE.Data.Table;
            targetFieldName: string;
            targetRelationshipName: string;
        }


        export interface IRemoteTransportOption{
            read: {
            url: string; // request url
            dataType?: string; // request data type, supports 'json', 'xml'
            adapter?: string; // adapt different data protocol, supports "rest", "odata", "odata4", "graphql"
            body?: any; // request body
            method?: string; // request method, such as 'GET', 'POST', 'PUT', 'DELETE', default value is 'GET'
            };
            create?: {
            url: string;
            dataType?: string; // request data type, supports 'json', 'xml'
            method?: string; // request method, such as 'GET', 'POST', 'PUT', 'DELETE', default value is 'POST'
            };
            update?: {
            url: string;
            dataType?: string; // request data type, supports 'json', 'xml'
            method?: string; // request method, such as 'GET', 'POST', 'PUT', 'DELETE', default value is 'POST'
            };
            delete?: {
            url: string;
            dataType?: string; // request data type, supports 'json', 'xml'
            method?: string; // request method, such as 'GET', 'POST', 'PUT', 'DELETE', default value is 'DELETE'
            };
            batch?: {
            url: string;
            dataType?: string; // request data type, supports 'json', 'xml'
            method?: string; // request method, such as 'GET', 'POST', 'PUT', 'DELETE', default value is 'POST'
            };
        }


        export interface ITables{
            [tableName: string]: GCTYPE.Data.Table
        }


        export interface IViews{
            [viewName: string]: GCTYPE.Data.View
        }


        /**
         * @typedef GCTYPE.Data.AverageRuleOptions - The options of average rule.
         * @property {"averageRule"} ruleType - The rule type if you want to use average rule.
         * @property {GCTYPE.Data.AverageType} type - The average type.
         * @property {GCTYPE.Data.StyleOptions} style - The style that is applied to the cell when the condition is met.
         * @property {number} priority - The priority of the rule.
         * @property {boolean} stopIfTrue - Whether rules with lower priority are applied before this rule.
         */
        export type AverageRuleOptions =
            {
                ruleType: "averageRule";
                type: GCTYPE.Data.AverageType;
                style: GCTYPE.Data.StyleOptions;
                priority: number;
                stopIfTrue: boolean;
            }


        /**
         * @typedef GCTYPE.Data.AverageType
         * @type {"above"|"below"|"equalOrAbove"|"equalOrBelow"|"above1StdDev"|"below1StdDev"|"above2StdDev"|"below2StdDev"|"above3StdDev"|"below3StdDev"}
         * @description The average type.
         */
        export type AverageType =
            "above"|"below"|"equalOrAbove"|"equalOrBelow"|"above1StdDev"|"below1StdDev"|"above2StdDev"|"below2StdDev"|"above3StdDev"|"below3StdDev"


        /**
         * @typedef GCTYPE.Data.CellButtonOptions
         * @property {string} position - The button's position in cell, which supports "left", "right", "leftOfText", "rightOfText".
         * @property {boolean} useButtonStyle - Whether the cellButton is a button style, default value is false.
         * @property {boolean} enabled - Whether the cell button responds to user actions, default value is true.
         * @property {number} width - The button's width. If it is set to null or undefined, the button width is auto fit based on the caption and image size.
         * @property {string} caption - The text of the button to display.
         * @property {string} imageSrc - When imageType is custom, can Specifies a image (base64) by imageSrc.
         * @property {Object} imageSize - The image's size by object {width: 16, height: 16}, default value is 16px * 16px.
         * @property {number} imageSize.width - The image width.
         * @property {number} imageSize.height - The image height.
         * @property {string} captionAlign - The alignment of image and caption, which supports "left", "right".
         * @property {string | Function} command - When click button, allow user to execute a command or user can execute a callback.
         * @property {string} imageType - The button's type (the type of image to display in the button), default value is custom. Provide some predefined type for cellButton, custom allow to Specifies icon.
         * It supports "none", "custom", "clear", "cancel", "ok", "dropdown", "ellipsis", "left", "right", "plus", "minus", "undo", "redo", "search", "separator", "spinLeft", "spinRight", "collapse", "expand".
         * @property {string} visibility - The button can be visible "always", "onSelected", "onEditing", default value is "always".
         * @property {string} hoverBackColor - The hover backColor of cell button when the button is visible and enable.
         * @property {string} buttonBackColor - The backColor of cell button when the button is enable.
         */
        export type CellButtonOptions =
            {
                position?: "left" | "right" | "leftOfText" | "rightOfText";
                useButtonStyle?: boolean;
                enabled?: boolean;
                width?: number;
                caption?: string;
                imageSrc?: string;
                imageSize?: { width: number, height: number };
                captionAlign?: "left" | "right";
                command?: string | ((sheet: any, row: number, col: number, option: any) => void);
                imageType?: "none" | "custom" | "clear" | "cancel" | "ok" | "dropdown" | "ellipsis" | "left" | "right" | "plus" | "minus" | "undo" | "redo" | "search" | "separator" | "spinLeft" | "spinRight" | "collapse" | "expand";
                visibility?: "always" | "onSelected" | "onEditing";
                hoverBackColor?: string;
                buttonBackColor?: string;
            }


        /**
         * @typedef GCTYPE.Data.CellValueComparisionOperator
         * @type {"equalsTo"|"notEqualsTo"|"greaterThan"|"greaterThanOrEqualsTo"|"lessThan"|"lessThanOrEqualsTo"|"between"|"notBetween"}
         * @description The cell value comparision operator.
         */
        export type CellValueComparisionOperator =
            "equalsTo"|"notEqualsTo"|"greaterThan"|"greaterThanOrEqualsTo"|"lessThan"|"lessThanOrEqualsTo"|"between"|"notBetween"


        /**
         * @typedef GCTYPE.Data.CellValueRuleOptions - The options of cell value rule.
         * @property {"cellValueRule"} ruleType - The rule type if you want to use cell value rule.
         * @property {GCTYPE.Data.CellValueComparisionOperator} comparisionOperator - The comparision operator of cell value.
         * @property {GCTYPE.Data.CellValueType} value1 - The first value.
         * @property {GCTYPE.Data.CellValueType} value2 - The second value.
         * @property {GCTYPE.Data.StyleOptions} style - The style that is applied to the cell when the condition is met.
         * @property {number} priority - The priority of the rule.
         * @property {boolean} stopIfTrue - Whether rules with lower priority are applied before this rule.
         */
        export type CellValueRuleOptions =
            {
                ruleType: "cellValueRule";
                comparisionOperator: GCTYPE.Data.CellValueComparisionOperator;
                value1: GCTYPE.Data.CellValueType;
                value2: GCTYPE.Data.CellValueType;
                style: GCTYPE.Data.StyleOptions;
                priority: number;
                stopIfTrue: boolean;
            }


        /**
         * @typedef GCTYPE.Data.CellValueType
         * @type {number|string|boolean|Date|FormulaString}
         * @description The cell value type.
         */
        export type CellValueType =
            number|string|boolean|Date|FormulaString


        /**
         * @typedef GCTYPE.Data.CheckboxOptions
         * @property {string} type - The type of the cell type, supports "checkbox".
         * @property {string} caption - The caption.
         * @property {string} textTrue - The text when cell value is true.
         * @property {string} textIndeterminate - The text when cell value is indeterminate.
         * @property {string} textFalse - The text when cell value is false.
         * @property {string} textAlign - The text alignment relative to the check box, which supports "top", "bottom", "left", "right".
         * @property {boolean} isThreeState - Whether the check box supports three states.
         * @property {number} boxSize - The check box size.
         */
        export type CheckboxOptions =
            {
                type: "checkbox";
                caption: string;
                textTrue: string;
                textIndeterminate: string;
                textFalse: string;
                textAlign: "top" | "bottom" | "left" | "right";
                isThreeState: boolean;
                boxSize: number;
            }


        /**
         * @typedef GCTYPE.Data.ColorPickerGroup
         * @property {string} name - The group name.
         * @property {string[][]} colors - The group colors.
         * @property {boolean} needScaleColor - Whether generate scale color group.
         */
        export type ColorPickerGroup =
            {
                name: string;
                colors: string[][];
                needScaleColor: boolean;
            }


        /**
         * @typedef GCTYPE.Data.ColorPickerOptions
         * @property {number} colorBlockSize - Every color cell's size.
         * @property {GCTYPE.Data.ColorPickerGroup[]} groups - The group of the color picker, every group accept a name as group name, and a color array as the group's colors.
         */
        export type ColorPickerOptions =
            {
                colorBlockSize: number;
                groups: GCTYPE.Data.ColorPickerGroup[];
            }


        /**
         * @typedef GCTYPE.Data.ColorString
         * @type {string}
         * @description The string type color.
         */
        export type ColorString =
            string


        /**
         * @typedef GCTYPE.Data.ColumnBindingInfo
         * @property {string} name - The bound column of data through name.
         * @property {string} displayName - The display name of this column.
         * @property {string} formatter - The formatter for this column.
         * @property {number | string} size - The size of column.
         * @property {boolean} visible - The visibility of column.
         */
        export type ColumnBindingInfo =
            {
                name: string;
                displayName?: string;
                formatter?: string;
                size?: number | string;
                visible?: boolean;
            }


        /**
         * @typedef GCTYPE.Data.ComboBoxOptions
         * @property {string} type - The type of the cell type, supports "combobox".
         * @property {string} editorValueType - The editor value type, which supports "text", "index", "value".
         * @property {string[] | GCTYPE.Data.ItemOptions[]} items - The items, which supports string Array or Object Array which each item contains text and value.
         * @property {number} itemHeight - The height of each item.
         * @property {number} maxDropDownItems - The maximum item count of the drop-down list per page.
         * @property {boolean} editable - Whether the combo box is editable.
         */
        export type ComboBoxOptions =
            {
                type: "combobox";
                editorValueType: "text" | "index" | "value";
                items: string[] | GCTYPE.Data.ItemOptions[];
                itemHeight: number;
                maxDropDownItems: number;
                editable: boolean;
            }


        /**
         * @typedef GCTYPE.Data.DataBarRuleOptions - The options of data bar rule.
         * @property {"dataBarRule"} ruleType - The rule type if you want to use data bar rule.
         * @property {GCTYPE.Data.ScaleValueType} minType - The minimum scale type.
         * @property {number} minValue - The minimum scale value.
         * @property {GCTYPE.Data.ScaleValueType} maxType - The maximum scale type.
         * @property {number} maxValue - The maximum scale value.
         * @property {GCTYPE.Data.ColorString} maxColor - The maximum scale color string.
         * @property {number} priority - The priority of the rule.
         * @property {boolean} stopIfTrue - Whether rules with lower priority are applied before this rule.
         */
        export type DataBarRuleOptions =
            {
                ruleType: "dataBarRule";
                minType: GCTYPE.Data.ScaleValueType;
                minValue: number;
                midType: GCTYPE.Data.ScaleValueType;
                midValue: number;
                color: GCTYPE.Data.ColorString;
                priority: number;
                stopIfTrue: boolean;
            }


        /**
         * @typedef GCTYPE.Data.DateOccurringRuleOptions - The options of date occurring rule.
         * @property {"dateOccurringRule"} ruleType - The rule type if you want to use data occurring rule.
         * @property {GCTYPE.Data.DateOccurringType} type - The date occurring type.
         * @property {GCTYPE.Data.StyleOptions} style - The style that is applied to the cell when the condition is met.
         * @property {number} priority - The priority of the rule.
         * @property {boolean} stopIfTrue - Whether rules with lower priority are applied before this rule.
         */
        export type DateOccurringRuleOptions =
            {
                ruleType: "dateOccurringRule";
                type: GCTYPE.Data.DateOccurringType;
                style: GCTYPE.Data.StyleOptions;
                priority: number;
                stopIfTrue: boolean;
            }


        /**
         * @typedef GCTYPE.Data.DateOccurringType
         * @type {"today"|"yesterday"|"tomorrow"|"last7Days"|"thisMonth"|"lastMonth"|"nextMonth"|"thisWeek"|"lastWeek"|"nextWeek"|"nextQuarter"|"thisQuarter"|"lastQuarter"|"nextYear"|"thisYear"|"lastYear"}
         * @description The date occurring type.
         */
        export type DateOccurringType =
            "today"|"yesterday"|"tomorrow"|"last7Days"|"thisMonth"|"lastMonth"|"nextMonth"|"thisWeek"|"lastWeek"|"nextWeek"|"nextQuarter"|"thisQuarter"|"lastQuarter"|"nextYear"|"thisYear"|"lastYear"


        /**
         * @typedef GCTYPE.Data.DateTimePickerOptions
         * @property {boolean} showTime - Whether the calendar need to display time part.
         * @property {string} calendarPage - The default page, which accepts "year", "month", "day".
         * @property {string} startDay - The start day of week, normal the start day is monday or sunday, there user can set any day as it's start day. It accepts "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday".
         */
        export type DateTimePickerOptions =
            {
                showTime: boolean;
                calendarPage: "year" | "month" | "day";
                startDay: "monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday";
            }


        /**
         * @typedef GCTYPE.Data.DateValidatorOptions
         * @property {"date"} type - The data validator type.
         * @property {GCTYPE.Data.CellValueComparisionOperator} comparisonOperator - The data validator comparison operator.
         * @property {Date | GCTYPE.Data.FormulaString} value1 - The data validator first value.
         * @property {Date | GCTYPE.Data.FormulaString} value2 - The data validator second value if validator comparison operator is "between" or "notBetween".
         * @property {boolean} ignoreBlank - Whether to ignore empty value.
         * @property {boolean} inCellDropdown - Whether to display a drop-down button.
         * @property {GCTYPE.Data.ErrorStyle} errorStyle - The data validator error style.
         * @property {string} errorTitle - The data validator error title.
         * @property {string} errorMessage - The data validator error message.
         * @property {boolean} showErrorMessage - Whether to show error message.
         * @property {string} inputMessage - The data validator input message.
         * @property {string} inputTitle - The data validator input title.
         * @property {boolean} showInputMessage - Whether to show input message.
         * @property {GCTYPE.Data.HighlightStyle} highlightStyle - The data validator highlight style.
         */
        export type DateValidatorOptions =
            {
                type: "date";
                comparisonOperator: GCTYPE.Data.CellValueComparisionOperator;
                value1: Date | GCTYPE.Data.FormulaString;
                value2?: Date | GCTYPE.Data.FormulaString;
                errorStyle: GCTYPE.Data.ErrorStyle;
                errorTitle: string;
                errorMessage: string;
                highlightStyle: GCTYPE.Data.HighlightStyle;
                ignoreBlank: boolean;
                inCellDropdown: boolean;
                inputMessage: string;
                inputTitle: string;
                showErrorMessage: boolean;
                showInputMessage: boolean;
            }


        /**
         * @typedef GCTYPE.Data.DropDownOptions
         * @property {string} type - The type of drop down, which supports "colorPicker", "dateTimePicker", "timePicker", "monthPicker", "list", "slider", "calculator", "workflowList", "multiColumn".
         * @property {GCTYPE.Data.ColorPickerOptions | GCTYPE.Data.DateTimePickerOptions | GCTYPE.Data.TimePickerOptions | GCTYPE.Data.MonthPickerOptions | GCTYPE.Data.ListOptions | GCTYPE.Data.SliderOptions | GCTYPE.Data.WorkFlowOptions | GCTYPE.Data.MultiColumnOptions} option - The option of drop down.
         * @property {Function} submitCommand - A command name or a callback function which will be executed when submit drop down's value.
         */
        export type DropDownOptions =
            {
                type: "colorPicker" | "dateTimePicker" | "timePicker" | "monthPicker" | "list" | "slider" | "calculator" | "workflowList" | "multiColumn";
                option?: GCTYPE.Data.ColorPickerOptions | GCTYPE.Data.DateTimePickerOptions | GCTYPE.Data.TimePickerOptions | GCTYPE.Data.MonthPickerOptions | GCTYPE.Data.ListOptions | GCTYPE.Data.SliderOptions | GCTYPE.Data.WorkFlowOptions | GCTYPE.Data.MultiColumnOptions;
                submitCommand?: string | ((sheet: any, value: any, option: any) => void);
            }


        /**
         * @typedef GCTYPE.Data.DuplicateRuleOptions - The options of duplicate rule.
         * @property {"duplicateRule"} ruleType - The rule type if you want to use duplicate rule.
         * @property {GCTYPE.Data.StyleOptions} style - The style that is applied to the cell when the condition is met.
         * @property {number} priority - The priority of the rule.
         * @property {boolean} stopIfTrue - Whether rules with lower priority are applied before this rule.
         */
        export type DuplicateRuleOptions =
            {
                ruleType: "duplicateRule";
                style: GCTYPE.Data.StyleOptions;
                priority: number;
                stopIfTrue: boolean;
            }


        /**
         * @typedef GCTYPE.Data.ErrorStyle
         * @type {"stop" | "warning" | "information"}
         * @description The validator error style.
         */
        export type ErrorStyle =
            "stop" | "warning" | "information"


        /**
         * @typedef GCTYPE.Data.FormulaListValidatorOptions
         * @property {"formulaList"} type - The data validator type.
         * @property {GCTYPE.Data.FormulaString} formula - The data validator formula if the validator type if "formula" or "formulaList".
         * @property {boolean} ignoreBlank - Whether to ignore empty value.
         * @property {boolean} inCellDropdown - Whether to display a drop-down button.
         * @property {GCTYPE.Data.ErrorStyle} errorStyle - The data validator error style.
         * @property {string} errorTitle - The data validator error title.
         * @property {string} errorMessage - The data validator error message.
         * @property {boolean} showErrorMessage - Whether to show error message.
         * @property {string} inputMessage - The data validator input message.
         * @property {string} inputTitle - The data validator input title.
         * @property {boolean} showInputMessage - Whether to show input message.
         * @property {GCTYPE.Data.HighlightStyle} highlightStyle - The data validator highlight style.
         */
        export type FormulaListValidatorOptions =
            {
                type: "formulaList";
                formula: GCTYPE.Data.FormulaString;
                errorStyle: GCTYPE.Data.ErrorStyle;
                errorTitle: string;
                errorMessage: string;
                highlightStyle: GCTYPE.Data.HighlightStyle;
                ignoreBlank: boolean;
                inCellDropdown: boolean;
                inputMessage: string;
                inputTitle: string;
                showErrorMessage: boolean;
                showInputMessage: boolean;
            }


        /**
         * @typedef GCTYPE.Data.FormulaRuleOptions - The options of formula rule.
         * @property {"formulaRule"} ruleType - The rule type if you want to use formula rule.
         * @property {GCTYPE.Data.FormulaString} formula - The formula.
         * @property {GCTYPE.Data.StyleOptions} style - The style that is applied to the cell when the condition is met.
         * @property {number} priority - The priority of the rule.
         * @property {boolean} stopIfTrue - Whether rules with lower priority are applied before this rule.
         */
        export type FormulaRuleOptions =
            {
                ruleType: "formulaRule";
                formula: GCTYPE.Data.FormulaString;
                style: GCTYPE.Data.StyleOptions;
                priority: number;
                stopIfTrue: boolean;
            }


        /**
         * @typedef {string} GCTYPE.Data.FormulaString - The formula type string, such as "=SUM(A1:B2)".
         */
        export type FormulaString =
            string


        /**
         * @typedef GCTYPE.Data.FormulaValidatorOptions
         * @property {"formula"} type - The data validator type.
         * @property {GCTYPE.Data.FormulaString} formula - The data validator formula if the validator type if "formula" or "formulaList".
         * @property {boolean} ignoreBlank - Whether to ignore empty value.
         * @property {boolean} inCellDropdown - Whether to display a drop-down button.
         * @property {GCTYPE.Data.ErrorStyle} errorStyle - The data validator error style.
         * @property {string} errorTitle - The data validator error title.
         * @property {string} errorMessage - The data validator error message.
         * @property {boolean} showErrorMessage - Whether to show error message.
         * @property {string} inputMessage - The data validator input message.
         * @property {string} inputTitle - The data validator input title.
         * @property {boolean} showInputMessage - Whether to show input message.
         * @property {GCTYPE.Data.HighlightStyle} highlightStyle - The data validator highlight style.
         */
        export type FormulaValidatorOptions =
            {
                type: "formula";
                formula: GCTYPE.Data.FormulaString;
                errorStyle: GCTYPE.Data.ErrorStyle;
                errorTitle: string;
                errorMessage: string;
                highlightStyle: GCTYPE.Data.HighlightStyle;
                ignoreBlank: boolean;
                inCellDropdown: boolean;
                inputMessage: string;
                inputTitle: string;
                showErrorMessage: boolean;
                showInputMessage: boolean;
            }


        /**
         * @typedef GCTYPE.Data.GradientFillOptions
         * @property {number} degree - The gradient fill degree.
         * @property {GCTYPE.Data.GradientStop[]} stops - The gradient fill stops.
         */
        export type GradientFillOptions =
            {
                degree?: number;
                stops: GCTYPE.Data.GradientStop[];
            }


        /**
         * @typedef GCTYPE.Data.GradientPathFillOptions
         * @property {string} type - The gradient path fill type, supports "path."
         * @property {number} left - The gradient path fill left.
         * @property {number} right - The gradient path fill right.
         * @property {number} top - The gradient path fill top.
         * @property {number} bottom - The gradient path fill bottom.
         * @property {GCTYPE.Data.GradientStop[]} stops - The gradient path fill stops.
         */
        export type GradientPathFillOptions =
            {
                type: "path";
                left?: number;
                right?: number;
                top?: number;
                bottom?: number;
                stops: GCTYPE.Data.GradientStop[];
            }


        /**
         * @typedef GCTYPE.Data.GradientStop
         * @property {string} color - The gradient stop color.
         * @property {number} position - The gradient stop position.
         */
        export type GradientStop =
            {
                color: string;
                position: number;
            }


        /**
         * @typedef GCTYPE.Data.HighlightStyle
         * @property {"circle" | "dogEar" | "icon"} type - The highlight type.
         * @property {GCTYPE.Data.ColorString} color - The highlight color.
         * @property {"topLeft" | "topRight" | "bottomRight" | "bottomLeft" | "outsideLeft" | "outsideRight"} position - The highlight position.
         * @property {string} image - The highlight image, it could be an url or base64 data.
         */
        export type HighlightStyle =
            {
                type?: "circle" | "dogEar" | "icon";
                color?: string;
                position: "topLeft" | "topRight" | "bottomRight" | "bottomLeft" | "outsideLeft" | "outsideRight";
                image?: string;
            }


        /**
         * @typedef GCTYPE.Data.HyperlinkOptions
         * @property {string} type - The type of the cell type, supports "hyperlink".
         * @property {string} linkColor - The color of the link.
         * @property {string} visitedLinkColor - The color of the visited link.
         * @property {string} text - The text of the link.
         * @property {string} linkToolTip - The tooltip of the link.
         * @property {string} target - The type of the link's target, which support "blank", "self", "parent", "top".
         * @property {boolean} activeOnClick - Whether to move to the active cell when clicked.
         */
        export type HyperlinkOptions =
            {
                type: "hyperlink";
                linkColor: string;
                visitedLinkColor: string;
                text: string;
                linkToolTip: string;
                target: "blank" | "self" | "parent" | "top";
                activeOnClick: boolean;
            }


        /**
         * @typedef GCTYPE.Data.IconOptions - The icon options.
         * @property {GCTYPE.Data.IconSetType} iconSetType - The icon value type.
         * @property {number} iconIndex - The custom icon index
         */
        export type IconOptions =
            {
                iconSetType: GCTYPE.Data.IconSetType;
                iconIndex: number;
            }


        /**
         * @typedef GCTYPE.Data.IconSetRuleOptions - The options of icon set rule.
         * @property {"iconSetRule"} ruleType - The rule type if you want to use icon set rule.
         * @property {GCTYPE.Data.IconSetType} iconSetType - The icon set type.
         * @property {boolean} reverseIconOrder - Whether to reverse icon order.
         * @property {boolean} showIconOnly - Whether to display the icon only.
         * @property {Array.<GCTYPE.Data.IconOptions>} icons - The array of icon options.
         * @property {number} priority - The priority of the rule.
         * @property {boolean} stopIfTrue - Whether rules with lower priority are applied before this rule.
         */
        export type IconSetRuleOptions =
            {
                ruleType: "iconSetRule";
                iconSetType: GCTYPE.Data.IconSetType;
                reverseIconOrder: boolean;
                showIconOnly: boolean;
                icons: GCTYPE.Data.IconOptions[];
                priority: number;
                stopIfTrue: boolean;
            }


        /**
         * @typedef GCTYPE.Data.IconSetType
         * @type {"threeArrowsColored"|"threeArrowsGray"|"threeTriangles"|"threeStars"|"threeFlags"|"threeTrafficLightsUnrimmed"|"threeTrafficLightsRimmed"|"threeSigns"|"threeSymbolsCircled"|"threeSymbolsUncircled"|"fourArrowsColored"|"fourArrowsGray"|"fourRedToBlack"|"fourRatings"|"fourTrafficLights"|"fiveArrowsColored"|"fiveArrowsGray"|"fiveRatings"|"fiveQuarters"|"fiveBoxes"|"noIcons"}
         * @description The icon set type.
         */
        export type IconSetType =
            "threeArrowsColored"|"threeArrowsGray"|"threeTriangles"|"threeStars"|"threeFlags"|"threeTrafficLightsUnrimmed"|"threeTrafficLightsRimmed"|"threeSigns"|"threeSymbolsCircled"|"threeSymbolsUncircled"|"fourArrowsColored"|"fourArrowsGray"|"fourRedToBlack"|"fourRatings"|"fourTrafficLights"|"fiveArrowsColored"|"fiveArrowsGray"|"fiveRatings"|"fiveQuarters"|"fiveBoxes"|"noIcons"


        /**
         * @typedef GCTYPE.Data.IconValueType
         * @type {"number"|"percent"|"formula"|"percentile"}
         * @description The icon value type.
         */
        export type IconValueType =
            "number"|"percent"|"formula"|"percentile"


        /**
         * @typedef GCTYPE.Data.ItemOptions
         * @property {string} text - The item text.
         * @property {Object} value - The item value, could be a number, string, boolean, Date.
         */
        export type ItemOptions =
            {
                text: string;
                value: any;
            }


        /**
         * @typedef GCTYPE.Data.LabelOptions
         * @property {string} alignment - The cell label position, which supports "topLeft", "topCenter", "topRight", "bottomLeft", "bottomCenter", "bottomRight".
         * @property {string} visibility - The cell label visibility, which supports "visible", "hidden", "auto".
         * @property {string} font - The cell label font.
         * @property {string} foreColor - The cell label foreground color.
         * @property {string} margin - The cell label margin.
         */
        export type LabelOptions =
            {
                alignment: "topLeft" | "topCenter" | "topRight" | "bottomLeft" | "bottomCenter" | "bottomRight";
                visibility: "visible" | "hidden" | "auto";
                font: string;
                foreColor: string;
                margin: string;
            }


        /**
         * @typedef GCTYPE.Data.LineBorder
         * @property {string} color - The border color.
         * @property {string} style - The border style, which supports "empty", "thin", "medium", "dashed", "dotted", "thick", "double", "hair", "mediumDashed", "dashDot", "mediumDashDot", "dashDotDot", "mediumDashDotDot", "slantedDashDot".
         */
        export type LineBorder =
            {
                color: string;
                style: "empty" | "thin" | "medium" | "dashed" | "dotted" | "thick" | "double" | "hair" | "mediumDashed" | "dashDot" | "mediumDashDot" | "dashDotDot" | "mediumDashDotDot" | "slantedDashDot";
            }


        /**
         * @typedef GCTYPE.Data.ListItem
         * @property {string} text - The item text.
         * @property {string} value - The item value.
         * @property {string} icon - The item icon.
         */
        export type ListItem =
            {
                text?: string;
                value?: string;
                icon?: string;
            }


        /**
         * @typedef GCTYPE.Data.ListLayout
         * @property {string} direction - The layout direction, which accepts "horizontal", "vertical".
         * @property {string} displayAs - The layout display, which accepts "inline", "popup", "tree".
         * @property {boolean} collapsible - Whether the list can be collapsed.
         */
        export type ListLayout =
            {
                direction?: "horizontal" | "vertical";
                displayAs?: "inline" | "popup" | "tree";
                collapsible?: boolean;
            }


        /**
         * @typedef GCTYPE.Data.ListOptions
         * @property {string} text - The text.
         * @property {GCTYPE.Data.ListLayout} layout - The layout.
         * @property {boolean} multiSelect - Whether to set the list to multi-select.
         * @property {string} valueType - The cell value type of dropdown list result, which accepts "string", "array".
         * @property {GCTYPE.Data.ListItem[] | GCTYPE.Data.ListOptions[] | Function} items - The items. Usually, it accepts an array. Specially, when it accepts a function, the function should returns a DOM element.
         * @property {Function} onItemSelected - It is used when items or sub-items are selected.
         */
        export type ListOptions =
            {
                text?: string;
                layout?: GCTYPE.Data.ListLayout;
                multiSelect?: boolean;
                valueType?: "string" | "array";
                items: GCTYPE.Data.ListItem[] | GCTYPE.Data.ListOptions[] | (() => HTMLElement); // a function returns a DOM element
                onItemSelected?: (e: MouseEvent) => string; // used when items or sub-items is (() => HTMLElement)
            }


        /**
         * @typedef GCTYPE.Data.ListString
         * @type {string}
         * @description The list type string, such as "1,2,3".
         */
        export type ListString =
            string


        /**
         * @typedef GCTYPE.Data.ListValidatorOptions
         * @property {"list"} type - The data validator type.
         * @property {GCTYPE.Data.ListString} source - The data validator source.
         * @property {boolean} ignoreBlank - Whether to ignore empty value.
         * @property {boolean} inCellDropdown - Whether to display a drop-down button.
         * @property {GCTYPE.Data.ErrorStyle} errorStyle - The data validator error style.
         * @property {string} errorTitle - The data validator error title.
         * @property {string} errorMessage - The data validator error message.
         * @property {boolean} showErrorMessage - Whether to show error message.
         * @property {string} inputMessage - The data validator input message.
         * @property {string} inputTitle - The data validator input title.
         * @property {boolean} showInputMessage - Whether to show input message.
         * @property {GCTYPE.Data.HighlightStyle} highlightStyle - The data validator highlight style.
         */
        export type ListValidatorOptions =
            {
                type: "list";
                source: GCTYPE.Data.ListString;
                errorStyle: GCTYPE.Data.ErrorStyle;
                errorTitle: string;
                errorMessage: string;
                highlightStyle: GCTYPE.Data.HighlightStyle;
                ignoreBlank: boolean;
                inCellDropdown: boolean;
                inputMessage: string;
                inputTitle: string;
                showErrorMessage: boolean;
                showInputMessage: boolean;
            }


        /**
         * @typedef GCTYPE.Data.MonthPickerOptions
         * @property {number} startYear - The month picker's start year, default value is ten year ago.
         * @property {number} stopYear - The month picker's stop year, default value is this year.
         * @property {number} height - The dom's height of month picker, default value is 300.
         */
        export type MonthPickerOptions =
            {
                startYear: number;
                stopYear: number;
                height: number;
            }


        /**
         * @typedef GCTYPE.Data.MultiColumnOptions
         * @property {number} width - User can customize the width for multi-column dropdown. By default, it is the min value between 800 and the result of auto calculated all the column width.
         * @property {number} height - User can customize the height for multi-column dropdown. By default, it is the min value between 400 and the result of auto calculated all the row height.
         * @property {string | Object[]} dataSource - User should specify the dataSource for binding.The dataSource is required, supports array or formula which return an array.
         * @property {GCTYPE.Data.ColumnBindingInfo[]} bindingInfos - User can customize the bound column infos.
         */
        export type MultiColumnOptions =
            {
                width?: number;
                height?: number;
                dataSource: string | any[];
                bindingInfos?: GCTYPE.Data.ColumnBindingInfo[];
            }


        /**
         * @typedef GCTYPE.Data.NumberValidatorOptions
         * @property {"number"} type - The data validator type.
         * @property {GCTYPE.Data.CellValueComparisionOperator} comparisonOperator - The data validator comparison operator.
         * @property {number | GCTYPE.Data.FormulaString} value1 - The data validator first value.
         * @property {number | GCTYPE.Data.FormulaString} value2 - The data validator second value if validator comparison operator is "between" or "notBetween".
         * @property {boolean} isIntegerValue - Is it an integer value if the validator type if "number".
         * @property {boolean} ignoreBlank - Whether to ignore empty value.
         * @property {boolean} inCellDropdown - Whether to display a drop-down button.
         * @property {GCTYPE.Data.ErrorStyle} errorStyle - The data validator error style.
         * @property {string} errorTitle - The data validator error title.
         * @property {string} errorMessage - The data validator error message.
         * @property {boolean} showErrorMessage - Whether to show error message.
         * @property {string} inputMessage - The data validator input message.
         * @property {string} inputTitle - The data validator input title.
         * @property {boolean} showInputMessage - Whether to show input message.
         * @property {GCTYPE.Data.HighlightStyle} highlightStyle - The data validator highlight style.
         */
        export type NumberValidatorOptions =
            {
                type: "number";
                comparisonOperator: GCTYPE.Data.CellValueComparisionOperator;
                value1: number | GCTYPE.Data.FormulaString;
                value2?: number | GCTYPE.Data.FormulaString;
                isIntegerValue: boolean;
                errorStyle: GCTYPE.Data.ErrorStyle;
                errorTitle: string;
                errorMessage: string;
                highlightStyle: GCTYPE.Data.HighlightStyle;
                ignoreBlank: boolean;
                inCellDropdown: boolean;
                inputMessage: string;
                inputTitle: string;
                showErrorMessage: boolean;
                showInputMessage: boolean;
            }


        /**
         * @typedef GCTYPE.Data.PatternFillOptions
         * @property {string} type - The pattern fill type, which supports "solid", "darkGray", "mediumGray", "lightGray", "gray125", "gray0625", "darkHorizontal", "darkVertical", "darkDown", "darkUp", "darkGrid", "darkTrellis", "lightHorizontal", "lightVertical", "lightDown", "lightUp", "lightGrid" and "lightTrellis".
         * @property {string} patternColor - the pattern fill color.
         * @property {string} backgroundColor - the pattern fill background color.
         */
        export type PatternFillOptions =
            {
                type: "solid" | "darkGray" | "mediumGray" | "lightGray" | "gray125" | "gray0625" | "darkHorizontal" | "darkVertical" | "darkDown" | "darkUp" | "darkGrid" | "darkTrellis" | "lightHorizontal" | "lightVertical" | "lightDown" | "lightUp" | "lightGrid" | "lightTrellis";
                patternColor: string;
                backgroundColor?: string;
            }


        /**
         * @typedef GCTYPE.Data.RadioButtonCheckboxListOptions
         * @property {string} type - The type of the cell type, supports "radioButtonList","checkboxList".
         * @property {GCTYPE.Data.ItemOptions[]} items - The items, which supports Object Array which each item contains text and value.
         * @property {string} direction - The the radio box or check box's orders, which support "horizontal", "vertical".
         * @property {number} maxColumnCount - The the radio box or check box's column count.
         * @property {number} maxRowCount - The the radio box or check box's row count.
         * @property {boolean} isFlowLayout - The the radio box or check box's layout is auto fit.
         * @property {Object} itemSpacing - The space for two items.
         * @property {number} itemSpacing.horizontal - The space for two items in horizontal direction.
         * @property {number} itemSpacing.vertical - The space for two items in vertical direction.
         * @property {string} textAlign - The text alignment relative to the radio box or check box, which supports "left", "right".
         * @property {number} boxSize - The radio box or check box size.
         */
        export type RadioButtonCheckboxListOptions =
            {
                type: "radioButtonList" | "checkboxList";
                items: GCTYPE.Data.ItemOptions[];
                direction: "horizontal" | "vertical";
                maxColumnCount: number;
                maxRowCount: number;
                isFlowLayout: boolean;
                itemSpacing: { horizontal: number; vertical: number };
                textAlign: "left" | "right";
                boxSize: number;
            }


        /**
         * @typedef GCTYPE.Data.ScaleValueType
         * @type {"number"|"lowestValue"|"highestValue"|"percent"|"percentile"|"automin"|"formula"|"automax"}
         * @description The scale value type.
         */
        export type ScaleValueType =
            "number"|"lowestValue"|"highestValue"|"percent"|"percentile"|"automin"|"formula"|"automax"


        /**
         * @typedef GCTYPE.Data.SliderOptions
         * @property {boolean} scaleVisible - Whether the thumb can drag over tick only, default value is false.
         * @property {number} max - The maximum value the slider can slide to, default value is 100.
         * @property {number} min - The minimum value the slider can slide to, default value is 0.
         * @property {number} step - The granularity that the slider can step through values. Must greater than 0, and be divided by (max - min). When marks no null, step can be null, default value is 1.
         * @property {boolean} tooltipVisible - If true, tooltip will show always, or it will not show anyway, even if dragging or hovering, default value is false.
         * @property {number} width - The slider's width when direction is horizontal, default value is 350.
         * @property {number} height - The slider's height when direction is vertical, default value is 350.
         * @property {string} direction - The direction of slider, which accepts "horizontal", "vertical", and default value is horizontal.
         * @property {number[]} marks - The tick mark of slider.
         * @property {string} formatString - The display formatter, that used to tooltip or marks.
         */
        export type SliderOptions =
            {
                scaleVisible: boolean;
                max: number;
                min: number;
                step: number;
                tooltipVisible: boolean;
                width: number;
                height: number;
                direction: "horizontal" | "vertical";
                marks: number[];
                formatString: string;
            }


        /**
         * @typedef GCTYPE.Data.SpecificTextComparisionOperator
         * @type {"contains"|"doesNotContain"|"beginsWith"|"endsWith"}
         * @description The specific text comparision operator.
         */
        export type SpecificTextComparisionOperator =
            "contains"|"doesNotContain"|"beginsWith"|"endsWith"


        /**
         * @typedef GCTYPE.Data.SpecificTextRuleOptions - The options of specific text rule.
         * @property {"specificTextRule"} ruleType - The rule type if you want to use specific text rule.
         * @property {GCTYPE.Data.SpecificTextComparisionOperator} comparisionOperator - The comparision operator of specific text.
         * @property {string} text - The specific text.
         * @property {GCTYPE.Data.StyleOptions} style - The style that is applied to the cell when the condition is met.
         * @property {number} priority - The priority of the rule.
         * @property {boolean} stopIfTrue - Whether rules with lower priority are applied before this rule.
         */
        export type SpecificTextRuleOptions =
            {
                ruleType: "specificTextRule";
                comparisionOperator: GCTYPE.Data.SpecificTextComparisionOperator;
                text: string;
                style: GCTYPE.Data.StyleOptions;
                priority: number;
                stopIfTrue: boolean;
            }


        /**
         * @typedef GCTYPE.Data.StyleOptions
         * @property {string | GCTYPE.Data.PatternFillOptions | GCTYPE.Data.GradientFillOptions | GCTYPE.Data.GradientPathFillOptions} backColor - The background color string or pattern fill options, gradient fill options, gradient path fill options.
         * @property {string} foreColor - The foreground color.
         * @property {string} hAlign - The horizontal alignment, which supports "left", "center", "right", "general".
         * @property {string} vAlign - The vertical alignment, which supports "top", "center", "bottom".
         * @property {string} font - The font.
         * @property {string} themeFont - The theme font.
         * @property {string} formatter - The formatter string.
         * @property {GCTYPE.Data.LineBorder} borderLeft - The left border.
         * @property {GCTYPE.Data.LineBorder} borderTop - The top border.
         * @property {GCTYPE.Data.LineBorder} borderRight - The right border.
         * @property {GCTYPE.Data.LineBorder} borderBottom - The bottom border.
         * @property {GCTYPE.Data.LineBorder} diagonalDown - The diagonal with LeftTop to bottomRight.
         * @property {GCTYPE.Data.LineBorder} diagonalUp - The diagonal with topRight to bottomLeft.
         * @property {boolean} locked - Whether the cell, row, or column is locked.
         * @property {number} textIndent - The text indent amount.
         * @property {boolean} wordWrap - Whether words wrap within the cell or cells.
         * @property {boolean} shrinkToFit - Whether content shrinks to fit the cell or cells.
         * @property {string} backgroundImage - The background image to display.
         * @property {GCTYPE.Data.CheckboxOptions | GCTYPE.Data.ComboBoxOptions | GCTYPE.Data.HyperlinkOptions | GCTYPE.Data.RadioButtonCheckboxListOptions} cellType - The cell type.
         * @property {string} backgroundImageLayout - The layout for the background image, which supports "stretch", "center", "zoom", "none".
         * @property {boolean} tabStop - Whether the user can set focus to the cell using the Tab key.
         * @property {string} textDecoration - The decoration added to text, which supports "underline", "lineThrough", "overline", "doubleUnderline", "none".
         * @property {string} imeMode - The input method editor mode, which supports "auto", "active", "inactive", "disabled".
         * @property {string} name - The name.
         * @property {string} parentName - The name of the parent style.
         * @property {string} watermark - The watermark content.
         * @property {string} cellPadding - The cell padding.
         * @property {GCTYPE.Data.LabelOptions} labelOptions - The cell label options.
         * @property {boolean} isVerticalText - Whether to set the cell's text vertical.
         * @property {number} textOrientation - The cell text rotation angle.
         * @property {boolean} showEllipsis - Whether the text out of bounds shows ellipsis.
         * @property {GCTYPE.Data.CellButtonOptions[]} cellButtons - The cell buttons.
         * @property {GCTYPE.Data.DropDownOptions[]} dropDowns - The drop downs.
         */
        export type StyleOptions =
            {
                backColor?: string | GCTYPE.Data.PatternFillOptions | GCTYPE.Data.GradientFillOptions | GCTYPE.Data.GradientPathFillOptions;
                foreColor?: string;
                hAlign?: "left" | "center" | "right" | "general";
                vAlign?: "top" | "center" | "bottom";
                font?: string;
                themeFont?: string;
                formatter?: string;
                borderLeft?: GCTYPE.Data.LineBorder;
                borderTop?: GCTYPE.Data.LineBorder;
                borderRight?: GCTYPE.Data.LineBorder;
                borderBottom?: GCTYPE.Data.LineBorder;
                diagonalDown?: GCTYPE.Data.LineBorder;
                diagonalUp?: GCTYPE.Data.LineBorder;
                locked?: boolean;
                textIndent?: number;
                wordWrap?: boolean;
                shrinkToFit?: boolean;
                backgroundImage?: string;
                cellType?: GCTYPE.Data.CheckboxOptions | GCTYPE.Data.ComboBoxOptions | GCTYPE.Data.HyperlinkOptions | GCTYPE.Data.RadioButtonCheckboxListOptions;
                backgroundImageLayout?: "stretch" | "center" | "zoom" | "none";
                tabStop?: boolean;
                textDecoration?: "underline" | "lineThrough" | "overline" | "doubleUnderline" | "none";
                imeMode?: "auto" | "active" | "inactive" | "disabled";
                name?: string;
                parentName?: string;
                watermark?: string;
                cellPadding?: string;
                labelOptions?: GCTYPE.Data.LabelOptions;
                isVerticalText?: boolean;
                textOrientation?: number;
                showEllipsis?: boolean;
                cellButtons?: GCTYPE.Data.CellButtonOptions[];
                dropDowns?: GCTYPE.Data.DropDownOptions[];
            }


        /**
         * @typedef GCTYPE.Data.TextLengthString
         * @type {string}
         * @description The text length type string, such as "10".
         */
        export type TextLengthString =
            string


        /**
         * @typedef GCTYPE.Data.TextLengthValidatorOptions
         * @property {"textLength"} type - The data validator type.
         * @property {GCTYPE.Data.CellValueComparisionOperator} comparisonOperator - The data validator comparison operator.
         * @property {GCTYPE.Data.TextLengthString | GCTYPE.Data.FormulaString} value1 - The data validator first value.
         * @property {GCTYPE.Data.TextLengthString | GCTYPE.Data.FormulaString} value2 - The data validator second value if validator comparison operator is "between" or "notBetween".
         * @property {boolean} ignoreBlank - Whether to ignore empty value.
         * @property {boolean} inCellDropdown - Whether to display a drop-down button.
         * @property {GCTYPE.Data.ErrorStyle} errorStyle - The data validator error style.
         * @property {string} errorTitle - The data validator error title.
         * @property {string} errorMessage - The data validator error message.
         * @property {boolean} showErrorMessage - Whether to show error message.
         * @property {string} inputMessage - The data validator input message.
         * @property {string} inputTitle - The data validator input title.
         * @property {boolean} showInputMessage - Whether to show input message.
         * @property {GCTYPE.Data.HighlightStyle} highlightStyle - The data validator highlight style.
         */
        export type TextLengthValidatorOptions =
            {
                type: "textLength";
                comparisonOperator: GCTYPE.Data.CellValueComparisionOperator;
                value1: GCTYPE.Data.TextLengthString | GCTYPE.Data.FormulaString;
                value2?: GCTYPE.Data.TextLengthString | GCTYPE.Data.FormulaString;
                errorStyle: GCTYPE.Data.ErrorStyle;
                errorTitle: string;
                errorMessage: string;
                highlightStyle: GCTYPE.Data.HighlightStyle;
                ignoreBlank: boolean;
                inCellDropdown: boolean;
                inputMessage: string;
                inputTitle: string;
                showErrorMessage: boolean;
                showInputMessage: boolean;
            }


        /**
         * @typedef GCTYPE.Data.ThreeScaleRuleOptions - The options of three scale rule.
         * @property {"threeScaleRule"} ruleType - The rule type if you want to use three scale rule.
         * @property {GCTYPE.Data.ScaleValueType} minType - The minimum scale type.
         * @property {number} minValue - The minimum scale value.
         * @property {GCTYPE.Data.ColorString} minColor - The minimum scale color string.
         * @property {GCTYPE.Data.ScaleValueType} midType - The midpoint scale type.
         * @property {number} midValue - The midpoint scale value.
         * @property {GCTYPE.Data.ColorString} midColor - The midpoint scale color string.
         * @property {GCTYPE.Data.ScaleValueType} maxType - The maximum scale type.
         * @property {number} maxValue - The maximum scale value.
         * @property {GCTYPE.Data.ColorString} maxColor - The maximum scale color string.
         * @property {number} priority - The priority of the rule.
         * @property {boolean} stopIfTrue - Whether rules with lower priority are applied before this rule.
         */
        export type ThreeScaleRuleOptions =
            {
                ruleType: "threeScaleRule";
                minType: GCTYPE.Data.ScaleValueType;
                minValue: number;
                minColor: GCTYPE.Data.ColorString;
                midType: GCTYPE.Data.ScaleValueType;
                midValue: number;
                midColor: GCTYPE.Data.ColorString;
                maxType: GCTYPE.Data.ScaleValueType;
                maxValue: number;
                maxColor: GCTYPE.Data.ColorString;
                priority: number;
                stopIfTrue: boolean;
            }


        /**
         * @typedef GCTYPE.Data.TimePickerOptions
         * @property {GCTYPE.Data.TimePickerValue} max - The maximum value the time picker can display, the value need hour, minute and second attribute.
         * @property {GCTYPE.Data.TimePickerValue} min - The minimum value the time picker can display, the value need hour, minute and second attribute.
         * @property {GCTYPE.Data.TimePickerValue} step - The granularity that the time picker can step through values.
         * @property {string} formatString - The format of the time item.
         * @property {number} height - The container of the time picker's size.
         */
        export type TimePickerOptions =
            {
                max: GCTYPE.Data.TimePickerValue;
                min: GCTYPE.Data.TimePickerValue;
                step: GCTYPE.Data.TimePickerValue;
                formatString: string;
                height: number;
            }


        /**
         * @typedef GCTYPE.Data.TimePickerValue
         * @property {number} hour - The hour of the value.
         * @property {number} minute - The minute of the value.
         * @property {number} second - The second of the value.
         */
        export type TimePickerValue =
            {
                hour: number;
                minute: number;
                second: number;
            }


        /**
         * @typedef GCTYPE.Data.TimeValidatorOptions
         * @property {"time"} type - The data validator type.
         * @property {GCTYPE.Data.CellValueComparisionOperator} comparisonOperator - The data validator comparison operator.
         * @property {Date | GCTYPE.Data.FormulaString} value1 - The data validator first value.
         * @property {Date | GCTYPE.Data.FormulaString} value2 - The data validator second value if validator comparison operator is "between" or "notBetween".
         * @property {boolean} ignoreBlank - Whether to ignore empty value.
         * @property {boolean} inCellDropdown - Whether to display a drop-down button.
         * @property {GCTYPE.Data.ErrorStyle} errorStyle - The data validator error style.
         * @property {string} errorTitle - The data validator error title.
         * @property {string} errorMessage - The data validator error message.
         * @property {boolean} showErrorMessage - Whether to show error message.
         * @property {string} inputMessage - The data validator input message.
         * @property {string} inputTitle - The data validator input title.
         * @property {boolean} showInputMessage - Whether to show input message.
         * @property {GCTYPE.Data.HighlightStyle} highlightStyle - The data validator highlight style.
         */
        export type TimeValidatorOptions =
            {
                type: "time";
                comparisonOperator: GCTYPE.Data.CellValueComparisionOperator;
                value1: Date | GCTYPE.Data.FormulaString;
                value2?: Date | GCTYPE.Data.FormulaString;
                errorStyle: GCTYPE.Data.ErrorStyle;
                errorTitle: string;
                errorMessage: string;
                highlightStyle: GCTYPE.Data.HighlightStyle;
                ignoreBlank: boolean;
                inCellDropdown: boolean;
                inputMessage: string;
                inputTitle: string;
                showErrorMessage: boolean;
                showInputMessage: boolean;
            }


        /**
         * @typedef GCTYPE.Data.Top10RuleOptions - The options of top-10 rule.
         * @property {"top10Rule"} ruleType - The rule type if you want to use top-10 rule.
         * @property {GCTYPE.Data.Top10Type} type - The top-10 type.
         * @property {number} rank - The number of top or bottom items to apply the style to.
         * @property {GCTYPE.Data.StyleOptions} style - The style that is applied to the cell when the condition is met.
         * @property {number} priority - The priority of the rule.
         * @property {boolean} stopIfTrue - Whether rules with lower priority are applied before this rule.
         */
        export type Top10RuleOptions =
            {
                ruleType: "top10Rule";
                type: GCTYPE.Data.Top10Type;
                rank: number;
                style: GCTYPE.Data.StyleOptions;
                priority: number;
                stopIfTrue: boolean;
            }


        /**
         * @typedef GCTYPE.Data.Top10Type
         * @type {"top"|"bottom"}
         * @description The top-10 type.
         */
        export type Top10Type =
            "top"|"bottom"


        /**
         * @typedef GCTYPE.Data.TwoScaleRuleOptions - The options of two scale rule.
         * @property {"twoScaleRule"} ruleType - The rule type if you want to use two scale rule.
         * @property {GCTYPE.Data.ScaleValueType} minType - The minimum scale type.
         * @property {number} minValue - The minimum scale value.
         * @property {GCTYPE.Data.ColorString} minColor - The minimum scale color string.
         * @property {GCTYPE.Data.ScaleValueType} maxType - The maximum scale type.
         * @property {number} maxValue - The maximum scale value.
         * @property {GCTYPE.Data.ColorString} maxColor - The maximum scale color string.
         * @property {number} priority - The priority of the rule.
         * @property {boolean} stopIfTrue - Whether rules with lower priority are applied before this rule.
         */
        export type TwoScaleRuleOptions =
            {
                ruleType: "twoScaleRule";
                minType: GCTYPE.Data.ScaleValueType;
                minValue: number;
                minColor: GCTYPE.Data.ColorString;
                maxType: GCTYPE.Data.ScaleValueType;
                maxValue: number;
                maxColor: GCTYPE.Data.ColorString;
                priority: number;
                stopIfTrue: boolean;
            }


        /**
         * @typedef GCTYPE.Data.UniqueRuleOptions - The options of unique rule.
         * @property {"uniqueRule"} ruleType - The rule type if you want to use unique rule.
         * @property {GCTYPE.Data.StyleOptions} style - The style that is applied to the cell when the condition is met.
         * @property {number} priority - The priority of the rule.
         * @property {boolean} stopIfTrue - Whether rules with lower priority are applied before this rule.
         */
        export type UniqueRuleOptions =
            {
                ruleType: "uniqueRule";
                style: GCTYPE.Data.StyleOptions;
                priority: number;
                stopIfTrue: boolean;
            }


        /**
         * @typedef GCTYPE.Data.WorkFlowItem
         * @property {string} value - The item value.
         * @property {number[]|string[]} transitions - The item transitions.
         */
        export type WorkFlowItem =
            {
                value: string;
                transitions: number[]|string[];
            }


        /**
         * @typedef GCTYPE.Data.WorkFlowOptions
         * @property {GCTYPE.Data.WorkFlowItem[]} items - The items.
         */
        export type WorkFlowOptions =
            {
                items: GCTYPE.Data.WorkFlowItem[];
            }


        export class DataManager{
            /**
             * Represents the data manager.
             * @class
             * @example
             * // Create a data manager
             * var dataManager = new GCTYPE.Data.DataManager();
             */
            constructor();
            /**
             * Represents the relationship array. Each relationship includes the following field,
             * @property {GCTYPE.Data.Table} sourceTable - The source table.
             * @property {string} sourceFieldName - The field name of the source table.
             * @property {string} sourceRelationshipName - The relationship name which can be used in source table.
             * @property {GCTYPE.Data.Table} targetTable - The target table.
             * @property {string} targetFieldName - The field name of the target table.
             * @property {string} targetRelationshipName - The relationship name which can be used in target table.
             * @type {Array<Object>}
             */
            relationships: GCTYPE.Data.IRelationship[];
            /**
             * Represents the table collection. Its key is table name, and value is GCTYPE.Data.Table instance.
             * @type {Object}
             */
            tables: GCTYPE.Data.ITables;
            /**
             * Adds a relationship into the data manager.
             * @param {GCTYPE.Data.Table} sourceTable - The source table, which foreign key is target table's primary key.
             * @param {string} sourceFieldName - The source field name.
             * @param {string} sourceRelationshipName - The source relationship name.
             * @param {GCTYPE.Data.Table} targetTable - The target table, which primary key is source table's foreign key.
             * @param {string} targetFieldName - The target field name.
             * @param {string} targetRelationshipName - The target relationship name.
             * @returns {Object} Returns the relationship.
             * @example
             * // Add relationship between products table and categories table
             * dataManager.addRelationship(productTable, "categoryId", "categories", categoriesTable, "id", "products");
             */
            addRelationship(sourceTable: GCTYPE.Data.Table,  sourceFieldName: string,  sourceRelationshipName: string,  targetTable: GCTYPE.Data.Table,  targetFieldName: string,  targetRelationshipName: string): GCTYPE.Data.IRelationship;
            /**
             * Add a table into the data manager.
             * @param {string} name - The table name.
             * @param {Object} dataSourceOption - The data source option for creating a table, which contains the following properties,
             * @property {string | Array.<Object>} data - The local data source, which could be an object array for JSON, a string for CSV or XML.
             * @property {Object} remote - The remote data source, which supports REST API, OData, GraphQL.
             * @property {Object} remote.read - The option that indicates where and how to read the remote data source.
             * @property {string} remote.read.url - The request url of read operation.
             * @property {string} remote.read.dataType - The request data type, supports 'json' and 'xml'. The default is 'json'.
             * @property {string} remote.read.adapter - Adapts different data protocol, supports "rest", "odata", "odata4" and "graphql".
             * @property {Object} remote.read.body - The request body.
             * @property {string} remote.read.method - The request method, such as 'GET', 'POST', 'PUT', 'DELETE'. The default is 'GET'.
             * @property {Object} remote.create - The option that indicates where and how to insert new row to the remote data source, when autoSync is true.
             * @property {string} remote.create.url - The request url of create operation.
             * @property {string} remote.create.dataType - The request data type, supports 'json' and 'xml'. The default is 'json'.
             * @property {string} remote.create.method - The request method, such as 'GET', 'POST', 'PUT', 'DELETE'. The default is 'POST'.
             * @property {Object} remote.update - The option that indicates where and how to update a row the remote data source, when autoSync is true.
             * @property {string} remote.update.url - The request url of update operation.
             * @property {string} remote.update.dataType - The request data type, supports 'json' and 'xml'. The default is 'json'.
             * @property {string} remote.update.method - The request method, such as 'GET', 'POST', 'PUT', 'DELETE'. The default is 'POST'.
             * @property {Object} remote.delete - The option that indicates where and how to delete a row the remote data source when autoSync is true.
             * @property {string} remote.delete.url - The request url of delete operation.
             * @property {string} remote.delete.dataType - The request data type, supports 'json' and 'xml'. The default is 'json'.
             * @property {string} remote.delete.method - The request method, such as 'GET', 'POST', 'PUT', 'DELETE'. The default is 'DELETE'.
             * @property {Object} remote.batch - The option that indicates where and how to batch update the remote data source, when batch is true.
             * @property {string} remote.batch.url - The request url of batch operation.
             * @property {string} remote.batch.dataType - The request data type, supports 'json' and 'xml'. The default is 'json'.
             * @property {string} remote.batch.method - The request method, such as 'GET', 'POST', 'PUT', 'DELETE'. The default is 'POST'.
             * @property {boolean} autoSync - In auto sync mode, data changes will be synced to server immediately.
             * @property {boolean} batch - In batch mode, data changes will be held in data source, user need invoke submitChanges method to sync server.
             * @property {Object} schema - The schema of data source.
             * @property {string} schema.type - The data type, should be one of 'json', 'csv', 'xml' or 'columnJson'. The default is 'json'.
             * @property {string} schema.count - The data reader use this to get data source collection length, return the current data source collection length if this is not specified.
             * @property {string} schema.data - The data reader use this to get data source collection after parse, return entire parsed object if this is not specified.
             * @returns {GCTYPE.Data.Table} Returns the table.
             * @example
             * // Add a sample table to read data
             * var tableName = "products";
             * var dataSourceOption = {
             *      remote: {
             *         read: {
             *             url: "https://demodata.grapecity.com/northwind/api/v1/products"
             *         }
             *     }
             * };
             * var dataManager = new GCTYPE.Data.DataManager();
             * var productTable = dataManager.addTable(tableName, dataSourceOption);
             */
            addTable(name: string,  dataSourceOption: GCTYPE.Data.IDataSourceOption): GCTYPE.Data.Table;
            /**
             * Removes a relationship from the data manager by source relationship name.
             * @param {string} name - The relationship name.
             * @example
             * // Remove a relationship from the data manager by source relationship name
             * dataManager.removeRelationship("categories");
             */
            removeRelationship(name: string): void;
            /**
             * Removes a table from the data manager.
             * @param {string} name - The table name.
             * @example
             * // Remove a table from data manager by table name
             * dataManager.removeTable("products");
             */
            removeTable(name: string): void;
        }

        export class Table{
            /**
             * Represents the table.
             * @class
             * @param {string} name - The table name.
             * @param {Object} dataSourceOption - The data source of table.
             */
            constructor(name: string,  dataSourceOption: GCTYPE.Data.IDataSourceOption);
            /**
             * Represents the default columns of the table, it is only available after table is fetched. The key is column name, the value is column information instance.
             * @type {Object}
             */
            columns: GCTYPE.Data.IColumnCollection;
            /**
             * Represents the name of the table.
             * @type {string}
             */
            name: string;
            /**
             * Represents the view collection of the table. The key is view name, the value is GCTYPE.Data.View instance.
             * @type {Object}
             */
            views: GCTYPE.Data.IViews;
            /**
             * Adds a view, which host table is current table.
             * @param {string} name - The view name.
             * @param {string[] | Object[]} [columnInfos] - The column information, each column includes the following properties.
             * @param {boolean} includeDefaultColumns - Whether to include current table's default columns when column information are empty. Its default value is true.
             * @property {string} name - The unique name of the column.
             * @property {string} [value] - The value of the column, could be a field name of table from database, or formula which uses the fields names.
             * @property {string} [caption] - The caption of the column, which is the key of row data.
             * @property {number | string} [width] - The width of the column, support number in pixel, or star size.
             * @property {GCTYPE.Data.StyleOptions} [style] - The style options.
             * @property {Array.<GCTYPE.Data.CellValueRuleOptions | GCTYPE.Data.SpecificTextRuleOptions | GCTYPE.Data.FormulaRuleOptions | GCTYPE.Data.DateOccurringRuleOptions | GCTYPE.Data.Top10RuleOptions | GCTYPE.Data.UniqueRuleOptions | GCTYPE.Data.DuplicateRuleOptions | GCTYPE.Data.AverageRuleOptions | GCTYPE.Data.TwoScaleRuleOptions | GCTYPE.Data.ThreeScaleRuleOptions | GCTYPE.Data.DataBarRuleOptions | GCTYPE.Data.IconSetRuleOptions>} [conditionalFormats] - The conditional rules array.
             * @property {GCTYPE.Data.NumberValidatorOptions | GCTYPE.Data.DateValidatorOptions | GCTYPE.Data.TimeValidatorOptions | GCTYPE.Data.TextLengthValidatorOptions | GCTYPE.Data.FormulaValidatorOptions | GCTYPE.Data.FormulaListValidatorOptions | GCTYPE.Data.ListValidatorOptions} [validators] - The default data validator.
             * @property {boolean} [isPrimaryKey] - Mark the column as primary key column.
             * @property {boolean} [readonly] - Mark the column is readonly.
             * @property {boolean} [required] - Mark the column is required when insert a new row.
             * @property {Object} [defaultValue] - Provide the default value when insert a new row, could be a const or a formula.
             * @returns {GCTYPE.Data.View} Returns the view.
             * @example
             * // Add a view by string array columns
             * productTable.addView("productView", [
             *     "id", "name", "reorderLevel", "unitPrice", "unitsInStock", "unitsOnOrder"
             * ]);
             *
             * // Add a view by customized columns
             * productTable.addView("productView", [{
             *     value: "id",
             *     caption: "ID",
             *     isPrimaryKey: true
             * }, {
             *     value: "name",
             *     caption: "NAME",
             *     required: true
             * }, {
             *     value: "quantityPerUnit",
             *     caption: "QUANTITY PER UNIT"
             * }, {
             *     value: "unitPrice",
             *     caption: "UNIT PRICE"
             * }, {
             *     value: "unitsInStock",
             *     caption: "UNITS IN STOCK",
             *     readonly: true
             * }, {
             *     value: "unitsOnOrder",
             *     caption: "UNITS ON ORDER"
             * }, {
             *     value: "reorderLevel",
             *     caption: "REORDER LEVEL"
             * }, {
             *     value: "discontinued",
             *     caption: "DISCONTINUED",
             *     defaultValue: false
             * });
             *
             * // Add a view with relationship columns
             * var supplierRelationship = dataManager.addRelationship(productTable, "supplierId", "supplier", supplierTable, "id", "products");
             * productTable.addView("productWithSupplierView", [{
             *     value: "id",
             *     caption: "ID"
             * }, {
             *     value: "name",
             *     caption: "NAME"
             * }, {
             *     value: "supplier.companyName", // relationship
             *     caption: "SUPPLIER NAME"
             * }, {
             *     value: "supplier.contactName", // relationship
             *     caption: "SUPPLIER CONTACT NAME"
             * }, {
             *     value: "supplier.contactTitle", // relationship
             *     caption: "SUPPLIER CONTACT TITLE"
             * });
             *
             * // Add a view with calc field columns
             * var supplierRelationship = dataManager.addRelationship(productTable, "supplierId", "supplier", supplierTable, "id", "products");
             * productTable.addView("productWithSupplierView", [{
             *     value: "id",
             *     caption: "ID"
             * }, {
             *     value: "name",
             *     caption: "NAME"
             * }, {
             *     caption: "TOTAL PRICE",
             *     value: "=(unitsInStock + unitsOnOrder) * unitPrice"
             * }, {
             *     caption: "SUPPLIER'S INFO",
             *     value: "=CONCAT(supplierTable.companyName, ', ', supplierTable.contactName)"
             * });
             *
             */
            addView(name: string,  columnInfos?: string[] | GCTYPE.Data.IColumn[],  includeDefaultColumns?: boolean): GCTYPE.Data.View;
            /**
             * Clear all the indexed fields.
             * @example
             * // Clear all the indexed fields.
             * table.clearIndexes();
             */
            clearIndexes(): void;
            /**
             * Create index for the fields.
             * @param {Array} fields The index fields.
             * @example
             * // Create indexes.
             * table.createIndexes(["name", "country", "project"]);
             */
            createIndexes(fields: string[]): void;
            /**
             * Drop indexed fields.
             * @param {Array} fields The indexed fields.
             * @example
             * // Drop indexed fields.
             * table.dropIndexes(["name", "country", "project"]);
             */
            dropIndexes(fields: string[]): void;
            /**
             * Requests the table data from local data source or remote data source by the data source option.
             * @returns {Promise} The resolving Promise thenable. You could get the data in Promise.then().
             * @example
             * // Use fetched data to build a tablesheet
             * productTable.fetch().then(function(data) {
             *     var productView = productTable.addView("productView");
             *     var tableSheet = new GCTYPE.Spread.Sheets.TableSheet.TableSheet("productTableSheet", productView);
             *     spread.addSheetTab(0, tableSheet);
             * });
             */
            fetch(): Promise<any>;
            /**
             * Get all the indexed fields.
             * @returns {Array} The indexed fields.
             * @example
             * // Indexed fields exist.
             * table.getIndexes(); // returns ["name", "country", "project"]
             * // No indexed field.
             * table.getIndexes(); // returns []
             */
            getIndexes(): string[];
            /**
             * Removes a view.
             * @param {string} name - The name of the view to be removed.
             * @example
             * // Remove a view by name
             * dataManager.removeView("productView");
             */
            removeView(name: string): void;
            /**
             * Search the records with search value, returns all the exact matching records.
             * @param {Object} value The search value. Always convert the non-string to string type.
             * @param {string} field The target field.
             * @returns {Array} The all matching records.
             * @example
             * // Search value and succeed
             * table.search("SpreadJS", "group"); // returns [ {id: 1, project: "DataManager", group: "SpreadJS"}, {id: 3, project: "TableSheet", group: "SpreadJS"} ]
             * // Search value and failed
             * table.search("WPS", "project"); // returns []
             */
            search(value: any,  field: string): any[];
        }

        export class View{
            /**
             * Represents the view.
             * @class
             * @param {string} name - The view name.
             * @param {string[] | Object[]} [columnInfos] - The column information, each column includes the following fields.
             * @param {boolean} includeDefaultColumns - Whether to include current table's default columns when column information are empty. Its default value is true.
             * @property {string} name - The unique name of the column.
             * @property {string} [value] - The value of the column, could be a field name of table from database, or formula which uses the fields names.
             * @property {string} [caption] - The caption of the column, which is the key of row data.
             * @property {number | string} [width] - The width of the column, support number in pixel, or star size.
             * @property {GCTYPE.Data.StyleOptions} [style] - The style.
             * @property {Array.<GCTYPE.Data.CellValueRuleOptions | GCTYPE.Data.SpecificTextRuleOptions | GCTYPE.Data.FormulaRuleOptions | GCTYPE.Data.DateOccurringRuleOptions | GCTYPE.Data.Top10RuleOptions | GCTYPE.Data.UniqueRuleOptions | GCTYPE.Data.DuplicateRuleOptions | GCTYPE.Data.AverageRuleOptions | GCTYPE.Data.TwoScaleRuleOptions | GCTYPE.Data.ThreeScaleRuleOptions | GCTYPE.Data.DataBarRuleOptions | GCTYPE.Data.IconSetRuleOptions>} [conditionalFormats] - The conditional rules array.
             * @property {GCTYPE.Data.NumberValidatorOptions | GCTYPE.Data.DateValidatorOptions | GCTYPE.Data.TimeValidatorOptions | GCTYPE.Data.TextLengthValidatorOptions | GCTYPE.Data.FormulaValidatorOptions | GCTYPE.Data.FormulaListValidatorOptions | GCTYPE.Data.ListValidatorOptions} [validators] - The default data validator.
             * @property {boolean} [isPrimaryKey] - Mark the column as primary key column.
             * @property {boolean} [readonly] - Mark the column is readonly.
             * @property {boolean} [required] - Mark the column is required when insert a new row.
             * @property {Object} [defaultValue] - Provide the default value when insert a new row, could be a const or a formula.
             * @returns {GCTYPE.Data.View} Returns the view.
             * /
             ///* field name: string
             /**
             * Represents the name of the view.
             * @type {string}
             */
            constructor(name: string,  columnInfos?: string[] | GCTYPE.Data.IColumn[],  includeDefaultColumns?: boolean);
            /**
             * Whether to filter again after data is changed. Its default value is true.
             * @type {string}
             */
            autoRefilter: boolean;
            /**
             * Whether to sort again after data is changed. Its default value is true.
             * @type {string}
             */
            autoResort: boolean;
            /**
             * Adds a column into current view.
             * @param {string | Object} column - The column string or object. When the parameter is a string, the column name and value are the string.
             * @example
             * // Add columns to view
             * var productTable = dataManager.addTable("products", {
             *      remote: {
             *         read: {
             *             url: "https://demodata.grapecity.com/northwind/api/v1/products"
             *         }
             *     }
             * });
             * var productView = productTable.addView("productView", [ "id", "name" ]);
             * productTable.fetch().then(function() {
             *     productView.addColumn("reorderLevel");
             *     productView.addColumn({ value: "unitPrice", caption: "UNIT PRICE" });
             * });
             */
            addColumn(column: string | GCTYPE.Data.IColumn): void;
            /**
             * Requests the view data from its host table and related table.
             * @returns {Promise} The resolving Promise thenable. You could get the data in Promise.then().
             * @example
             * // Set tablesheet with custom view
             * var tablesheet = new GCTYPE.Spread.Sheets.TableSheet.TableSheet("TableSheet1");
             * var dataManager = new GCTYPE.Data.DataManager();
             * var productTable = dataManager.addTable("productTable", {
             *     remote: {
             *         read: {
             *             url: "https://demodata.grapecity.com/northwind/api/v1/products"
             *         }
             *     }
             * });
             * var productView = productTable.addView("productView", [
             *     "id", "name", "reorderLevel", "unitPrice", "unitsInStock", "unitsOnOrder"
             * ]);
             * productView.fetch().then(function () {
             *     // set data source with a View
             *     tablesheet.setDataView(productView);
             * });
             */
            fetch(): Promise<any>;
            /**
             * Gets a column of current view.
             * @param {number} [index] - The column index.
             * @returns {Object | Array<Object>} Returns a column by the specified index, or returns all columns when the parameter is omitted.
             * @example
             * // Get all columns
             * var allColumns = productWithSupplierView.getColumn();
             * // Get the second column
             * var column1 = productWithSupplierView.getColumn(1);
             */
            getColumn(index?: number): GCTYPE.Data.IColumn | GCTYPE.Data.IColumn[];
            /**
             * Removes a column from current view.
             * @param column - The column value.
             * @example
             * // Remove a column
             * productWithSupplierView.removeColumn("discontinued");
             */
            removeColumn(column: string): void;
        }
    }

    module Pivot{

        export interface ICustomSortCallBack{
            (fieldItemNameArray: any[], sortInfo: GCTYPE.Pivot.IPivotCustomSortInfo) : any[];
        }


        export interface IPivotCustomSortInfo{
            sortType: GCTYPE.Pivot.SortType;
            isDate?: boolean;
        }


        /**
         * @typedef {object} GCTYPE.Pivot.IDataPosition
         * @property {boolean} [display]
         * @property {GCTYPE.Pivot.DataPosition}
         * @property {number}
         */
        export type IDataPosition =
            {
                display?: boolean;
                positionType: GCTYPE.Pivot.DataPosition;
                positionIndex: number;
            }


        /**
         * @typedef {object} GCTYPE.Pivot.IPivotCaptionConditionFilterInfo
         * @property {GCTYPE.Pivot.PivotConditionType} conType
         * @property {string[]} val
         * @property {GCTYPE.Pivot.PivotCaptionFilterOperator} operator
         */
        export type IPivotCaptionConditionFilterInfo =
            {
                conType: GCTYPE.Pivot.PivotConditionType;
                val: string[];
                operator: GCTYPE.Pivot.PivotCaptionFilterOperator;
            }


        /**
         * @typedef {object} GCTYPE.Pivot.IPivotDateConditionFilterInfo
         * @property {GCTYPE.Pivot.PivotConditionType} conType
         * @property {Date[]} val
         * @property {GCTYPE.Pivot.PivotDateFilterOperator} operator
         * @property {boolean} isWholeDay
         */
        export type IPivotDateConditionFilterInfo =
            {
                conType: GCTYPE.Pivot.PivotConditionType;
                val: Date[];
                operator: GCTYPE.Pivot.PivotDateFilterOperator;
                isWholeDay: boolean;
            }


        /**
         * @typedef {object} GCTYPE.Pivot.IPivotTop10ConditionFilterInfo
         * @property {GCTYPE.Pivot.PivotConditionType} conType
         * @property {number} val
         * @property {GCTYPE.Pivot.PivotTop10FilterType} type
         * @property {GCTYPE.Pivot.PivotTop10FilterOperator} operator
         */
        export type IPivotTop10ConditionFilterInfo =
            {
                conType: GCTYPE.Pivot.PivotConditionType;
                val: number;
                type: GCTYPE.Pivot.PivotTop10FilterType;
                operator: GCTYPE.Pivot.PivotTop10FilterOperator;
            }


        /**
         * @typedef {object} GCTYPE.Pivot.IPivotValueConditionInfo
         * @property {GCTYPE.Pivot.PivotConditionType} conType
         * @property {number[]} val
         * @property {GCTYPE.Pivot.PivotValueFilterOperator} operator
         */
        export type IPivotValueConditionInfo =
            {
                conType: GCTYPE.Pivot.PivotConditionType;
                val: number[];
                operator: GCTYPE.Pivot.PivotValueFilterOperator;
            }


        /**
         * @typedef {object} GCTYPE.Pivot.IPivotViewSortInfo
         * @property {GCTYPE.Pivot.ICustomSortCallBack} [customSortInfo]
         * @property {GCTYPE.Pivot.SortType} sortType
         * @property {string} [sortValueFieldName]
         */
        export type IPivotViewSortInfo =
            {
                sortType?: GCTYPE.Pivot.SortType;
                sortValueFieldName?: string;
                customSortInfo?: GCTYPE.Pivot.ICustomSortCallBack;
            }


        /**
         * @typedef GCTYPE.Pivot.IStringGroupItems
         * @property {Object.<string, string[] | number[]>}  -The group field items name and the matched items text.
         */
        export type IStringGroupItems =
            {
                [groupItemName: string]: (string | number)[];
            }

        /**
         * indicates the area where the Values is located
         * @enum {number}
         */
        export enum DataPosition{
            /**
             * Values is displayed in the row area
             */
            row= 0,
            /**
             * Values is displayed in the column area
             */
            col= 1,
            /**
             * Values does not show
             */
            none= 2
        }

        /**
         * indicates the date group type
         * @enum {number}
         */
        export enum DateGroupType{
            /**
             * seconds
             */
            seconds= 0,
            /**
             * minutes
             */
            minutes= 1,
            /**
             * hours
             */
            hours= 2,
            /**
             * days
             */
            days= 3,
            /**
             * months
             */
            months= 4,
            /**
             * quarters
             */
            quarters= 5,
            /**
             * years
             */
            years= 6
        }

        /**
         * Describe the type of caption filter
         * @enum {number}
         */
        export enum PivotCaptionFilterOperator{
            /**
             * Indicates whether the string is equal to a specified string.
             */
            equalsTo= 0,
            /**
             * Indicates whether the string is not equal to a specified string.
             */
            notEqualsTo= 1,
            /**
             * Indicates whether the string starts with a specified string.
             */
            beginsWith= 2,
            /**
             * Indicates whether the string does not start with a specified string.
             */
            doesNotBeginWith= 3,
            /**
             * Indicates whether the string ends with a specified string.
             */
            endsWith= 4,
            /**
             * Indicates whether the string does not end with a specified string.
             */
            doesNotEndWith= 5,
            /**
             * Indicates whether the string contains a specified string.
             */
            contains= 6,
            /**
             * Indicates whether the string does not contain a specified string.
             */
            doesNotContain= 7,
            /**
             * Indicates whether a value is greater than the parameter value.
             */
            greaterThan= 8,
            /**
             * Indicates whether a value is greater than or equal to the parameter value.
             */
            greaterThanOrEqualsTo= 9,
            /**
             * Indicates whether a value is less than the parameter value.
             */
            lessThan= 10,
            /**
             * Indicates whether a value is less than or equal to the parameter value.
             */
            lessThanOrEqualsTo= 11,
            /**
             * Indicates whether the number is between parameter values.
             */
            between= 12,
            /**
             * Indicates whether the number is not between parameter values.
             */
            notBetween= 13
        }

        /**
         * describe the type of filter
         *  @enum {number}
         */
        export enum PivotConditionType{
            /**
             * Indicates a text or number condition type.
             */
            caption= 0,
            /**
             * Indicates a date type condition.
             */
            date= 1,
            /**
             * Indicates number condition.
             */
            value= 2,
            /**
             * Indicates a specific condition which use for finding the top10 number .
             */
            top10= 3
        }

        /**
         * Indicates the field data type of pivot table.
         * @enum {number}
         */
        export enum PivotDataType{
            /**
             * number type
             */
            number= 0,
            /**
             * string type
             */
            string= 1,
            /**
             * date type
             */
            date= 2
        }

        /**
         * Describe the type of date filter
         * @enum {number}
         */
        export enum PivotDateFilterOperator{
            /**
             * Indicates whether the date time is equal to a certain time.
             */
            equalsTo= 0,
            /**
             * Indicates whether the date time is not equal to a certain time.
             */
            notEqualsTo= 1,
            /**
             * Indicates whether the date time is before a certain time.
             */
            before= 2,
            /**
             * Indicates whether the date time is before or equal to a certain time.
             */
            beforeEqualsTo= 3,
            /**
             * Indicates whether the date time is after a certain time.
             */
            after= 4,
            /**
             * Indicates whether the date time is after or equal to a certain time.
             */
            afterEqualsTo= 5,
            /**
             * Indicates whether the date time is between the certain time.
             */
            Between= 6,
            /**
             * Indicates whether the date time is not between the certain time.
             */
            notBetween= 7,
            /**
             * Specifies today.
             */
            today= 8,
            /**
             * Specifies yesterday.
             */
            yesterday= 9,
            /**
             * Specifies tomorrow.
             */
            tomorrow= 10,
            /**
             * Specifies the last seven days.
             */
            last7Days= 11,
            /**
             * Specifies this month.
             */
            thisMonth= 12,
            /**
             * Specifies last month.
             */
            lastMonth= 13,
            /**
             * Specifies next month.
             */
            nextMonth= 14,
            /**
             * Specifies this week.
             */
            thisWeek= 15,
            /**
             * Specifies last week.
             */
            lastWeek= 16,
            /**
             * Specifies next week.
             */
            nextWeek= 17,
            /**
             * Specifies next Quarter.
             */
            nextQuarter= 18,
            /**
             * Specifies this Quarter.
             */
            thisQuarter= 19,
            /**
             * Specifies last Quarter.
             */
            lastQuarter= 20,
            /**
             * Specifies next Year.
             */
            nextYear= 21,
            /**
             * Specifies this Year.
             */
            thisYear= 22,
            /**
             * Specifies last Year.
             */
            lastYear= 23,
            /**
             * Indicates the first quarter of a year.
             */
            Q1= 24,
            /**
             * Indicates the second quarter of a year.
             */
            Q2= 25,
            /**
             * Indicates the third quarter of a year.
             */
            Q3= 26,
            /**
             * Indicates the fourth quarter of a year.
             */
            Q4= 27,
            /**
             * Indicates the January of a year.
             */
            M1= 28,
            /**
             * Indicates the February of a year.
             */
            M2= 29,
            /**
             * Indicates the March of a year.
             */
            M3= 30,
            /**
             * Indicates the April of a year.
             */
            M4= 31,
            /**
             * Indicates the May of a year.
             */
            M5= 32,
            /**
             * Indicates the June of a year.
             */
            M6= 33,
            /**
             * Indicates the July of a year.
             */
            M7= 34,
            /**
             * Indicates the August of a year.
             */
            M8= 35,
            /**
             * Indicates the September of a year.
             */
            M9= 36,
            /**
             * Indicates the October of a year.
             */
            M10= 37,
            /**
             * Indicates the November of a year.
             */
            M11= 38,
            /**
             * Indicates the December of a year.
             */
            M12= 39,
            /**
             * Indicates the form Jan-1 to today in current year.
             */
            yearToDate= 40
        }

        /**
         * indicates the pivot table show value as  type
         * @enum {number}
         */
        export enum PivotShowDataAs{
            /**
             * no calculation
             */
            normal= 0,
            /**
             *  % of Grand Total
             */
            percentOfTotal= 1,
            /**
             * % of row Grand Total
             */
            percentOfRow= 2,
            /**
             * % of Column Grand Total
             */
            percentOfCol= 3,
            /**
             * % of
             */
            percent= 4,
            /**
             * % of Parent Row Total
             */
            percentOfParentRow= 5,
            /**
             * % of Parent Column Total
             */
            percentOfParentCol= 6,
            /**
             * % of Parent Total
             */
            percentOfParent= 7,
            /**
             * Difference from
             */
            difference= 8,
            /**
             * % difference from
             */
            percentDiff= 9,
            /**
             * running total in
             */
            runTotal= 10,
            /**
             * % of running total in
             */
            percentOfRunningTotal= 11,
            /**
             * rank smallest to largest
             */
            rankAscending= 12,
            /**
             * rank largest to smallest
             */
            rankDescending= 13,
            /**
             * index
             */
            index= 14
        }

        /**
         * Indicates the view layout type of pivot table.
         * @enum {number}
         */
        export enum PivotShowDataAsBaseItemType{
            /**
             * show data as base on a certain item of base field
             */
            item= 0,
            /**
             * show data as base on the next item of base field
             */
            next= 1,
            /**
             * show data as base on the previous item of base field
             */
            previous= 2
        }

        /**
         * Indicates the pivot field type of pivot table.
         * @enum {number}
         */
        export enum PivotSourceFieldType{
            /**
             * this is a calc field mark
             */
            isCalcField= 0,
            /**
             * this is a group field mark
             */
            isGroupField= 1
        }

        /**
         * Indicates that the interception is the front or back
         * @enum {number}
         */
        export enum PivotTop10FilterOperator{
            /**
             * Indicates that the interception is the front
             */
            top= 1,
            /**
             * Indicates that the interception is the back
             */
            bottom= -1
        }

        /**
         * Describes the type of filter
         * @enum {number}
         */
        export enum PivotTop10FilterType{
            /**
             * filter by count
             */
            count= 0,
            /**
             * filter by percent
             */
            percent= 1,
            /**
             * filter by sum
             */
            sum= 2
        }

        /**
         * describe the type of filter
         * @enum {number}
         */
        export enum PivotValueFilterOperator{
            /**
             * Determines whether a  value is equal to the parameter value.
             */
            equalsTo= 0,
            /**
             * Determines whether a  value is not equal to the parameter value.
             */
            notEqualsTo= 1,
            /**
             * Determines whether a  value is greater than the parameter value.
             */
            greaterThan= 2,
            /**
             * Determines whether a  value is greater than or equal to the parameter value.
             */
            greaterThanOrEqualsTo= 3,
            /**
             * Determines whether a  value is less than the parameter value.
             */
            lessThan= 4,
            /**
             * Determines whether a  value is less than or equal to the parameter value.
             */
            lessThanOrEqualsTo= 5,
            /**
             * Determines whether a  value is between the two parameter values.
             */
            between= 6,
            /**
             *Determines whether a cell value is not between the two parameter values.
             */
            notBetween= 7
        }

        /**
         * Indicates the pivot table sort type.
         * @enum {number}
         */
        export enum SortType{
            /**
             * Sort in ascending order
             */
            asc= 0,
            /**
             * Sort in descending order
             */
            desc= 1,
            /**
             * User-defined sort type
             */
            custom= 2
        }

        /**
         * Indicates the type of data subtotal
         * @enum {number}
         */
        export enum SubtotalType{
            /**
             * Average
             */
            average= 0,
            /**
             * Count
             */
            count= 1,
            /**
             * CountNums
             */
            countNums= 2,
            /**
             * Max
             */
            max= 3,
            /**
             * Min
             */
            min= 4,
            /**
             * Product
             */
            product= 5,
            /**
             * StdDev
             */
            stdDev= 6,
            /**
             * StdDevp
             */
            stdDevp= 7,
            /**
             * Sum
             */
            sum= 8,
            /**
             * Var
             */
            varr= 9,
            /**
             * Varp
             */
            varp= 10
        }

    }

    module Spread{
        module CalcEngine{
            /**
             * Gets or Sets the Excel Compatible Mode for CalcEngine. Default value is FALSE.
             * When ExcelCompatibleCalcMode disabled, SpreadJS will auto convert text to number for calculation.
             * When ExcelCompatibleCalcMode enabled, treated the text differently when provided as argument directly or in array / reference.
             * For example, A1 is text value "1", SUM(A1, 1) will be 2 if disabled, and 1 if enabled.
             */
            var ExcelCompatibleCalcMode: boolean;
            /**
             * Represents the expression type
             * @enum {number}
             */
            export enum ExpressionType{
                /**
                 * Specifies the unknow type
                 */
                unknow= 0,
                /**
                 * Specifies the reference type
                 */
                reference= 1,
                /**
                 * Specifies the number type
                 */
                number= 2,
                /**
                 * Specifies the string type
                 */
                string= 3,
                /**
                 * Specifies the boolean type
                 */
                boolean= 4,
                /**
                 * Specifies the error type
                 */
                error= 5,
                /**
                 * Specifies the array type
                 */
                array= 6,
                /**
                 * Specifies the function type
                 */
                function= 7,
                /**
                 * Specifies the name type
                 */
                name= 8,
                /**
                 * Specifies the operator type
                 */
                operator= 9,
                /**
                 * Specifies the parenthesses type
                 */
                parentheses= 10,
                /**
                 * Specifies the missing argument type
                 */
                missingArgument= 11,
                /**
                 * Specifies the expand type
                 */
                expand= 12,
                /**
                 * Specifies the struct reference type
                 */
                structReference= 13,
                /**
                 * Specifies the spill reference type
                 */
                spillReference= 33,
                /**
                 * Specifies the Let local name type
                 */
                letLocalName= 100
            }


            export class AsyncEvaluateContext{
                /**
                 * Represents an evaluate context for async functions.
                 * @class
                 * @param {Object} context The common evaluate context.
                 */
                constructor(context: any);
                /**
                 * Set the async function evaluate result to CalcEngine, CalcEngine uses this value to recalculate the cell that contains this async function and all dependents cells.
                 * @param {Object} value The async function evaluate result.
                 */
                setAsyncResult(value: any): void;
            }

            export class CalcArray{
                /**
                 * Represents an array in the formula result.
                 * @class
                 * @param {any[][]} array The array content of the formula result.
                 */
                constructor(array: any[][]);
            }

            export class CalcError{
                /**
                 * Represents an error in calculation.
                 * @class
                 * @param {string} error The description of the error.
                 */
                constructor(error: string);
                /**
                 * Parses the specified error from the string.
                 * @param {string} value The error string.
                 * @returns {GCTYPE.Spread.CalcEngine.CalcError} The calculation error.
                 */
                static parse(value:string): GCTYPE.Spread.CalcEngine.CalcError;
                /**
                 * Returns a string that represents this instance.
                 * @returns {string} The error string.
                 */
                toString(): string;
            }

            export class Expression{
                /**
                 * Provides the base class from which the classes that represent expression tree nodes are derived. This is an abstract class.
                 * @class
                 */
                constructor(type: GCTYPE.Spread.CalcEngine.ExpressionType);
                /**
                 * Indicates the expression type
                 * @type {GCTYPE.Spread.CalcEngine.ExpressionType}
                 */
                type: GCTYPE.Spread.CalcEngine.ExpressionType;
            }
            module Functions{
                /**
                 * Defines a global custom function.
                 * @param {string} name The name of the function.
                 * @param {GCTYPE.Spread.CalcEngine.Functions.Function} fn The function to add.
                 */
                function defineGlobalCustomFunction(name: string,  fn: GCTYPE.Spread.CalcEngine.Functions.Function): GCTYPE.Spread.CalcEngine.Functions.Function;
                /**
                 * Gets all of the global functions or one global function that specified by name.
                 * @param {string} name The name of the function.
                 * @returns {GCTYPE.Spread.CalcEngine.Functions.Function} If the name is empty, return all of the global functions, otherwise, return one function with the specified name.
                 */
                function findGlobalFunction(name?: string): any;
                /**
                 * If the name is empty, remove all of the global functions, otherwise, remove one function with the specified name.
                 * @param {string} name The name of the function.
                 */
                function removeGlobalFunction(name?: string): void;

                export interface IFunctionDescription{
                    description: string;
                    parameters: GCTYPE.Spread.CalcEngine.Functions.IParameterDescription[];
                }


                export interface IParameterDescription{
                    name: string;
                    repeatable?: boolean;
                    optional?: boolean;
                }

                /**
                 * Represents the asynchronous function evaluate mode.
                 * @enum {number}
                 */
                export enum AsyncFunctionEvaluateMode{
                    /**
                     * enum value is 0, Specifies that the async function evaluates the changed, referenced cells.
                     */
                    onRecalculation= 0,
                    /**
                     * enum value is 1, Specifies that the async function only evaluates once.
                     */
                    calculateOnce= 1,
                    /**
                     * enum value is 2, Specifies that the async function evaluates based on the interval.
                     */
                    onInterval= 2
                }


                export class AsyncFunction extends GCTYPE.Spread.CalcEngine.Functions.Function{
                    /**
                     * Represents an abstract base class for defining asynchronization functions.
                     * @class
                     * @param {string} name The name of the function.
                     * @param {number} minArgs The minimum number of arguments for the function.
                     * @param {number} maxArgs The maximum number of arguments for the function.
                     * @param {Object} description The description of the function.
                     */
                    constructor(name: string,  minArgs: number,  maxArgs: number,  description: GCTYPE.Spread.CalcEngine.Functions.IFunctionDescription);
                    /**
                     * Returns the default value of the evaluated function result before getting the async result.
                     * @returns {Object} The default value of the evaluated function result before getting the async result.
                     */
                    defaultValue(): any;
                    /**
                     * Returns the result of the function applied to the arguments.
                     * @param {GCTYPE.Spread.CalcEngine.AsyncEvaluateContext} context The evaluate context
                     * @param {Object} args Arguments for the function evaluation
                     * @returns {Object} The result of the function applied to the arguments.
                     */
                    evaluateAsync(context: GCTYPE.Spread.CalcEngine.AsyncEvaluateContext,  args: any): any;
                    /**
                     * Decides how to re-calculate the formula.
                     * @returns {GCTYPE.Spread.CalcEngine.Functions.AsyncFunctionEvaluateMode} The evaluate mode.
                     */
                    evaluateMode(): GCTYPE.Spread.CalcEngine.Functions.AsyncFunctionEvaluateMode;
                    /**
                     * Returns the interval.
                     * @returns {number} The interval in milliseconds.
                     */
                    interval(): number;
                }

                export class Function{
                    /**
                     * Represents an abstract base class for defining functions.
                     * @class
                     * @param {string} name The name of the function.
                     * @param {number} minArgs The minimum number of arguments for the function.
                     * @param {number} maxArgs The maximum number of arguments for the function.
                     * @param {Object} functionDescription The description object of the function.
                     * @param {string} [functionDescription.description] - The description of the function.
                     * @param {Array.<Object>} [functionDescription.parameter] - The parameters' description array of the function.
                     * @param {string} functionDescription.parameter.name -  The parameter name..
                     * @param {boolean} [functionDescription.parameter.repeatable] - Whether the parameter is repeatable.
                     * @param {boolean} [functionDescription.parameter.optional] - Whether the parameter is optional.
                     */
                    constructor(name?: string,  minArgs?: number,  maxArgs?: number,  description?: GCTYPE.Spread.CalcEngine.Functions.IFunctionDescription);
                    /**
                     * Represents the maximum number of arguments for the function.
                     * @type {number}
                     */
                    maxArgs: number;
                    /**
                     * Represents the minimum number of arguments for the function.
                     * @type {number}
                     */
                    minArgs: number;
                    /**
                     * Represents the name of the function.
                     * @type {string}
                     */
                    name: string;
                    /**
                     * Represents the type name string used for supporting serialization.
                     * @type {string}
                     */
                    typeName: string;
                    /**
                     * Determines whether the function accepts array values for the specified argument.
                     * @param {number} argIndex Index of the argument.
                     * @function
                     * @returns {boolean} <c>true</c> if the function accepts array values for the specified argument; otherwise, <c>false</c>.
                     */
                    acceptsArray(argIndex: number): boolean;
                    /**
                     * Indicates whether the function can process Error values.
                     * @param {number} argIndex Index of the argument.
                     * @returns {boolean} <c>true</c> if the function can process Error values for the specified argument; otherwise, <c>false</c>.
                     * @function
                     */
                    acceptsError(argIndex: number): boolean;
                    /**
                     * Indicates whether the Evaluate method can process missing arguments.
                     * @param {number} argIndex Index of the argument
                     * @returns {boolean} <c>true</c> if the Evaluate method can process missing arguments; otherwise, <c>false</c>.
                     */
                    acceptsMissingArgument(argIndex: number): boolean;
                    /**
                     * Determines whether the function accepts Reference values for the specified argument.
                     * @param {number} argIndex Index of the argument.
                     * @returns {boolean} <c>true</c> if the function accepts Reference values for the specified argument; otherwise, <c>false</c>.
                     * @function
                     */
                    acceptsReference(argIndex: number): boolean;
                    /**
                     * Returns the description of the function.
                     * @function
                     * @returns {Object} The description of the function.
                     */
                    description(): GCTYPE.Spread.CalcEngine.Functions.IFunctionDescription;
                    /**
                     * Returns the result of the function applied to the arguments.
                     * @param {Object} args Arguments for the function evaluation
                     * @returns {Object} The result of the function applied to the arguments.
                     */
                    evaluate(args: any): any;
                    /**
                     * Finds the branch argument.
                     * @param {Object} test The test.
                     * @returns {number} Indicates the index of the argument that would be treated as the branch condition.
                     */
                    findBranchArgument(test: any): number;
                    /**
                     * Finds the test argument when this function is branched.
                     * @returns {number} Indicates the index of the argument that would be treated as the test condition.
                     */
                    findTestArgument(): number;
                    /**
                     * Gets a value that indicates whether this function is branched by arguments as conditional.
                     * @returns {boolean} <c>true</c> if this instance is branched; otherwise, <c>false</c>.
                     */
                    isBranch(): boolean;
                    /**
                     * Determines whether the evaluation of the function is dependent on the context in which the evaluation occurs.
                     * @returns {boolean} <c>true</c> if the evaluation of the function is dependent on the context; otherwise, <c>false</c>.
                     */
                    isContextSensitive(): boolean;
                    /**
                     * Determines whether the function is volatile while it is being evaluated.
                     * @returns {boolean} <c>true</c> if the function is volatile; otherwise, <c>false</c>.
                     */
                    isVolatile(): boolean;
                }
            }

            module LanguagePackages{
                /**
                 * Gets or Sets the language package for clacengine.
                 * @param {string} languageName the clacengine language name string;
                 * @returns {string|void} If no value is set, return the clacengine language name string;
                 * @example
                 * GCTYPE.Spread.CalcEngine.LanguagePackages.languagePackages('fr');
                 * GCTYPE.Spread.CalcEngine.LanguagePackages.languagePackages();
                 */
                function languagePackages(languageName?: string): any;
            }

        }

        module Commands{
            /**
             * Represents the key code.
             * @enum {number}
             * @example
             * //This example creates a custom action using the enter key.
             * var activeSheet = spread.getActiveSheet();
             * spread.commandManager().register('myCmd',
             *                 function ColorAction() {
             *                     //Click on a cell and press the Enter key.
             *                     activeSheet.getCell(activeSheet.getActiveRowIndex(), activeSheet.getActiveColumnIndex()).backColor("red");
             *                 }
             *             );
             * //Map the created action to the Enter key.
             * spread.commandManager().setShortcutKey('myCmd', GCTYPE.Spread.Commands.Key.enter, false, false, false, false);
             */
            export enum Key{
                /**
                 * Indicates the left arrow key.
                 */
                left= 37,
                /**
                 * Indicates the right arrow key.
                 */
                right= 39,
                /**
                 * Indicates the up arrow key.
                 */
                up= 38,
                /**
                 * Indicates the down arrow key.
                 */
                down= 40,
                /**
                 * Indicates the Tab key.
                 */
                tab= 9,
                /**
                 * Indicates the Enter key.
                 */
                enter= 13,
                /**
                 * Indicates the Shift key.
                 */
                shift= 16,
                /**
                 * Indicates the Ctrl key.
                 */
                ctrl= 17,
                /**
                 * Indicates the space key.
                 */
                space= 32,
                /**
                 * Indicates the Alt key.
                 */
                altkey= 18,
                /**
                 * Indicates the Home key.
                 */
                home= 36,
                /**
                 * Indicates the End key.
                 */
                end= 35,
                /**
                 * Indicates the Page Up key.
                 */
                pup= 33,
                /**
                 * Indicates the Page Down key.
                 */
                pdn= 34,
                /**
                 * Indicates the Backspace key.
                 */
                backspace= 8,
                /**
                 * Indicates the Delete key.
                 */
                del= 46,
                /**
                 * Indicates the Esc key.
                 */
                esc= 27,
                /**
                 * Indicates the A key
                 */
                a= 65,
                /**
                 * Indicates the C key.
                 */
                c= 67,
                /**
                 * Indicates the V key.
                 */
                v= 86,
                /**
                 * Indicates the X key.
                 */
                x= 88,
                /**
                 * Indicates the Z key.
                 */
                z= 90,
                /**
                 * Indicates the Y key.
                 */
                y= 89
            }


            export class CommandManager{
                /**
                 * Represents a command manager.
                 * @class
                 * @param {Object} context The execution context for all commands in the command manager.
                 * @constructor
                 */
                constructor(context: Object);
                /**
                 * Executes a command and adds the command to UndoManager.
                 * @param {Object} commandOptions The options for the command.
                 * @param {string} commandOptions.cmd The command name, the field is required.
                 * @param {Object} [commandOptions.arg1] The command argument, the name and type are decided by the command definition.
                 * @param {Object} [commandOptions.arg2] The command argument, the name and type are decided by the command definition.
                 * @param {Object} [commandOptions.argN] The command argument, the name and type are decided by the command definition.
                 * @returns {boolean} The execute command result.
                 * @example
                 * //For example, the following code executes the autoFitColumn command.
                 * var spread = GCTYPE.Spread.Sheets.findControl(document.getElementById("ss"));
                 * spread.commandManager().execute({cmd: "autoFitColumn", sheetName: "Sheet1", columns: [{col: 1}], rowHeader: false, autoFitType: GCTYPE.Spread.Sheets.AutoFitType.cell});
                 */
                execute(commandOptions: Object): boolean;
                /**
                 * Registers a command with the command manager.
                 * @param {string} name - The name of the command.
                 * @param {Object} command - The object that defines the command.
                 * @param {number|GCTYPE.Spread.Commands.Key} key - The key code.
                 * @param {boolean} ctrl - <c>true</c> if the command uses the Ctrl key; otherwise, <c>false</c>.
                 * @param {boolean} shift - <c>true</c> if the command uses the Shift key; otherwise, <c>false</c>.
                 * @param {boolean} alt - <c>true</c> if the command uses the Alt key; otherwise, <c>false</c>.
                 * @param {boolean} meta - <c>true</c> if the command uses the Command key on the Macintosh or the Windows key on Microsoft Windows; otherwise, <c>false</c>.
                 * @example
                 * //For example, the following code registers the changeBackColor command and then executes the command.
                 * var command = {
                 *   canUndo: true,
                 *   execute: function (context, options, isUndo) {
                 *     var Commands = GCTYPE.Spread.Sheets.Commands;
                 *     options.cmd = "changeBackColor";
                 *     if (isUndo) {
                 *       Commands.undoTransaction(context, options);
                 *       return true;
                 *     } else {
                 *       Commands.startTransaction(context, options);
                 *       var sheet = context.getSheetFromName(options.sheetName);
                 *       var cell = sheet.getCell(options.row, options.col);
                 *       cell.backColor(options.backColor);
                 *       Commands.endTransaction(context, options);
                 *       return true;
                 *     }
                 *   }
                 * };
                 * var spread = GCTYPE.Spread.Sheets.findControl(document.getElementById("ss"));
                 * var commandManager = spread.commandManager();
                 * commandManager.register("changeBackColor", command);
                 * commandManager.execute({cmd: "changeBackColor", sheetName: spread.getSheet(0).name(), row: 1, col: 2, backColor: "red"});
                 */
                register(name: string,  command: Object,  key?: number|GCTYPE.Spread.Commands.Key,  ctrl?: boolean,  shift?: boolean,  alt?: boolean,  meta?: boolean): void;
                /**
                 * Binds a shortcut key to a command.
                 * @param {string} commandName The command name, setting commandName to undefined removes the bound command of the shortcut key.
                 * @param {number|GCTYPE.Spread.Commands.Key} key The key code, setting the key code to undefined removes the shortcut key of the command.
                 * @param {boolean} ctrl <c>true</c> if the command uses the Ctrl key; otherwise, <c>false</c>.
                 * @param {boolean} shift <c>true</c> if the command uses the Shift key; otherwise, <c>false</c>.
                 * @param {boolean} alt <c>true</c> if the command uses the Alt key; otherwise, <c>false</c>.
                 * @param {boolean} meta <c>true</c> if the command uses the Command key on the Macintosh or the Windows key on Microsoft Windows; otherwise, <c>false</c>.
                 * @example
                 * //This example changes the behavior of default keys.
                 * var activeSheet = spread.getActiveSheet();
                 * //Change the default Up arrow key action to "Page Up" for the active cell.
                 * spread.commandManager().setShortcutKey('navigationPageUp', GCTYPE.Spread.Commands.Key.up, false, false, false, false);
                 * //Change the default Down arrow key action to "Page Down" for the active cell.
                 * spread.commandManager().setShortcutKey('navigationPageDown', GCTYPE.Spread.Commands.Key.down, false, false, false, false);
                 */
                setShortcutKey(commandName: string,  key?: number|GCTYPE.Spread.Commands.Key,  ctrl?: boolean,  shift?: boolean,  alt?: boolean,  meta?: boolean): void;
            }

            export class UndoManager{
                /**
                 * Represents the undo manager.
                 * @constructor
                 */
                constructor();
                /**
                 * Gets whether the redo operation is allowed.
                 * @returns {boolean} <c>true</c> if the redo operation is allowed; otherwise, <c>false</c>.
                 */
                canRedo(): boolean;
                /**
                 * Gets whether the undo operation is allowed.
                 * @returns {boolean} <c>true</c> if the undo operation is allowed; otherwise, <c>false</c>.
                 */
                canUndo(): boolean;
                /**
                 * Clears all of the undo stack and the redo stack.
                 */
                clear(): void;
                /**
                 * Get the redo stack.
                 * @returns {any[]} It returns an object. This  must include sheetName and cmd. the type of sheetName and cmd both is string.
                 */
                getRedoStack():any[];
                /**
                 * Get the undo stack.
                 * @returns {any[]} It returns is an object. This object must include sheetName and cmd. the type of sheetName and cmd both is string.
                 */
                getUndoStack():any[];
                /**
                 * Gets or sets the the undo/redo stack max size.
                 * @param {number} value this value should be greater or equal to 0.
                 * @returns {number | UndoManager} If no value is set. return the max size of undo/redo stack. otherwise return UndoManager.
                 */
                maxSize(value?: number):any;
                /**
                 * Redoes the last command.
                 * @returns {boolean} <c>true</c> if the redo operation is successful; otherwise, <c>false</c>.
                 */
                redo(): boolean;
                /**
                 * Undoes the last command.
                 * @returns {boolean} <c>true</c> if the undo operation is successful; otherwise, <c>false</c>.
                 */
                undo(): boolean;
            }
        }

        module Common{

            export interface IDateTimeFormat{
                abbreviatedDayNames?: string[];
                abbreviatedMonthGenitiveNames?: string[];
                abbreviatedMonthNames?: string[];
                amDesignator?: string;
                dayNames?: string[];
                fullDateTimePattern?: string;
                longDatePattern?: string;
                longTimePattern?: string;
                monthDayPattern?: string;
                monthGenitiveNames?: string[];
                monthNames?: string[];
                pmDesignator?: string;
                shortDatePattern?: string;
                shortTimePattern?: string;
                yearMonthPattern?: string;
            }


            export interface ILocalNumberFormat{
                [K: number]: string;
            }


            export interface INumberFormat{
                currencyDecimalSeparator?: string;
                currencyGroupSeparator?: string;
                currencySymbol?: string;
                numberDecimalSeparator?: string;
                numberGroupSeparator?: string;
                listSeparator?: string;
                arrayListSeparator?: string;
                arrayGroupSeparator?: string;
                dbNumber?: Object
            }


            export class CultureInfo{
                /**
                 * Represents the custom culture class. The member variable can be overwritten.
                 * @class
                 */
                constructor();
                /**
                 * Indicates the date time format fields.
                 * @type {Object}
                 * @property {Array.<string>} abbreviatedDayNames - Specifies the day formatter for "ddd".
                 * @property {Array.<string>} abbreviatedMonthGenitiveNames - Specifies the month formatter for "MMM".
                 * @property {Array.<string>} abbreviatedMonthNames - Specifies the month formatter for "MMM".
                 * @property {string} amDesignator - Indicates the AM designator.
                 * @property {Array.<string>} dayNames - Specifies the day formatter for "dddd".
                 * @property {string} fullDateTimePattern - Specifies the standard date formatter for "F".
                 * @property {string} longDatePattern - Specifies the standard date formatter for "D".
                 * @property {string} longTimePattern - Specifies the standard date formatter for "T" and "U".
                 * @property {string} monthDayPattern - Specifies the standard date formatter for "M" and "m".
                 * @property {Array.<string>} monthGenitiveNames - Specifies the formatter for "MMMM".
                 * @property {Array.<string>} monthNames - Specifies the formatter for "M" or "MM".
                 * @property {string} pmDesignator - Indicates the PM designator.
                 * @property {string} shortDatePattern - Specifies the standard date formatter for "d".
                 * @property {string} shortTimePattern - Specifies the standard date formatter for "t".
                 * @property {string} yearMonthPattern - Specifies the standard date formatter for "y" and "Y".
                 * @example
                 * // This example creates a custom culture.
                 * var myCulture = new GCTYPE.Spread.Common.CultureInfo();
                 * myCulture.NumberFormat.currencySymbol = "\u20ac"
                 * myCulture.NumberFormat.numberDecimalSeparator = ",";
                 * myCulture.NumberFormat.numberGroupSeparator = ".";
                 * myCulture.NumberFormat.arrayGroupSeparator = ";";
                 * myCulture.NumberFormat.arrayListSeparator = "\\";
                 * myCulture.NumberFormat.listSeparator = ";";
                 * myCulture.DateTimeFormat.amDesignator = "";
                 * myCulture.DateTimeFormat.pmDesignator = "";
                 * myCulture.DateTimeFormat.abbreviatedMonthNames = ["Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez", ""];
                 * myCulture.DateTimeFormat.abbreviatedDayNames = ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"];
                 * myCulture.DateTimeFormat.abbreviatedMonthGenitiveNames = ["Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez", ""];
                 * myCulture.DateTimeFormat.dayNames = ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"];
                 * myCulture.DateTimeFormat.fullDateTimePattern = "dddd, d. MMMM yyyy HH:mm:ss";
                 * myCulture.DateTimeFormat.longDatePattern = "dddd, d. MMMM yyyy";
                 * myCulture.DateTimeFormat.longTimePattern = "HH:mm:ss";
                 * myCulture.DateTimeFormat.monthDayPattern = "dd MMMM";
                 * myCulture.DateTimeFormat.monthNames = ["Januar", "Februar", "M\xe4rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember", ""];
                 * myCulture.DateTimeFormat.monthGenitiveNames = ["Januar", "Februar", "M\xe4rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember", ""];
                 * myCulture.DateTimeFormat.shortDatePattern = "dd.MM.yyyy";
                 * myCulture.DateTimeFormat.shortTimePattern = "HH:mm";
                 * myCulture.DateTimeFormat.yearMonthPattern = "MMMM yyyy";
                 * //add one culture
                 * GCTYPE.Spread.Common.CultureManager.addCultureInfo("de-DE", myCulture);
                 * //switch to "de-DE" culture
                 * GCTYPE.Spread.Common.CultureManager.culture("de-DE");
                 * var d = new Date();
                 * //With culture
                 * activeSheet.setValue(1, 0, new Date(d.setDate(d.getDate() + 1)));
                 * activeSheet.getCell(1, 0).formatter("mmm");
                 * var dvalue = 12345.6789;
                 * activeSheet.setColumnWidth(0, 200);
                 * activeSheet.setColumnWidth(1, 200);
                 * activeSheet.setColumnWidth(2, 200);
                 * activeSheet.setValue(0, 0, dvalue);
                 * activeSheet.getCell(0, 0).formatter("###,###.00");
                 * activeSheet.setValue(2, 0, new Date(d.setDate(d.getDate() + 1)));
                 * //With culture
                 * activeSheet.getCell(3, 0).formatter("yyyy/mmm/dddd");
                 * activeSheet.setValue(3, 0, new Date());
                 */
                DateTimeFormat: GCTYPE.Spread.Common.IDateTimeFormat;
                /**
                 * indicates the local number format built.It's a map whose keys are number and values are formatString.
                 * @type {Object}
                 * @property {string} key - this property key is number, this property value is format string.
                 * //this is an example.
                 * var cultureInfo = new GCTYPE.Spread.Common.CultureInfo().
                 * cultureInfo.LocalNumberFormat = {
                 *  14:"yyyy-mm-dd",
                 *  15:"yyyy/mm/dd"
                 * }
                 */
                LocalNumberFormat: GCTYPE.Spread.Common.ILocalNumberFormat;
                /**
                 * Indicates all the number format fields.
                 * @type {Object}
                 * @property {string} currencyDecimalSeparator - Indicates the currency decimal point.
                 * @property {string} currencyGroupSeparator - Indicates the currency thousand separator.
                 * @property {string} currencySymbol - Indicates the currency symbol.
                 * @property {string} numberDecimalSeparator - Indicates the decimal point.
                 * @property {string} numberGroupSeparator - Indicates the thousand separator.
                 * @property {string} listSeparator - Indicates the separator for function arguments in a formula.
                 * @property {string} arrayListSeparator - Indicates the separator for the constants in one row of an array constant in a formula.
                 * @property {string} arrayGroupSeparator - Indicates the separator for the array rows of an array constant in a formula.
                 * @property {object} dbNumber - Specifies the DBNumber characters.
                 * The dbNumber object structure as follow:
                 *  {
                 *     1: {letters: ['\u5146', '\u5343', '\u767e', '\u5341', '\u4ebf', '\u5343', '\u767e', '\u5341', '\u4e07', '\u5343', '\u767e', '\u5341', ''], // \u5146\u5343\u767e\u5341\u4ebf\u5343\u767e\u5341\u4e07\u5343\u767e\u5341
                 *         numbers: ['\u25cb', '\u4e00', '\u4e8c', '\u4e09', '\u56db', '\u4e94', '\u516d', '\u4e03', '\u516b', '\u4e5d'] }, // \u25cb\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d
                 *     2: {letters: ['\u5146', '\u4edf', '\u4f70', '\u62fe', '\u4ebf', '\u4edf', '\u4f70', '\u62fe', '\u4e07', '\u4edf', '\u4f70', '\u62fe', ''], // \u5146\u4edf\u4f70\u62fe\u4ebf\u4edf\u4f70\u62fe\u4e07\u4edf\u4f70\u62fe
                 *         numbers: ['\u96f6', '\u58f9', '\u8d30', '\u53c1', '\u8086', '\u4f0d', '\u9646', '\u67d2', '\u634c', '\u7396']}, // \u96f6\u58f9\u8d30\u53c1\u8086\u4f0d\u9646\u67d2\u634c\u7396
                 *     3: {letters: null,
                 *         numbers: ['\uff10', '\uff11', '\uff12', '\uff13', '\uff14', '\uff15', '\uff16', '\uff17', '\uff18', '\uff19']} // \uff10\uff11\uff12\uff13\uff14\uff15\uff16\uff17\uff18\uff19
                 * };
                 * @example
                 * // This example creates a custom culture.
                 * var myCulture = new GCTYPE.Spread.Common.CultureInfo();
                 * myCulture.NumberFormat.currencySymbol = "\u20ac"
                 * myCulture.NumberFormat.numberDecimalSeparator = ",";
                 * myCulture.NumberFormat.numberGroupSeparator = ".";
                 * myCulture.NumberFormat.arrayGroupSeparator = ";";
                 * myCulture.NumberFormat.arrayListSeparator = "\\";
                 * myCulture.NumberFormat.listSeparator = ";";
                 * myCulture.DateTimeFormat.amDesignator = "";
                 * myCulture.DateTimeFormat.pmDesignator = "";
                 * myCulture.DateTimeFormat.abbreviatedMonthNames = ["Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez", ""];
                 * myCulture.DateTimeFormat.abbreviatedDayNames = ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"];
                 * myCulture.DateTimeFormat.abbreviatedMonthGenitiveNames = ["Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez", ""];
                 * myCulture.DateTimeFormat.dayNames = ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"];
                 * myCulture.DateTimeFormat.fullDateTimePattern = "dddd, d. MMMM yyyy HH:mm:ss";
                 * myCulture.DateTimeFormat.longDatePattern = "dddd, d. MMMM yyyy";
                 * myCulture.DateTimeFormat.longTimePattern = "HH:mm:ss";
                 * myCulture.DateTimeFormat.monthDayPattern = "dd MMMM";
                 * myCulture.DateTimeFormat.monthNames = ["Januar", "Februar", "M\xe4rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember", ""];
                 * myCulture.DateTimeFormat.monthGenitiveNames = ["Januar", "Februar", "M\xe4rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember", ""];
                 * myCulture.DateTimeFormat.shortDatePattern = "dd.MM.yyyy";
                 * myCulture.DateTimeFormat.shortTimePattern = "HH:mm";
                 * myCulture.DateTimeFormat.yearMonthPattern = "MMMM yyyy";
                 * //add one culture
                 * GCTYPE.Spread.Common.CultureManager.addCultureInfo("de-DE", myCulture);
                 * //switch to "de-DE" culture
                 * GCTYPE.Spread.Common.CultureManager.culture("de-DE");
                 * var d = new Date();
                 * //With culture
                 * activeSheet.setValue(1, 0, new Date(d.setDate(d.getDate() + 1)));
                 * activeSheet.getCell(1, 0).formatter("mmm");
                 * var dvalue = 12345.6789;
                 * activeSheet.setColumnWidth(0, 200);
                 * activeSheet.setColumnWidth(1, 200);
                 * activeSheet.setColumnWidth(2, 200);
                 * activeSheet.setValue(0, 0, dvalue);
                 * activeSheet.getCell(0, 0).formatter("###,###.00");
                 * activeSheet.setValue(2, 0, new Date(d.setDate(d.getDate() + 1)));
                 * //With culture
                 * activeSheet.getCell(3, 0).formatter("yyyy/mmm/dddd");
                 * activeSheet.setValue(3, 0, new Date());
                 */
                NumberFormat: GCTYPE.Spread.Common.INumberFormat;
            }

            export class CultureManager{
                /**
                 * Represent a culture manager.
                 * @constructor
                 */
                constructor();
                /**
                 * Adds the cultureInfo or custom language into the culture manager.
                 * @static
                 * @param {string} cultureName The culture name to set.
                 * @param {GCTYPE.Spread.Common.CultureInfo} cultureInfo The cultureInfo set to the culture.
                 * @param {object} language The custom language set to the culture. If already set, it will overwrite the old language.
                 */
                static addCultureInfo(cultureName: string,  culture: GCTYPE.Spread.Common.CultureInfo,  language?: object): void;
                /**
                 * Get or set the Sheets culture.
                 * @static
                 * @param {string} cultureName The culture name to get.
                 * @returns {string}. The current culture name of Sheets.
                 */
                static culture(cultureName?: string): string;
                /**
                 * Gets the specified cultureInfo. If no culture name, get current cultureInfo.
                 * @static
                 * @param {string | number} cultureName Culture name or culture ID
                 * @returns {GCTYPE.Spread.Common.CultureInfo} The specified cultureInfo object.
                 */
                static getCultureInfo(cultureName: string | number): GCTYPE.Spread.Common.CultureInfo;
                /**
                 * Gets the specified custom language.
                 * @static
                 * @param {string} cultureName The culture name to get.
                 * @returns {object} The specified object. Null if not define the language.
                 */
                static getLanguage(cultureName: string): object;
                /**
                 * Gets the specified or current working resources.
                 * @static
                 * @param {string | null} cultureName The culture name to get. If the cultureName is null, will return the current working resources.
                 * @returns {object} The specified or current working resources. Null if not define the language.
                 */
                static getResources(cultureName?: string): object;
            }
        }

        module Formatter{

            export class FormatterBase{
                /**
                 * Represents a custom formatter with the specified format string.
                 * @class
                 * @param {string} format The format.
                 * @param {string} cultureName The culture name.
                 */
                constructor(format: string,  cultureName: string);
                /** Represents the type name string used for supporting serialization.
                 * @type {string}
                 */
                typeName: string;
                /**
                 * Formats the specified object as a string with a conditional color. This function should be overwritten.
                 * @param {Object} obj - The object with cell data to format.
                 * @param {Object} [options] - The additonal format data.
                 * @param {string} [options.conditionalForeColor] - The conditonal foreColor when format pattern contains color patter, such as [red]###.##
                 * @returns {string} The formatted string.
                 * @example
                 * //This example creates a custom formatter.
                 * var customFormatterTest = {};
                 * customFormatterTest.prototype = GCTYPE.Spread.Formatter.FormatterBase;
                 * customFormatterTest.format = function (obj, data) {
                 *     data.conditionalForeColor = "blue";
                 *     return "My format result : " + obj.toString();
                 * };
                 * customFormatterTest.parse = function (str) {
                 *     if (!str) {
                 *         return "";
                 *     }
                 *     return str;
                 * }
                 * activeSheet.getCell(1, 0).formatter(customFormatterTest);
                 * activeSheet.getCell(1, 0).value("Test");
                 */
                format(obj: Object): string;
                /**
                 * Loads the object state from the specified JSON string.
                 * @param {Object} settings The custom formatter data from deserialization.
                 */
                fromJSON(settings: Object): void;
                /**
                 * Parses the specified text. This function should be overwritten.
                 * @param {string} text The text.
                 * @returns {Object} The parsed object.
                 * @example
                 * //This example creates a custom formatter.
                 * var customFormatterTest = {};
                 * customFormatterTest.prototype = GCTYPE.Spread.Formatter.FormatterBase;
                 * customFormatterTest.format = function (obj, conditionalForeColor) {
                 *     conditionalForeColor.value = "blue";
                 *     return "My format result : " + obj.toString();
                 * };
                 * customFormatterTest.parse = function (str) {
                 *     if (!str) {
                 *         return "";
                 *     }
                 *     return str;
                 * }
                 * activeSheet.getCell(1, 0).formatter(customFormatterTest);
                 * activeSheet.getCell(1, 0).value("Test")
                 */
                parse(str: string): Object;
                /**
                 * Saves the object state to a JSON string.
                 * @returns {Object} The custom formatter data.
                 */
                toJSON(): Object;
            }

            export class GeneralFormatter{
                /**
                 * Represents a formatter with the specified format mode and format string.
                 * @class
                 * @param {string} format The format.
                 * @param {string} cultureName The culture name.
                 */
                constructor(format: string,  cultureName: string);
                /**
                 * Formats the specified object as a string with a formatted data Object.
                 * @param {Object} obj The object with cell data to format.
                 * @param {Object} formattedData The object with formatted data.
                 * @param {Array} [formattedData.content] - The formatted data array, each item is an object that has two properties type and value, And it may contain these types: 'number', 'text', 'fillingChar', 'placeholder', 'exponent', 'decimalSeparator', 'groupSeparator', 'numberPlaceholder', 'percent', 'permille' and 'currency'. For example: {type: 'number', value: '123'}.
                 * @param {string} [formattedData.conditionalForeColor] - The conditional foreground color.
                 * @returns {string} The formatted string.
                 */
                format(obj: Object,  formattedData: Object): string;
                /**
                 * Gets or sets the format string for this formatter.
                 * @param {string} value The format string for this formatter.
                 * @returns {string|GCTYPE.Spread.Formatter.GeneralFormatter} If no value is set, returns the formatter string for this formatter; otherwise, returns the formatter.
                 */
                formatString(value?: string): string | GCTYPE.Spread.Formatter.GeneralFormatter;
                /**
                 * Parses the specified text.
                 * @param {string} text The text.
                 * @returns {Object} The parsed object.
                 */
                parse(str: string): Object;
            }
        }

        module Pivot{

            export interface IPivotItemInfo{
                fieldName: string;
                fieldItem: string;
            }


            export interface IPivotTableViewManager{
                add: (view: IPivotTableView) => boolean;
                save: (name: string) => boolean;
                remove: (name: string) => void;
                get: (name: string) => GCTYPE.Spread.Pivot.IPivotTableView;
                all: () => IPivotTableView[];
                apply: (name: string) => void;
            }


            /**
             * @typedef {object} GCTYPE.Spread.Pivot.ICalcFieldInfo
             * @property {string} fieldName  the field name of calc field
             * @property {string} formula  the formula of calc field
             */
            export type ICalcFieldInfo =
                {
                    fieldName: string;
                    formula: string;
                }


            /**
             * @typedef GCTYPE.Spread.Pivot.IDateGroupInfo
             * @property {GCTYPE.Pivot.DateGroupType} by The date unit of date group info.
             * @property {Date} [start]  The start date of group.
             * @property {Date} [end] The end date of group.
             */
            export type IDateGroupInfo =
                {
                    start?: Date;
                    end?: Date;
                    by: GCTYPE.Pivot.DateGroupType;
                }


            /**
             * @typedef GCTYPE.Spread.Pivot.IDateGroupsInfo
             * @property {string} originFieldName The source field name.
             * @property {GCTYPE.Spread.Pivot.IDateGroupInfo[]} dateGroups The date group info.
             */
            export type IDateGroupsInfo =
                {
                    originFieldName: string;
                    dateGroups: GCTYPE.Spread.Pivot.IDateGroupInfo[];
                }


            /**
             * @typedef {object} GCTYPE.Spread.Pivot.IFieldInfo - the field info of a pivot table field
             * @property {string} fieldName the field name
             * @property {string} sourceName the source name
             * @property {GCTYPE.Pivot.PivotDataType} dataType  the field correspondence source data type
             * @property {GCTYPE.Spread.Pivot.PivotTableFieldType} pivotArea the field type, which effect the field in different area
             * @property {number} pivotIndex the index in the field area
             * @property {Date|number} [start] the min value of number type data field or the oldest of date type field
             * @property {Date|number} [end]  the max value of number type data field or the newest of date type field
             */
            export type IFieldInfo =
                {
                    fieldName: string;
                    sourceName: string;
                    dataType: GCTYPE.Pivot.PivotDataType;
                    pivotArea: GCTYPE.Spread.Pivot.PivotTableFieldType;
                    pivotIndex: number;
                    start?: Date|number;
                    end?: Date|number;
                }


            /**
             * @typedef GCTYPE.Spread.Pivot.INumberGroupInfo
             * @property {string} originFieldName The source field name.
             * @property {object}  numberGroup The number group info
             * @property {number}  [numberGroup.start]  The start number of number group info.
             * @property {number}  [numberGroup.end]  The end number of number group info.
             * @property {number}  numberGroup.by   The step of number group info.
             */
            export type INumberGroupInfo =
                {
                    originFieldName: string;
                    numberGroup: {
                        start?: number;
                        end?: number;
                        by: number;
                    };
                }


            /**
             * @typedef {object} GCTYPE.Spread.Pivot.IPivotArea
             * @property {GCTYPE.Spread.Pivot.PivotAreaType} [type]
             * @property {string} [fieldName]
             * @property {boolean} [labelOnly]
             * @property {boolean} [dataOnly]
             * @property {boolean} [grandRow]
             * @property {boolean} [grandCol]
             * @property {GCTYPE.Spread.Pivot.IPivotReference[]} [references]
             */
            export type IPivotArea =
                {
                    type?: GCTYPE.Spread.Pivot.PivotAreaType;
                    fieldName?: string;
                    labelOnly?: boolean;
                    dataOnly?: boolean;
                    grandRow?: boolean;
                    grandCol?: boolean;
                    references?: GCTYPE.Spread.Pivot.IPivotReference[];
                }


            /**
             * @typedef {object} GCTYPE.Spread.Pivot.IPivotAreasCollection
             * @property {Object.<string, GCTYPE.Spread.Pivot.IPivotArea[]>} - key indicates pivot table name, value indicates selected pivot areas.
             */
            export type IPivotAreasCollection =
                {
                    [pivotTableName: string]: IPivotArea[];
                }


            /**
             * @typedef {object} GCTYPE.Spread.Pivot.IPivotConditionFilterInfo
             * @property {string} conditionByName
             * @property {GCTYPE.Pivot.IPivotCaptionConditionFilterInfo | GCTYPE.Pivot.IPivotDateConditionFilterInfo | GCTYPE.Pivot.IPivotTop10ConditionFilterInfo | GCTYPE.Pivot.IPivotValueConditionInfo} condition
             */
            export type IPivotConditionFilterInfo =
                {
                    conditionByName: string;
                    condition: GCTYPE.Pivot.IPivotCaptionConditionFilterInfo | GCTYPE.Pivot.IPivotDateConditionFilterInfo | GCTYPE.Pivot.IPivotTop10ConditionFilterInfo | GCTYPE.Pivot.IPivotValueConditionInfo
                }


            /**
             * @typedef {object} GCTYPE.Spread.Pivot.IPivotReference
             * @property {string} fieldName
             * @property {boolean} [subtotal]
             * @property {string[]} [items]
             */
            export type IPivotReference =
                {
                    fieldName: string;
                    subtotal?: boolean;
                    items?: string[];
                }


            /**
             * @typedef {object} GCTYPE.Spread.Pivot.IPivotShowDataAsInfo
             * @property {string} baseFieldName
             * @property {GCTYPE.Pivot.PivotShowDataAsBaseItemType} baseFieldItemType
             * @property {string} baseFieldItem
             */
            export type IPivotShowDataAsInfo =
                {
                    showDataAs: GCTYPE.Pivot.PivotShowDataAs;
                    baseFieldName?:string;
                    baseFieldItemType?:GCTYPE.Pivot.PivotShowDataAsBaseItemType;
                    baseFieldItem?:string;
                }


            /**
             * @typedef {object} GCTYPE.Spread.Pivot.IPivotStyle
             * @property {GCTYPE.Spread.Pivot.IPivotArea} pivotArea The pivotArea in pivot table.
             * @property {GCTYPE.Spread.Sheets.Style}  style The style use for pivotArea.
             */
            export type IPivotStyle =
                {
                    pivotArea?: GCTYPE.Spread.Pivot.IPivotArea;
                    style?: GCTYPE.Spread.Sheets.Style;
                }


            /**
             * @property {boolean} [allowMultipleFiltersPerField]
             * @property {boolean} [fillDownLabels]
             * @property {boolean} [insertBlankLineAfterEachItem]
             * @property {GCTYPE.Spread.Pivot.GrandTotalPosition} grandTotalPosition
             * @property {GCTYPE.Spread.Pivot.SubtotalsPosition} subtotalsPosition
             * @property {GCTYPE.Spread.Pivot.SubtotalsPosition} subTotalsPosition
             * @property {GCTYPE.Spread.Pivot.DisplayFields} displayFieldsInPageFilterArea
             * @property {number} reportFilterFieldsPerColumn
             * @property {boolean} [bandRows]
             * @property {boolean} [bandColumns]
             * @property {boolean} [showRowHeader]
             * @property {boolean} [showColumnHeader]
             * @property {boolean} [showDrill]
             * @property {boolean} [showMissing]
             * @property {string | number} missingCaption
             * @property {number} rowLabelIndent
             * @property {boolean} [printDrill]
             * @property {boolean} [itemPrintTitles]
             * @property {boolean} [fieldPrintTitles]
             * @property {boolean} [showFilter]
             * @property {boolean} [showToolTip]
             * @property {boolean} [mergeItem]
             * @property {boolean} [isShowErrorValue]
             * @property {string} [errorValueInfo]
             * @property {string} [rowHeaderCaption]
             * @property {string} [colHeaderCaption]
             */
            export type IPivotTableOption =
                {
                    allowMultipleFiltersPerField?: boolean;
                    fillDownLabels?: boolean;
                    insertBlankLineAfterEachItem?: boolean;
                    grandTotalPosition?: GCTYPE.Spread.Pivot.GrandTotalPosition;
                    subtotalsPosition?: GCTYPE.Spread.Pivot.SubtotalsPosition;
                    subTotalsPosition?: GCTYPE.Spread.Pivot.SubtotalsPosition;
                    displayFieldsInPageFilterArea?: GCTYPE.Spread.Pivot.DisplayFields;
                    reportFilterFieldsPerColumn?: number;
                    bandRows?: boolean;
                    bandColumns?: boolean;
                    showRowHeader?: boolean;
                    showColumnHeader?: boolean;
                    showDrill?: boolean;
                    showMissing?: boolean;
                    missingCaption?: string | number;
                    rowLabelIndent?: number;
                    printDrill?: boolean;
                    itemPrintTitles?: boolean;
                    fieldPrintTitles?: boolean;
                    showFilter?: boolean;
                    showToolTip?: boolean;
                    mergeItem?: boolean;
                    isShowErrorValue?: boolean;
                    errorValueInfo?: string;
                    rowHeaderCaption?: string;
                    colHeaderCaption?: string;
                }


            /**
             * @typedef {object} GCTYPE.Spread.Pivot.IPivotTablePosition
             * @property {number} row indicates pivot table start row
             * @property {number} col indicates pivot table start col
             * @property {number} [sheetName] which sheet is pivot table on
             */
            export type IPivotTablePosition =
                {
                    row: number;
                    col: number;
                    sheetName?: string;
                }


            /**
             * @typedef GCTYPE.Spread.Pivot.IPivotTableRange
             * @property {GCTYPE.Spread.Sheets.Range} page the filter area range
             * @property {GCTYPE.Spread.Sheets.Range} content the content area range
             */
            export type IPivotTableRange =
                {
                    page: GCTYPE.Spread.Sheets.Range;
                    content: GCTYPE.Spread.Sheets.Range;
                }


            /**
             * @typedef {object} GCTYPE.Spread.Pivot.IPivotTableView
             * @property {string} name
             * @property {GCTYPE.Spread.Pivot.ISerializeInfo} config
             */
            export type IPivotTableView =
                {
                    name: string;
                    config: GCTYPE.Spread.Pivot.ISerializeInfo;
                }


            /**
             * @typedef {object} GCTYPE.Spread.Pivot.IPivotTextFilterInfo
             * @property {GCTYPE.Spread.Pivot.ITextCollectionCondition} textItem
             */
            export type IPivotTextFilterInfo =
                {
                    textItem: GCTYPE.Spread.Pivot.ITextCollectionCondition;
                }


            /**
             * @typedef {object} GCTYPE.Spread.Pivot.ISerializeFieldInfo
             * @property {string} conditionBySourceName
             * @property {string} displayName
             * @property {GCTYPE.Pivot.SubtotalType} [subtotal]
             * @property {GCTYPE.Spread.Pivot.IPivotTextFilterInfo | GCTYPE.Spread.Pivot.IPivotConditionFilterInfo} [labelFilter]
             * @property {GCTYPE.Spread.Pivot.IPivotConditionFilterInfo} [valueFilter]
             * @property {GCTYPE.Pivot.IPivotViewSortInfo} [sortInfo]
             */
            export type ISerializeFieldInfo =
                {
                    sourceName: string;
                    displayName: string;
                    subtotal?:  GCTYPE.Pivot.SubtotalType;
                    labelFilter?:  GCTYPE.Spread.Pivot.IPivotTextFilterInfo | GCTYPE.Spread.Pivot.IPivotConditionFilterInfo;
                    valueFilter?:  GCTYPE.Spread.Pivot.IPivotConditionFilterInfo;
                    sortInfo?:  GCTYPE.Pivot.IPivotViewSortInfo;
                }


            /**
             * @typedef {object} GCTYPE.Spread.Pivot.ISerializeInfo
             * @property {GCTYPE.Spread.Pivot.PivotTableLayoutType} [layoutType]
             * @property {object} [options] the options of pivot table
             * @property {string} [theme] the theme of pivot table
             * @property {GCTYPE.Pivot.IDataPosition} [valuePosition] the valuePosition info of pivot table
             * @property {number[]} [pivotTablePosition] the position  of pivot table
             * @property {GCTYPE.Spread.Pivot.ISerializeFieldInfo[][]} [fieldsInfo] the fields info of pivot table
             * @property {GCTYPE.Spread.Pivot.IPivotStyle} [styles] the pivot area styles of pivot table
             * @property {object} [collapseItems] the collapse info of pivot table
             * @property {GCTYPE.Spread.Pivot.ISerializeShowDataAsInfo[]} [showDataAsList] the show data as info of pivot table
             */
            export type ISerializeInfo =
                {
                    layoutType?:  GCTYPE.Spread.Pivot.PivotTableLayoutType;
                    options?: object;
                    theme?: string;
                    valuePosition?: GCTYPE.Pivot.IDataPosition;
                    pivotTablePosition?: number[];
                    fieldsInfo?:  GCTYPE.Spread.Pivot.ISerializeFieldInfo[][];
                    styles?: GCTYPE.Spread.Pivot.IPivotStyle[];
                    collapseItems?: object;
                    showDataAsList?: GCTYPE.Spread.Pivot.ISerializeShowDataAsInfo[];
                }


            /**
             * @typedef {object} GCTYPE.Spread.Pivot.ISerializeShowDataAsInfo
             * @property {string} valueFieldName
             * @property {GCTYPE.Spread.Pivot.IPivotShowDataAsInfo} showDataAsInfo
             */
            export type ISerializeShowDataAsInfo =
                {
                    valueFieldName: string;
                    showDataAsInfo: GCTYPE.Spread.Pivot.IPivotShowDataAsInfo;
                }


            /**
             * @typedef {object} GCTYPE.Spread.Pivot.ISourceFieldInfo
             * @property {string} name the name of source field
             * @property {GCTYPE.Pivot.PivotSourceFieldType} [fieldType] the pivot field type is calc field or group field
             */
            export type ISourceFieldInfo =
                {
                    name: string;
                    fieldType?: GCTYPE.Pivot.PivotSourceFieldType;
                }


            /**
             * @typedef {object} GCTYPE.Spread.Pivot.ITextCollectionCondition
             * @property {string[]} list
             * @property {boolean} isAll
             */
            export type ITextCollectionCondition =
                {
                    list: string[];
                    isAll: boolean;
                }


            /**
             * @typedef {object} GCTYPE.Spread.Pivot.ITextGroupInfo The text group info.
             * @property {string} originFieldName  The source field name.
             * @property {object} textGroup  The text group info
             * @property {string} textGroup.fieldName  The group field name.
             * @property {GCTYPE.Pivot.IStringGroupItems} textGroup.groupItems  The text group items info.
             */
            export type ITextGroupInfo =
                {
                    originFieldName: string;
                    textGroup: {
                        fieldName: string;
                        groupItems: GCTYPE.Pivot.IStringGroupItems;
                    }
                }

            /**
             * Indicates the display direction of the pivot table's page area.
             * @enum {number}
             */
            export enum DisplayFields{
                /**
                 * Indicates the first vertical direction, then horizontal direction.
                 */
                downThenOver= 0,
                /**
                 * Indicates the first horizontal direction, then vertical direction.
                 */
                overThenDown= 1
            }

            /**
             * Indicates the direction of grand total in the pivot table.
             * @enum {number}
             */
            export enum GrandTotalPosition{
                /**
                 * Don't show grand total
                 */
                none= 0,
                /**
                 * Show grand total in row direction for pivot table.
                 */
                row= 1,
                /**
                 * Show grand total in column direction for pivot table.
                 */
                col= 2,
                /**
                 * Show grand total in row and column direction for pivot table.
                 */
                both= 3
            }

            /**
             * Indicates the pivot area axis type of pivot table.
             * @enum {number}
             */
            export enum PivotAreaAxisType{
                /**
                 * indicate grandTotal is on the row axis
                 */
                row= 0,
                /**
                 * indicate grandTotal is on the col axis
                 */
                col= 1
            }

            /**
             * Indicates the pivot area type of pivot table.
             * @enum {number}
             */
            export enum PivotAreaType{
                /**
                 * indicate the filter button of the pivot table
                 */
                button= 1,
                /**
                 * indicate the corner of the pivot table
                 */
                corner= 5,
                /**
                 * indicate the top right area of the pivot table
                 */
                topRight= 7
            }

            /**
             * Indicates the pivot panel layout type.
             * @enum {number}
             */
            export enum PivotPanelLayoutType{
                /**
                 * stack
                 * @type {number}
                 */
                stack= 0,
                /**
                 * flow
                 * @type {number}
                 */
                flow= 1
            }

            /**
             * Indicates the pivot panel section.
             * @enum {number}
             */
            export enum PivotPanelSection{
                /**
                 * fields
                 * @type {number}
                 */
                fields= 1,
                /**
                 * area
                 * @type {number}
                 */
                area= 2,
                /**
                 * viewList
                 * @type {number}
                 */
                viewList= 4
            }

            /**
             * Indicates the pivot table field area.
             * @enum {number}
             */
            export enum PivotTableFieldType{
                /**
                 * Filter area
                 * @type {number}
                 */
                filterField= 0,
                /**
                 * Row area
                 * @type {number}
                 */
                rowField= 1,
                /**
                 * Column area
                 * @type {number}
                 */
                columnField= 2,
                /**
                 * Value area
                 * @type {number}
                 */
                valueField= 3
            }

            /**
             * Indicates the view layout type of pivot table.
             * @enum {number}
             */
            export enum PivotTableLayoutType{
                /**
                 * Compact layout
                 */
                compact= 0,
                /**
                 * Outline layout
                 */
                outline= 1,
                /**
                 * Tabular layout
                 */
                tabular= 2
            }

            /**
             * Indicates the position of subtotal in the pivot table.
             * @enum {number}
             */
            export enum SubtotalsPosition{
                /**
                 * Don't show subtotal.
                 */
                none= 0,
                /**
                 * Show subtotal at the top of the pivot table.
                 */
                top= 1,
                /**
                 * Show subtotal at the bottom of the pivot table.
                 */
                bottom= 2
            }


            export class PivotPanel{
                /**
                 * Represents the pivot panel of pivot table.
                 * @class
                 * @param {string} name Indicates the Pivot panel name.
                 * @param {GCTYPE.Spread.Pivot.PivotTable} pivotTable  Indicates the pivot table that is related pivot panel.
                 * @param {HTMLDivElement} host Indicates the container html element of the pivot panel.
                 * @example
                 * //This example creates a pivot panel.
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * pivotTable.suspendLayout();
                 * pivotTable.options.showRowHeader =true;
                 * pivotTable.options.showColumnHeader =true;
                 * pivotTable.add("Buyer", "Buyer", GCTYPE.Spread.Pivot.PivotTableFieldType.columnField);
                 * pivotTable.add("Type", "Type", GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Amount", "Sum of Amount",   GCTYPE.Spread.Pivot.PivotTableFieldType.valueField, GCTYPE.Pivot.SubtotalType.sum);
                 * var panel = new GCTYPE.Spread.Pivot.PivotPanel("myPivotPanel", pivotTable, document.getElementById("panel"));
                 * pivotTable.resumeLayout();
                 */
                constructor(name: string,  pivotTable: GCTYPE.Spread.Pivot.PivotTable,  host: HTMLDivElement);
                /**
                 * @description attach to a pivot table for pivot panel, then the pivot panel can control the bound pivot table.
                 * @param {GCTYPE.Spread.Pivot.PivotTable} pivotTable  Indicates the pivot table which is attached.
                 * @returns void
                 */
                attach(pivotTable: GCTYPE.Spread.Pivot.PivotTable): any;
                /**
                 * @description destroy the PivotPanel.
                 */
                destroy(): any;
                /**
                 * @description detach the pivot table for pivot panel, stop the pivot panel control bound pivot table.
                 * @returns void
                 */
                detach(): void;
                /**
                 * @description set or get the panelLayout type.
                 * @param {GCTYPE.Spread.Pivot.PivotPanelLayoutType} [value] change the panelLayout option to stack or flow.
                 * @returns GCTYPE.Spread.Pivot.PivotPanelLayoutType | void
                 */
                panelLayout(value?: GCTYPE.Spread.Pivot.PivotPanelLayoutType): GCTYPE.Spread.Pivot.PivotPanelLayoutType | void;
                /**
                 * @description  get or set which sections are visible.
                 * @param {number} [value] get or set which sections are visible by the sum of GCTYPE.Spread.Pivot.PivotPanelSection enum.
                 * @returns {number|void} The visibility value.
                 * @example
                 *  var visibility = pivotPanel.sectionVisibility() // 7;
                 *  visibility = visibility & ~GCTYPE.Spread.Pivot.PivotPanelSection.viewList; // 3
                 *  pivotPanel.sectionVisibility(visibility);
                 */
                sectionVisibility(value?: number): number | void;
            }

            export class PivotTable{
                /**
                 * Represents a PivotTable.
                 * @class
                 * @param {string} name Indicates the name of pivot table.
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet Indicates the owner worksheet.
                 * @param {number} row Indicates the pivot table start row.
                 * @param {number} col Indicates the pivot table start column.
                 * @param {GCTYPE.Spread.Pivot.PivotTableLayoutType} layout Indicates the pivot table layout type.
                 * @param {GCTYPE.Spread.Pivot.PivotTableTheme} style Indicates the pivot table theme style.
                 */
                constructor(name: string,  sheet?: GCTYPE.Spread.Sheets.Worksheet,  row?: number,  col?: number,  layout?: GCTYPE.Spread.Pivot.PivotTableLayoutType,  style?: GCTYPE.Spread.Pivot.PivotTableTheme,  options?: GCTYPE.Spread.Pivot.IPivotTableOption,  layoutModel?: any);
                /**
                 * Indicates the options of the sheet.
                 * @type {Object}
                 * @property {boolean} [allowMultipleFiltersPerField] Indicates whether use multiple filter in one field.
                 * @property {boolean} [fillDownLabels] Indicates show repeat label items or not.
                 * @property {boolean} [insertBlankLineAfterEachItem] Indicates whether insert a blank row at end of each item.
                 * @property {GCTYPE.Spread.Pivot.GrandTotalPosition} [grandTotalPosition] Indicates whether show grandtotal in row, column or both.
                 * @property {GCTYPE.Spread.Pivot.SubtotalsPosition} [subTotalsPosition] Indicates show subtotal top or bottom or not show.
                 * @property {GCTYPE.Spread.Pivot.SubtotalsPosition} [subtotalsPosition] Indicates show subtotal top or bottom or not show.
                 * @property {GCTYPE.Spread.Pivot.DisplayFields} [displayFieldsInPageFilterArea] Indicates the field display in page area show first over then down or first down then over.
                 * @property {number} [reportFilterFieldsPerColumn] Indicates the number of report filer field per column.
                 * @property {boolean} [bandRows] Indicates show band row or not.
                 * @property {boolean} [bandColumns] Indicates show band column or not.
                 * @property {boolean} [showRowHeader] Indicates show row header style or not.
                 * @property {boolean} [showColumnHeader] Indicates show column header style or not.
                 * @property {boolean} [showDrill] Indicates show expand/collapse button or not.
                 * @property {boolean} [showMissing] Indicates whether the missingCaption option is effected.
                 * @property {boolean} [missingCaption] Indicates what value should be shown when the actual value is empty
                 * @property {boolean} [rowLabelIndent] Indicates the indent of the title of each level.
                 * @property {boolean} [printDrill] Print expand/collapse buttons when displayed on PivotTable.
                 * @property {boolean} [itemPrintTitles] Repeat row labels on each PivotTable.
                 * @property {boolean} [fieldPrintTitles] Set Print titles.
                 * @property {boolean} [showFilter] Indicates show filter button or not.
                 * @property {boolean} [showToolTip] Indicates show tooltip or not.
                 * @property {boolean} [mergeItem] Indicates wether merge and center the cells with labels.
                 * @property {boolean} [isShowErrorValue] Indicates whether the errorValueInfo option is effected.
                 * @property {boolean} [errorValueInfo] Indicates what value should be shown when the actual value is a error
                 */
                options: GCTYPE.Spread.Pivot.IPivotTableOption;
                /**
                 * Pivot table view manager for the pivot table.
                 * @type {GCTYPE.Spread.Pivot.IPivotTableViewManager}
                 */
                views: GCTYPE.Spread.Pivot.IPivotTableViewManager;
                /**
                 * @description Add a field to pivot table.
                 * @param {string} sourceName Indicates the source name of  the field.
                 * @param {string} displayName Indicates the display name of the field.
                 * @param {number} area Indicates which area will be added to.
                 * @param {GCTYPE.Pivot.SubtotalType} [subtotal] Indicates the summary type when the field add to value area.
                 * @param {number} [index] Indicates the field index of pivot table's field area.
                 * @returns {void}
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * var subtotal = GCTYPE.Pivot.SubtotalType.count;
                 * pivotTable.add("Buyer", "Buyer", 1, subtotal, 0) //add a field to pivot table, and field name is displayName, field in row area
                 */
                add(sourceName: string,  displayName: string,  area: number,  subtotal?: GCTYPE.Pivot.SubtotalType,  index?: number): void;
                /**
                 * @description Add a calculated field, the calculated field can only add into value area of pivot table.
                 * @param {string} fieldName Indicates the calculated field name.
                 * @param {string} formula Indicates the calculated formula.
                 * @returns {void}
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData);
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var pivotTable = sheet.pivotTables.add("myPivotTable", 'sourceData', 1, 1, layout, theme);
                 * pivotTable.addCalcField("PercentOfEach", "=Amount/454");
                 */
                addCalcField(fieldName: string,  formula: string): void;
                /**
                 * Sets the rules using the pivot areas.
                 * @param {GCTYPE.Spread.Pivot.IPivotArea[]} pivotArea The pivotArea in pivot table.
                 * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} conditionalRule The rules set to the pivot area.
                 * @example
                 * //This example uses the getRule method.
                 * var pivotTable = activeSheet.pivotTables.all()[0];
                 * var rule = new GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule();
                 * rule.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.threeScaleRule);
                 * rule.midColor("#12ff34");
                 * rule.midType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * rule.midValue(50000);
                 * rule.maxColor("#EE3344");
                 * rule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * rule.maxValue(400000);
                 * rule.minColor("#AAff34");
                 * rule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * rule.minValue(5000);
                 * var AmericaPivotArea = {
                 *        dataOnly: true
                 *        references: [{
                 *            fieldName: "Country",
                 *            items: ["America"]
                 *        }]
                 *    }
                 * var BritainPivotArea = {
                 *        dataOnly: true
                 *        references: [{
                 *            fieldName: "Country",
                 *            items: ["Britain"]
                 *        }]
                 *    }
                 * pivotTable.addConditionalRule([AmericaPivotArea, BritainPivotArea], rule);
                 */
                addConditionalRule(pivotArea: GCTYPE.Spread.Pivot.IPivotArea[],  conditionalRule: GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase): void;
                /**
                 * @description Set the minimum visual column width for each Field item.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme);
                 * pivotTable.add("Type", "Type", GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Date", "Date", GCTYPE.Spread.Pivot.PivotTableFieldType.columnField);
                 * pivotTable.add("Amount", "Sum of Amount", GCTYPE.Spread.Pivot.PivotTableFieldType.valueField, GCTYPE.Pivot.SubtotalType.sum);
                 * pivotTable.autoFitColumn();
                 */
                autoFitColumn(): void;
                /**
                 * @description Get or set collapse info for a field of pivot table.
                 * @param {string} fieldName Indicates the target field name.
                 * @param {string} item Indicates the collapse item name.
                 * @param {boolean} [isCollapse] Indicates the status of the collapse.
                 * @returns {boolean|void} whether is collapsed.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * pivotTable.add("Buyer", "Buyer", 1, subtotal, 0);
                 * pivotTable.add("Type", "Type", 1, subtotal, 1);
                 * var collapseValue = pivotTable.collapse("Buyer","Mom");
                 * pivotTable.collapse("Buyer","Mom", !collapseValue);
                 */
                collapse(fieldName: string,  item: string,  isCollapse?: boolean): boolean | void;
                /**
                 * @description Get or set the values position.
                 * @param {GCTYPE.Pivot.DataPosition} [positionType] Indicates the position which is in row or column area.
                 * @param {number} [positionIndex] Indicates the order in field row or column list.
                 * @returns {GCTYPE.Pivot.IDataPosition|void} return the data position info of pivot table or void
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * pivotTable.dataPosition(1,0) //move values to row area and index is 0
                 * pivotTable.dataPosition();//{positionType:1,positionIndex:0}
                 */
                dataPosition(positionType?: GCTYPE.Pivot.DataPosition,  positionIndex?: number): GCTYPE.Pivot.IDataPosition | void;
                /**
                 * @description restore serialized pivot table data to a existed pivot table
                 * @param {object} serializeInfo serialized pivot table data.
                 * @param {GCTYPE.Spread.Pivot.PivotTableLayoutType} [serializeInfo.layoutType] the layoutType of pivot table
                 * @param {object} [serializeInfo.options] the options of pivot table
                 * @param {string} [serializeInfo.theme] the theme of pivot table
                 * @param {object} [serializeInfo.valuePosition] the valuePosition info of pivot table
                 * @param {array} [serializeInfo.pivotTablePosition] the position  of pivot table
                 * @param {array} [serializeInfo.fieldsInfo] the fields info of pivot table
                 * @param {array} [serializeInfo.styles] the pivot area styles of pivot table
                 * @param {object} [serializeInfo.collapseItems] the collapse info of pivot table
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme);
                 * pivotTable.add("Buyer","Buyer",GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Type","Type",GCTYPE.Spread.Pivot.PivotTableFieldType.columnField);
                 * pivotTable.add("Amount","Sum of Amount",GCTYPE.Spread.Pivot.PivotTableFieldType.valueField, GCTYPE.Pivot.SubtotalType.sum);
                 * var serialization = pivotTable.serialize();
                 * pivotTable.remove('Type');
                 * pivotTable.deserialize(serialization);
                 */
                deserialize(serializeInfo: GCTYPE.Spread.Pivot.ISerializeInfo): void;
                /**
                 * @description get all calculated fields's info.
                 * @return {GCTYPE.Spread.Pivot.ICalcFieldInfo[]} return all calculated fields's info.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var pivotTable = sheet.pivotTables.add("pivotTable1", 'sourceData', 1, 1, layout, theme);
                 * pivotTable.addCalcField("PercentOfEach", "=Amount/454");
                 * pivotTable.getCalcFields();
                 */
                getCalcFields(): GCTYPE.Spread.Pivot.ICalcFieldInfo[];
                /**
                 * Gets the rules using the pivot area.
                 * @param {GCTYPE.Spread.Pivot.IPivotArea} pivotArea The pivotArea in pivot table.
                 * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase[]} The rules from the pivot area.
                 * @example
                 * //This example uses the getRule method.
                 * var pivotTable = activeSheet.pivotTables.all()[0];
                 * var rule = new GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule();
                 * rule.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.threeScaleRule);
                 * rule.midColor("#12ff34");
                 * rule.midType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * rule.midValue(50000);
                 * rule.maxColor("#EE3344");
                 * rule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * rule.maxValue(400000);
                 * rule.minColor("#AAff34");
                 * rule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * rule.minValue(5000);
                 * var AmericaPivotArea = {
                 *        dataOnly: true
                 *        references: [{
                 *            fieldName: "Country",
                 *            items: ["America"]
                 *        }]
                 *    }
                 * var BritainPivotArea = {
                 *        dataOnly: true
                 *        references: [{
                 *            fieldName: "Country",
                 *            items: ["Britain"]
                 *        }]
                 *    }
                 * pivotTable.addConditionalRule([AmericaPivotArea, BritainPivotArea], rule);
                 * var ruleTest = pivotTable.getConditionalRules(BritainPivotArea);
                 * alert(ruleTest[0].midValue());
                 */
                getConditionalRules(pivotArea: GCTYPE.Spread.Pivot.IPivotArea): GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase[];
                /**
                 * @description Get field information from pivot table by field name
                 * @param {string} fieldName the field's name
                 * @returns {GCTYPE.Spread.Pivot.IFieldInfo} return a field information
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * pivotTable.add("Buyer","Buyer",GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Type","Type",GCTYPE.Spread.Pivot.PivotTableFieldType.columnField);
                 * pivotTable.add("Amount","Sum of Amount",GCTYPE.Spread.Pivot.PivotTableFieldType.valueField, GCTYPE.Pivot.SubtotalType.sum);
                 * pivotTable.getField("Type");
                 */
                getField(fieldName: string): GCTYPE.Spread.Pivot.IFieldInfo;
                /**
                 * @description Get all field information from pivot table or one of pivot table area
                 * @param {GCTYPE.Spread.Pivot.PivotTableFieldType} [area] area index
                 * @returns {GCTYPE.Spread.Pivot.IFieldInfo[]} return all field information in the pivot table area
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * pivotTable.add("Buyer","Buyer",GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Type","Type",GCTYPE.Spread.Pivot.PivotTableFieldType.columnField);
                 * pivotTable.add("Amount","Sum of Amount",GCTYPE.Spread.Pivot.PivotTableFieldType.valueField, GCTYPE.Pivot.SubtotalType.sum);
                 * pivotTable.getFieldsByArea(GCTYPE.Spread.PivotTableFieldType.columnField);
                 */
                getFieldsByArea(area?: GCTYPE.Spread.Pivot.PivotTableFieldType): GCTYPE.Spread.Pivot.IFieldInfo[];
                /**
                 * @description get all items from pivot table by field name
                 * @param {string} fieldName the field name of pivot table field
                 * @returns {string[]}return all items of pivot table field
                 */
                getItemsByField(fieldName: string): any;
                /**
                 * @description get the sheet ranges that corresponding to the specific pivotArea.
                 * @param {GCTYPE.Spread.Pivot.IPivotArea} pivotArea the specific pivotArea
                 * @returns {GCTYPE.Spread.Sheets.Range[]} ranges the sheet ranges that corresponding to the specific pivotArea.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                 * var sourceSheet = spread.getSheet(0)
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                  ["01-Jan","Mom","Fuel",74],
                 *                  ["15-Jan","Mom","Food",235],
                 *                  ["17-Jan","Dad","Sports",20],
                 *                  ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData);
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable1", 'sourceData', 1, 1, layout, theme, options);
                 * pivotTable.add("Buyer", "Buyer", GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Type", "Type", GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Date", "Date", GCTYPE.Spread.Pivot.PivotTableFieldType.columnField);
                 * pivotTable.add("Amount", "Amount", GCTYPE.Spread.Pivot.PivotTableFieldType.valueField, GCTYPE.Pivot.SubtotalType.sum);
                 * var pivotArea = {
                 *     dataOnly: false,
                 *     references: [
                 *         {
                 *             fieldName: "Buyer",
                 *             items: ["Mom", "Dad"]
                 *         }
                 *     ]
                 * };
                 * let ranges = pivotTable.getPivotAreaRanges(pivotArea);
                 */
                getPivotAreaRanges(pivotArea: GCTYPE.Spread.Pivot.IPivotArea): GCTYPE.Spread.Sheets.Range[];
                /**
                 * @description get PivotTable Details
                 * @param {Array} pivotItemInfo The pivot details information list
                 * @param {string} pivotItemInfo.fieldName The name of field
                 * @param {string} pivotItemInfo.fieldItem The name of field item
                 * @returns {array|void}
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                 * var sourceSheet = spread.getSheet(0)
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                  ["01-Jan","Mom","Fuel",74],
                 *                  ["15-Jan","Mom","Food",235],
                 *                  ["17-Jan","Dad","Sports",20],
                 *                  ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData);
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * var pivotTable = sheet.pivotTables.get("pivotTable_1");
                 * pivotTable.add("Buyer","Buyer",GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Type","Type",GCTYPE.Spread.Pivot.PivotTableFieldType.columnField);
                 * pivotTable.add("Amount","Sum of Amount",GCTYPE.Spread.Pivot.PivotTableFieldType.valueField, GCTYPE.Pivot.SubtotalType.sum);
                 * pivotTable.getPivotDetails([{fieldName:"Buyer", fieldItem:"Kelly"}]]);
                 */
                getPivotDetails(pivotItemInfo: GCTYPE.Spread.Pivot.IPivotItemInfo[]): any[][] | void;
                /**
                 * @description Get the range of PivotTable, consist of page & content. They are readonly, change the range will not take any effect.
                 * @returns {GCTYPE.Spread.Pivot.IPivotTableRange} return current pivot table range.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                 * var sourceSheet = spread.getSheet(0)
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                  ["01-Jan","Mom","Fuel",74],
                 *                  ["15-Jan","Mom","Food",235],
                 *                  ["17-Jan","Dad","Sports",20],
                 *                  ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData);
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var pivotTable = sheet.pivotTables.add("pivotTable1", 'sourceData', 1, 1, layout, theme);
                 * pivotTable.add("Buyer", "Buyer", GCTYPE.Spread.Pivot.PivotTableFieldType.filterField);
                 * pivotTable.add("Type", "Type", GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Date", "Date", GCTYPE.Spread.Pivot.PivotTableFieldType.columnField);
                 * pivotTable.add("Amount", "Amount", GCTYPE.Spread.Pivot.PivotTableFieldType.valueField, GCTYPE.Pivot.SubtotalType.sum);
                 * var ranges = pivotTable.getRange();
                 * console.log(ranges.page, ranges.content);
                 */
                getRange(): GCTYPE.Spread.Pivot.IPivotTableRange;
                /**
                 * @description get PivotTable data refer
                 * @returns {string}
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                 * var sourceSheet = spread.getSheet(0)
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                  ["01-Jan","Mom","Fuel",74],
                 *                  ["15-Jan","Mom","Food",235],
                 *                  ["17-Jan","Dad","Sports",20],
                 *                  ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData);
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme);
                 * var pivotTable = sheet.pivotTables.get("pivotTable_1");
                 * pivotTable.getSource();
                 */
                getSource(): string;
                /**
                 * @description get PivotTable source field information
                 * @returns {GCTYPE.Spread.Pivot.ISourceFieldInfo[]}
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                 * var sourceSheet = spread.getSheet(0)
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                  ["01-Jan","Mom","Fuel",74],
                 *                  ["15-Jan","Mom","Food",235],
                 *                  ["17-Jan","Dad","Sports",20],
                 *                  ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData);
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * var pivotTable = sheet.pivotTables.get("pivotTable_1");
                 * pivotTable.addCalcField("calcField", "=Amount*2");
                 * pivotTable.getSourceFields();
                 */
                getSourceFields(): GCTYPE.Spread.Pivot.ISourceFieldInfo[];
                /**
                 * @description Get style by the specific pivotArea.
                 * @param {GCTYPE.Spread.Pivot.IPivotArea} pivotArea the specific pivotArea
                 * @returns GCTYPE.Spread.Sheets.Style
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                 * var sourceSheet = spread.getSheet(0)
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                  ["01-Jan","Mom","Fuel",74],
                 *                  ["15-Jan","Mom","Food",235],
                 *                  ["17-Jan","Dad","Sports",20],
                 *                  ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData);
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable1", 'sourceData', 1, 1, layout, theme, options);
                 * pivotTable.add("Buyer", "Buyer", GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Type", "Type", GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Date", "Date", GCTYPE.Spread.Pivot.PivotTableFieldType.columnField);
                 * pivotTable.add("Amount", "Amount", GCTYPE.Spread.Pivot.PivotTableFieldType.valueField, GCTYPE.Pivot.SubtotalType.sum);
                 * var pivotArea = {
                 *     dataOnly: false,
                 *     references: [
                 *         {
                 *             fieldName: "Buyer",
                 *             items: ["Mom", "Dad"]
                 *         }
                 *     ]
                 * };
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * redBack.backColor = '#ff0000';
                 * pivotTable.setStyle(pivotArea, style);
                 * pivotTable.getStyle(pivotArea);
                 */
                getStyle(pivotArea: GCTYPE.Spread.Pivot.IPivotArea): GCTYPE.Spread.Sheets.Style;
                /**
                 * @description Group the items of field
                 * @param {GCTYPE.Spread.Pivot.ITextGroupInfo | GCTYPE.Spread.Pivot.INumberGroupInfo | GCTYPE.Spread.Pivot.IDateGroupsInfo} groupInfo Indicates the grouped info.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["19-Jan","David","Books",120],
                 *                   ["20-Jan","Dad","Food",160],
                 *                   ["21-Jan","David","Sports",15],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 8, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * var groupInfo = {
                 *     originFieldName: "Buyer",
                 *     textGroup: {
                 *         fieldName: "FamilyMembers",
                 *         groupItems: {
                 *              "parent": ["Mom", "Dad"],
                 *              "children": ["David", "Kelly"]
                 *         }
                 *     }
                 * };
                 * pivotTable.group(groupInfo);
                 * pivotTable.add("FamilyMembers", "FamilyMembers", GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Buyer", "Buyer", GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Amount", "Sum of Amount", GCTYPE.Spread.Pivot.PivotTableFieldType.valueField, GCTYPE.Pivot.SubtotalType.sum);
                 * sheet.resumePaint();
                 */
                group(groupInfo: GCTYPE.Spread.Pivot.ITextGroupInfo | GCTYPE.Spread.Pivot.INumberGroupInfo | GCTYPE.Spread.Pivot.IDateGroupsInfo): void;
                /**
                 * Get or set label filter info for a field.
                 * @param {string} fieldName Indicates the target field name of pivot table.
                 * @param {object} [filterInfo] Indicates the label filter info when set.
                 * @returns {GCTYPE.Spread.Pivot.IPivotTextFilterInfo | GCTYPE.Spread.Pivot.IPivotConditionFilterInfo} return pivot table labelFilter information
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * pivotTable.suspendLayout();
                 * pivotTable.options.showRowHeader = true;
                 * pivotTable.options.showColumnHeader = true;
                 * pivotTable.add("Buyer", "Buyer", GCTYPE.Spread.Pivot.PivotTableFieldType.columnField);
                 * pivotTable.add("Type", "Type", GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * var condition = { conType: GCTYPE.Pivot.PivotConditionType.caption, operator: GCTYPE.Pivot.PivotCaptionFilterOperator.contains, val: ["Mom"] };
                 * var filterInfo = { condition };
                 * pivotTable.labelFilter("Buyer", filterInfo);
                 * pivotTable.add("Amount", "Sum of Amount", GCTYPE.Spread.Pivot.PivotTableFieldType.valueField, GCTYPE.Pivot.SubtotalType.sum);
                 * pivotTable.resumeLayout();
                 */
                labelFilter(fieldName: string,  filterInfo?: GCTYPE.Spread.Pivot.IPivotTextFilterInfo | GCTYPE.Spread.Pivot.IPivotConditionFilterInfo | null): GCTYPE.Spread.Pivot.IPivotTextFilterInfo | GCTYPE.Spread.Pivot.IPivotConditionFilterInfo | void;
                /**
                 * @description Get or set the layoutType of pivot table
                 * @param {GCTYPE.Spread.Pivot.PivotTableLayoutType} [type] Indicates the pivot Table layout Type
                 * @returns {GCTYPE.Spread.Pivot.PivotTableLayoutType} If no parameters are passed in, get the current layout type.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * var pivotTableLayoutType = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * pivotTable.layoutType(pivotTableLayoutType);
                 * pivotTable.layoutType();//GCTYPE.Spread.Pivot.PivotTableLayoutType.compact
                 */
                layoutType(type?: GCTYPE.Spread.Pivot.PivotTableLayoutType): GCTYPE.Spread.Pivot.PivotTableLayoutType;
                /**
                 * @description Get or set pivot table name.
                 * @param {string} name Indicates the pivot table name.
                 * @returns {string | void}
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * pivotTable.name("pivotTable_2")
                 * console.log(pivotTable.name()); //pivotTable_2
                 */
                name(name?: string): string | void;
                /**
                 * @description Get or set pivot table start position, the position of pivot table will auto change when there are enough cells to put the pivot table
                 * @param {number} [row] Indicates pivot table start row.
                 * @param {number} [col] Indicates pivot table start col.
                 * @param {string} [sheetName] Which sheet is pivot table on.
                 * @returns {GCTYPE.Spread.Pivot.IPivotTablePosition | void}
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var toSheet = spread.getSheet(2);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * pivotTable.position(10,10,toSheet.name());
                 * pivotTable.position(); //{row:10,col:10, sheetName: "Sheet3"}
                 */
                position(row?: number,  col?: number,  sheetName?: string): GCTYPE.Spread.Pivot.IPivotTablePosition | void;
                /**
                 * @description  Refresh fields Layout, re calc all field data in sheet.
                 */
                refresh(): void;
                /**
                 * @description Delete a field by name.
                 * @param {string} fieldName Indicates the fieldName which will be removed.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * pivotTable.add("Buyer", "Buyer", 1, GCTYPE.Pivot.SubtotalType.count, 0);
                 * pivotTable.remove("Buyer");
                 */
                remove(fieldName: string):void;
                /**
                 * @description remove a calculated field
                 * @param {string} fieldName Indicates the calculated field name.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var pivotTable = sheet.pivotTables.add("pivotTable1", 'sourceData', 1, 1, layout, theme);
                 * pivotTable.addCalcField("Amount", "PercentOfEach", "=Amount/454");
                 * var calcFieldsInfo = pivotTable.getCalcFields();
                 * pivotTable.removeCalcField(calcFieldsInfo[i].fieldName);
                 */
                removeCalcField(fieldName: string): void;
                /**
                 * Remove the rule of the pivot table.
                 * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} conditionalRule The rules set to the pivot table.
                 * @example
                 * //This example uses the getRule method.
                 * var pivotTable = activeSheet.pivotTables.all()[0];
                 * var rule = new GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule();
                 * rule.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.threeScaleRule);
                 * rule.midColor("#12ff34");
                 * rule.midType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * rule.midValue(50000);
                 * rule.maxColor("#EE3344");
                 * rule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * rule.maxValue(400000);
                 * rule.minColor("#AAff34");
                 * rule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * rule.minValue(5000);
                 * var AmericaPivotArea = {
                 *        dataOnly: true
                 *        references: [{
                 *            fieldName: "Country",
                 *            items: ["America"]
                 *        }]
                 *    }
                 * var BritainPivotArea = {
                 *        dataOnly: true
                 *        references: [{
                 *            fieldName: "Country",
                 *            items: ["Britain"]
                 *        }]
                 *    }
                 * pivotTable.addConditionalRule([AmericaPivotArea, BritainPivotArea], rule);
                 * pivotTable.removeConditionalRule(rule);
                 */
                removeConditionalRule(conditionalRule: GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase): void;
                /**
                 * @description Stop hold off update field, end of suspendLayout effect, it must be in pairs with suspendLayout.
                 */
                resumeLayout(): void;
                /**
                 * @description get serialized pivot table data
                 * @returns {GCTYPE.Spread.Pivot.ISerializeInfo} serialized pivot table data
                 */
                serialize(): GCTYPE.Spread.Pivot.ISerializeInfo;
                /**
                 * @description Set or remove style to the specific pivotArea.
                 * @param {GCTYPE.Spread.Pivot.IPivotArea} pivotArea the specific pivotArea
                 * @param {GCTYPE.Spread.Sheets.Style} style the style set to the specific pivotArea, null or undefined to remove style of the specific pivotArea.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                 * var sourceSheet = spread.getSheet(0)
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                  ["01-Jan","Mom","Fuel",74],
                 *                  ["15-Jan","Mom","Food",235],
                 *                  ["17-Jan","Dad","Sports",20],
                 *                  ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData);
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable1", 'sourceData', 1, 1, layout, theme, options);
                 * pivotTable.add("Buyer", "Buyer", GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Type", "Type", GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Date", "Date", GCTYPE.Spread.Pivot.PivotTableFieldType.columnField);
                 * pivotTable.add("Amount", "Amount", GCTYPE.Spread.Pivot.PivotTableFieldType.valueField, GCTYPE.Pivot.SubtotalType.sum);
                 * var pivotArea = {
                 *     dataOnly: false,
                 *     references: [
                 *         {
                 *             fieldName: "Buyer",
                 *             items: ["Mom", "Dad"]
                 *         }
                 *     ]
                 * };
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * redBack.backColor = '#ff0000';
                 * pivotTable.setStyle(pivotArea, style);
                 */
                setStyle(pivotArea: GCTYPE.Spread.Pivot.IPivotArea,  style: GCTYPE.Spread.Sheets.Style): void;
                /**
                 * @description get or set a value field's  showDataAs info.
                 * @param {string} fieldName the value field name the show value as will apply.
                 * @param {object} [showDataAsInfo]  the show data as info apply to value field
                 * @param {number} showDataAsInfo.showDataAs  the show data as type.
                 * @param {string} [showDataAsInfo.baseFieldName]  the base on field name
                 * @param {GCTYPE.Pivot.PivotShowDataAsBaseItemType} [showDataAsInfo.baseFieldItemType] the base on field item type
                 * @param {string} [showDataAsInfo.baseFieldItem]  the base on item name
                 * @returns {GCTYPE.Spread.Pivot.IPivotShowDataAsInfo}
                 */
                showDataAs(fieldName: string,  showDataAsInfo?: GCTYPE.Spread.Pivot.IPivotShowDataAsInfo): GCTYPE.Spread.Pivot.IPivotShowDataAsInfo | void;
                /**
                 * @description get or set sort for a field of pivot table.
                 * @param {string} fieldName Indicates the target field name.
                 * @param {GCTYPE.Pivot.IPivotViewSortInfo} sortInfo Indicates the sort info.
                 * @returns {GCTYPE.Pivot.IPivotViewSortInfo | void}
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.workbook(document.getElementById("ss"));
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = spread.getSheet(0).pivotTables.add("pivotTable_1",sourceData,1,1,layout,theme,option);
                 * pivotTable.add("Buyer","Buyer",GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Type","Type",GCTYPE.Spread.Pivot.PivotTableFieldType.columnField);
                 * pivotTable.add("Type", { sortType: GCTYPE.Pivot.SortType.asc, sortValueFieldName: "Sum of Amount"});
                 * pivotTable.sort("Buyer", { sortType: GCTYPE.Pivot.SortType.asc });
                 * pivotTable.sort("Buyer", { customSortInfo: function(fieldItemNameArray) {
                 *     return fieldItemNameArray.sort((a, b) => a.length - b.length);
                 *     }
                 * });
                 */
                sort(fieldName: string,  sortInfo: GCTYPE.Pivot.IPivotViewSortInfo): GCTYPE.Pivot.IPivotViewSortInfo | void;
                /**
                 * Get or set SubtotalType for a field.
                 * @param {string} fieldName Indicates the target field name of pivot table.
                 * @param {GCTYPE.Pivot.SubtotalType} type Indicates the subtotal type to set.
                 * @returns {GCTYPE.Pivot.SubtotalType | void}
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData);
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * pivotTable.add("Buyer","Buyer",GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Type","Type",GCTYPE.Spread.Pivot.PivotTableFieldType.columnField);
                 * pivotTable.add("Amount","Sum of Amount",GCTYPE.Spread.Pivot.PivotTableFieldType.valueField, GCTYPE.Pivot.SubtotalType.sum);
                 * var subtotalType = GCTYPE.Pivot.SubtotalType.average;
                 * pivotTable.subtotalType("Buyer", subtotalType) //set a subtotalType for a Field of name is "fieldName"
                 */
                subtotalType(fieldName: string,  type?:GCTYPE.Pivot.SubtotalType):void;
                /**
                 * @description Stop update field util resumeFieldsLayout, it must be used in pairs with resumeFieldsLayout.
                 */
                suspendLayout(): void;
                /**
                 * Get or set pivot table theme
                 * @param {string | GCTYPE.Spread.Pivot.PivotTableTheme} [theme] Indicates the pivot table internal theme name or pivot table theme instance.
                 * @returns {void | GCTYPE.Spread.Pivot.PivotTableTheme} If no parameters are passed in, get the current theme
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * pivotTable.theme("light3");
                 */
                theme(theme?: string | GCTYPE.Spread.Pivot.PivotTableTheme): void | GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * @description Ungroup the field by field name.
                 * @param {string} fieldName Indicates the ungroup field name.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"), { sheetCount: 3 });
                 * var sheet = spread.getActiveSheet();
                 * sheet.suspendPaint();
                 * var sourceDataArray = [["Date", "Buyer", "Type", "Amount"],
                 * ["01-Jan", "Mom", "Fuel", 74],
                 * ["15-Jan", "Mom", "Food", 235],
                 * ["17-Jan", "Dad", "Sports", 20],
                 * ["19-Jan", "David", "Books", 120],
                 * ["20-Jan", "Dad", "Food", 160],
                 * ["21-Jan", "David", "Sports", 15],
                 * ["21-Jan", "Kelly", "Books", 125]];
                 * sheet.setArray(3, 0, sourceDataArray);
                 * sheet.tables.add('Table1', 3, 0, 8, 4);
                 * sheet.setColumnWidth(6, 130);
                 * sheet.setColumnWidth(8, 100);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("PivotTable1", 'Table1', 3, 6, layout, theme, option);
                 * var groupInfo = {
                 *     originFieldName: "Buyer",
                 *     textGroup: {
                 *         "parent": ["Mom", "Dad"],
                 *         "children": ["David", "Kelly"]
                 *     }
                 * };
                 * pivotTable.group("FamilyMembers", groupInfo);
                 * pivotTable.add("FamilyMembers", "FamilyMembers", GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Buyer", "Buyer", GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Amount", "Sum of Amount", GCTYPE.Spread.Pivot.PivotTableFieldType.valueField, GCTYPE.Pivot.SubtotalType.sum);
                 * sheet.resumePaint();
                 *
                 * pivotTable.ungroup("FamilyMembers");
                 */
                ungroup(fieldName: string): void;
                /**
                 * @description Update the field area and index
                 * @param {string} name Indicates the field name.
                 * @param {GCTYPE.Spread.Pivot.PivotTableFieldType} area Indicates which area the field to be put.
                 * @param {number} [index] Indicates which index will be set.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * pivotTable.add("Buyer","Buyer",GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Type","Type",GCTYPE.Spread.Pivot.PivotTableFieldType.columnField);
                 * pivotTable.add("Amount","Sum of Amount",GCTYPE.Spread.Pivot.PivotTableFieldType.valueField, GCTYPE.Pivot.SubtotalType.sum);
                 * pivotTable.updateField("Buyer", GCTYPE.Spread.Pivot.PivotTableFieldType.columnField, 0) //The Field of name is "Buyer" move to column area and Field index is 2
                 */
                updateField(name: string,  area: GCTYPE.Spread.Pivot.PivotTableFieldType,  index?: number): void;
                /**
                 * @description Update the exist field Name.
                 * @param {string} oldName Indicates the old display name of field in pivot table.
                 * @param {string} newName Indicates the new display name of field in pivot table.
                 * @returns {void}
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * pivotTable.add("Buyer","Buyer",GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.updateFieldName("Buyer", "newBuyer")
                 */
                updateFieldName(oldName: string,  newName: string): void;
                /**
                 * @description refresh pivotTable data source
                 * @returns {void}
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                 * var sourceSheet = spread.getSheet(0)
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                  ["01-Jan","Mom","Fuel",74],
                 *                  ["15-Jan","Mom","Food",235],
                 *                  ["17-Jan","Dad","Sports",20],
                 *                  ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData);
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * var pivotTable = sheet.pivotTables.get("pivotTable_1");
                 * pivotTable.add("Buyer","Buyer",GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Type","Type",GCTYPE.Spread.Pivot.PivotTableFieldType.columnField);
                 * pivotTable.add("Amount","Sum of Amount",GCTYPE.Spread.Pivot.PivotTableFieldType.valueField, GCTYPE.Pivot.SubtotalType.sum);
                 * sourceSheet.setValue(1,3,1000);
                 * pivotTable.updateSource();
                 */
                updateSource(): void;
                /**
                 * Get or set value filter info for a field.
                 * @param {string} fieldName Indicates the target field name of pivot table.
                 * @param {GCTYPE.Spread.Pivot.IPivotConditionFilterInfo | void} [filterInfo] Indicates the value filter info when set.
                 * @returns {GCTYPE.Spread.Pivot.IPivotConditionFilterInfo} return the pivot table value information.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * pivotTable.suspendLayout();
                 * pivotTable.options.showRowHeader = true;
                 * pivotTable.options.showColumnHeader = true;
                 * pivotTable.add("Buyer", "Buyer", GCTYPE.Spread.Pivot.PivotTableFieldType.columnField);
                 * pivotTable.add("Type", "Type", GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * pivotTable.add("Amount", "Sum of Amount", GCTYPE.Spread.Pivot.PivotTableFieldType.valueField, GCTYPE.Pivot.SubtotalType.sum);
                 * let condition = { conType: GCTYPE.Pivot.PivotConditionType.value, operator: GCTYPE.Pivot.PivotValueFilterOperator.between, val: [0, 100] };
                 * let filterInfo = { condition: condition, conditionByName: "Sum of Amount" };
                 * pivotTable.valueFilter("Buyer", filterInfo);
                 * pivotTable.resumeLayout();
                 */
                valueFilter(fieldName: string,  filterInfo?: GCTYPE.Spread.Pivot.IPivotConditionFilterInfo | null): GCTYPE.Spread.Pivot.IPivotConditionFilterInfo | void;
            }

            export class PivotTableStyle{
                /**
                 * Represents a PivotTable Style.
                 * @class
                 * @param {string} [backColor] Indicates the backColor of pivot table style.
                 * @param {string} [foreColor] Indicates the foreColor of pivot table style.
                 * @param {string} [font] Indicates the font of pivot table style.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} [borderLeft] Indicates the borderLeft of pivot table style.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} [borderTop] Indicates the borderTop of pivot table style.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} [borderRight] Indicates the borderRight of pivot table style.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} [borderBottom] Indicates the borderBottom of pivot table style.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} [borderHorizontal] Indicates the borderHorizontal of pivot table style.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} [borderVertical] Indicates the borderVertical of pivot table style.
                 * @param {GCTYPE.Spread.Sheets.TextDecorationType} [textDecoration] Indicates the textDecoration of pivot table style.
                 */
                constructor(backColor?: string,  foreColor?: string,  font?: string,  borderLeft?: GCTYPE.Spread.Sheets.LineBorder,  borderTop?: GCTYPE.Spread.Sheets.LineBorder,  borderRight?: GCTYPE.Spread.Sheets.LineBorder,  borderBottom?: GCTYPE.Spread.Sheets.LineBorder,  borderHorizontal?: GCTYPE.Spread.Sheets.LineBorder,  borderVertical?: GCTYPE.Spread.Sheets.LineBorder,  textDecoration?: GCTYPE.Spread.Sheets.TextDecorationType);
                /**
                 * Indicates the background color.
                 * @type {string}
                 */
                backColor: string;
                /**
                 * Indicates the bottom border.
                 * @type {GCTYPE.Spread.Sheets.LineBorder}
                 */
                borderBottom: GCTYPE.Spread.Sheets.LineBorder;
                /**
                 * Indicates the horizontal border.
                 * @type {GCTYPE.Spread.Sheets.LineBorder}
                 */
                borderHorizontal: GCTYPE.Spread.Sheets.LineBorder;
                /**
                 * Indicates the left border.
                 * @type {GCTYPE.Spread.Sheets.LineBorder}
                 */
                borderLeft: GCTYPE.Spread.Sheets.LineBorder;
                /**
                 * Indicates the right border.
                 * @type {GCTYPE.Spread.Sheets.LineBorder}
                 */
                borderRight: GCTYPE.Spread.Sheets.LineBorder;
                /**
                 * Indicates the top border.
                 * @type {GCTYPE.Spread.Sheets.LineBorder}
                 */
                borderTop: GCTYPE.Spread.Sheets.LineBorder;
                /**
                 * Indicates the vertical border.
                 * @type {GCTYPE.Spread.Sheets.LineBorder}
                 */
                borderVertical: GCTYPE.Spread.Sheets.LineBorder;
                /**
                 * Indicates the font.
                 * @type {string}
                 */
                font: string;
                /**
                 * Indicates the fore color.
                 * @type {string}
                 */
                foreColor: string;
                /**
                 * Indicates the text decoration.
                 * @type {GCTYPE.Spread.Sheets.TextDecorationType}
                 */
                textDecoration: GCTYPE.Spread.Sheets.TextDecorationType;
            }

            export class PivotTableTheme{
                /**
                 * Represents a PivotTableTheme class.
                 * @class
                 */
                constructor();
                /**
                 * @description get or set the blankRowStyle of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the blank row area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                blankRowStyle(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the columnSubheading1Style of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the subheading column 1 area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                columnSubheading1Style(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the columnSubheading2Style of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the subheading column 2 area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                columnSubheading2Style(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the columnSubheading3Style of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the subheading column 3 area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                columnSubheading3Style(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the firstColumnStripeStyle of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The first alternating column style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                firstColumnStripeStyle(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the firstColumnStripSize of pivot table theme
                 * @param {number} [value] The size of the first alternating column.
                 * @returns {number | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the size of the size of the first alternating column; otherwise, returns the pivot table theme.
                 */
                firstColumnStripSize(value?: number): any;
                /**
                 * @description get or set the firstColumnStyle of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the first column.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                firstColumnStyle(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the firstHeaderCellStyle of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the first header cell.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                firstHeaderCellStyle(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the firstRowStripeStyle of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The first alternating row style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                firstRowStripeStyle(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the firstRowStripSize of pivot table theme
                 * @param {number} [value] The size of the first alternating row.
                 * @returns {number | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the size of the first alternating row; otherwise, returns the pivot table theme.
                 */
                firstRowStripSize(value?: number): any;
                /**
                 * @description get or set the grandTotalColumnStyle of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the grandTotal column area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                grandTotalColumnStyle(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the grandTotalRowStyle of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the grandTotal row area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                grandTotalRowStyle(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the headerRowStyle of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the header area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                headerRowStyle(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the name of pivot table theme
                 * @param {string} [value] name of pivot table theme
                 * @returns {string | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the name of the style; otherwise, returns the table theme.
                 */
                name(value?: string): any;
                /**
                 * @description get or set the reportFilterLabelsStyle of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the report filter labels area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                reportFilterLabelsStyle(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the reportFilterValuesStyle of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the report filter values area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                reportFilterValuesStyle(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the rowSubheading1Style of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the subheading row 1 area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                rowSubheading1Style(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the rowSubheading2Style of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the subheading row 2 area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                rowSubheading2Style(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the rowSubheading3Style of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the subheading row 3 area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                rowSubheading3Style(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the secondColumnStripeStyle of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The second alternating column style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                secondColumnStripeStyle(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the secondColumnStripSize of pivot table theme
                 * @param {number} [value] The size of the second alternating column.
                 * @returns {number | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the size of the second alternating column; otherwise, returns the pivot table theme.
                 */
                secondColumnStripSize(value?: number): any;
                /**
                 * @description get or set the secondRowStripeStyle of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The second alternating row style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                secondRowStripeStyle(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the secondRowStripSize of pivot table theme
                 * @param {number} [value] The size of the second alternating row.
                 * @returns {number | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the size of the second alternating row; otherwise, returns the pivot table theme.
                 */
                secondRowStripSize(value?: number): any;
                /**
                 * @description get or set the subtotalColumn1Style of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the subtotal column 1 area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                subtotalColumn1Style(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the subtotalColumn2Style of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the subtotal column 2 area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                subtotalColumn2Style(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the subtotalColumn3Style of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the subtotal column 3 area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                subtotalColumn3Style(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the subtotalRow1Style of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the subtotal row 1 area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                subtotalRow1Style(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the subtotalRow2Style of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the subtotal row 2 area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                subtotalRow2Style(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the subtotalRow3Style of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of the subtotal row 3 area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                subtotalRow3Style(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
                /**
                 * @description get or set the wholeTableStyle of pivot table theme
                 * @param {GCTYPE.Spread.Pivot.PivotTableStyle} [value] The default style of he data area.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableStyle | GCTYPE.Spread.Pivot.PivotTableTheme} If no value is set, returns the default style of the data area; otherwise, returns the pivot table theme.
                 */
                wholeTableStyle(value?: GCTYPE.Spread.Pivot.PivotTableStyle): any;
            }

            export class PivotTableThemes{
                /**
                 * Represents a built-in Pivot table theme collection.
                 * @class
                 */
                constructor();
                /**
                 * Gets the dark1 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark1: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark10 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark10: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark11 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark11: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark12 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark12: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark13 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark13: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark14 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark14: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark15 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark15: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark16 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark16: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark17 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark17: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark18 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark18: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark19 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark19: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark2 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark2: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark20 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark20: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark21 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark21: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark22 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark22: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark23 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark23: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark24 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark24: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark25 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark25: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark26 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark26: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark27 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark27: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark28 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark28: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark3 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark3: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark4 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark4: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark5 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark5: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark6 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark6: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark7 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark7: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark8 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark8: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the dark9 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static dark9: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light0 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light0: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light1 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light1: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light10 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light10: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light11 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light11: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light12 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light12: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light13 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light13: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light14 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light14: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light15 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light15: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light16 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light16: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light17 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light17: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light18 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light18: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light19 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light19: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light2 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light2: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light20 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light20: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light21 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light21: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light22 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light22: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light23 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light23: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light24 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light24: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light25 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light25: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light26 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light26: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light27 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light27: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light28 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light28: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light3 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light3: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light4 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light4: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light5 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light5: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light6 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light6: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light7 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light7: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light8 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light8: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the light9 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static light9: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium1 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium1: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium10 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium10: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium11 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium11: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium12 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium12: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium13 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium13: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium14 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium14: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium15 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium15: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium16 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium16: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium17 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium17: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium18 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium18: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium19 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium19: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium2 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium2: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium20 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium20: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium21 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium21: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium22 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium22: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium23 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium23: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium24 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium24: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium25 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium25: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium26 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium26: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium27 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium27: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium28 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium28: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium3 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium3: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium4 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium4: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium5 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium5: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium6 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium6: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium7 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium7: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium8 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium8: GCTYPE.Spread.Pivot.PivotTableTheme;
                /**
                 * Gets the medium9 style.
                 * @returns {GCTYPE.Spread.Pivot.PivotTableTheme}
                 */
                static medium9: GCTYPE.Spread.Pivot.PivotTableTheme;
            }
            module PivotPanel{
                /**
                 * Gets the PivotPanel instance by the host element.
                 * @param {HTMLElement|string} host The host element or the host element id.
                 * @returns {GCTYPE.Spread.Pivot.PivotPanel} The PivotPanel instance.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                 * var sourceSheet = spread.getSheet(0)
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                  ["01-Jan","Mom","Fuel",74],
                 *                  ["15-Jan","Mom","Food",235],
                 *                  ["17-Jan","Dad","Sports",20],
                 *                  ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData);
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * var pivotTable = sheet.pivotTables.get("pivotTable_1");
                 * var panel = new GCTYPE.Spread.Pivot.PivotPanel("sourceData", pivotTable, document.getElementById("pivotPanel"));
                 * var pivotPanel = GCTYPE.Spread.Pivot.PivotPanel.findControl("pivotPanel");
                 */
                function findControl(host: HTMLElement|string): GCTYPE.Spread.Pivot.PivotPanel;
            }

            module PivotTable{

                export class PivotTableViewManager{
                    /**
                     * Represents a PivotTableViewManager.
                     * @class
                     */
                    constructor(applyCallback: Function,  saveCallback: Function);
                    /**
                     * @description Add a view to pivot table views.
                     * @param {IPivotTableView} view Indicates the view to add.
                     * @example
                     * var viewsManager = pivotTable.views;
                     * viewsManager.add({
                     *      name: 'config1',
                     *      config: pivotTable.serialize()
                     * });
                     * viewsManager.get('config1');
                     */
                    add(view: IPivotTableView): boolean;
                    /**
                     * @description get all views from pivot table views.
                     * @example
                     * var viewsManager = pivotTable.views;
                     * viewsManager.save('config1');
                     * console.log(viewsManager.all());
                     */
                    all(): IPivotTableView[];
                    /**
                     * @description apply a view to current pivot table.
                     * @param {string} name Indicates the name of view to apply.
                     * @example
                     * var viewsManager = pivotTable.views;
                     * viewsManager.save('config1');
                     * viewsManager.apply('config1');
                     */
                    apply(name: string): void;
                    /**
                     * @description get a view from pivot table views.
                     * @param {string} name Indicates the name of view to query.
                     * @example
                     * var viewsManager = pivotTable.views;
                     * viewsManager.save('config1');
                     * viewsManager.get('config1');
                     */
                    get(name: string): IPivotTableView;
                    /**
                     * @description remove a view from pivot table views.
                     * @param {string} name Indicates the name of view to remove.
                     * @example
                     * var viewsManager = pivotTable.views;
                     * viewsManager.remove('config1');
                     * viewsManager.get('config1');
                     */
                    remove(name: string): void;
                    /**
                     * @description  Add a view to pivot table views.
                     * @param {string} name Indicates the name of view to save.
                     * @example
                     * var viewsManager = pivotTable.views;
                     * viewsManager.save('config1');
                     * viewsManager.get('config1');
                     */
                    save(name: string): boolean;
                }
            }

        }

        module Sheets{
            /**
             * Represents the license key for evaluation version and production version.
             */
            var LicenseKey: string;
            /**
             * Gets the Workbook instance by the host element.
             * @param {HTMLElement|string} host The host element or the host element id.
             * @returns {GCTYPE.Spread.Sheets.Workbook} The Workbook instance.
             */
            function findControl(host: HTMLElement|string): GCTYPE.Spread.Sheets.Workbook;
            /**
             * Gets the type from the type string. This method is used for supporting the serialization of the custom object.
             * @param {string} typeString The type string.
             * @returns {Object} The type.
             */
            function getTypeFromString(typeString: string): any;

            export interface FloatingObjectLoadedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                floatingObject: FloatingObjects.FloatingObject;
                element: HTMLElement;
            }


            export interface FormattedData{
                conditionalForeColor?: string | CanvasGradient | CanvasPattern;
                value?: string | CanvasGradient | CanvasPattern;
                content?: {
                type: string;
                value: string;
                }[];
            }


            export interface IActiveSheetChangedEventArgs{
                oldSheet: GCTYPE.Spread.Sheets.Worksheet;
                newSheet: GCTYPE.Spread.Sheets.Worksheet;
            }


            export interface IActiveSheetChangingEventArgs{
                oldSheet: GCTYPE.Spread.Sheets.Worksheet;
                newSheet: GCTYPE.Spread.Sheets.Worksheet;
                cancel: boolean;
            }


            export interface IBaseSpreadOption{
                width?: number;
                height?: number;
            }


            export interface IBounds{
                x?: number;
                y?: number;
                width: number;
                height: number;
            }


            export interface IButtonClickedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                sheetArea: SheetArea;
            }


            export interface ICalendarOption{
                startDay?: GCTYPE.Spread.Sheets.CalendarStartDay;
                calendarPage?: GCTYPE.Spread.Sheets.CalendarPage;
                showTime?: boolean;
            }


            export interface ICellButton{
                position?: GCTYPE.Spread.Sheets.ButtonPosition;
                useButtonStyle?: boolean;
                enabled?: boolean;
                width?: number;
                caption?: string;
                imageSrc?: string;
                imageSize?: { width: number, height: number };
                captionAlign?: GCTYPE.Spread.Sheets.CaptionAlignment;
                command?: string | ((sheet: GCTYPE.Spread.Sheets.Worksheet, row: number, col: number, option: any) => void);
                imageType?: GCTYPE.Spread.Sheets.ButtonImageType;
                visibility?: GCTYPE.Spread.Sheets.ButtonVisibility;
                hoverBackColor?: string;
                buttonBackColor?: string;
            }


            export interface ICellChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                sheetArea: SheetArea;
                propertyName: string;
                oldValue: any;
                newValue: any;
                isUndo?: boolean;
            }


            export interface ICellClickEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                sheetArea: SheetArea;
                row: number;
                col: number;
            }


            export interface ICellColorSortInfo{
                order: "top" | "bottom";
                backColor: string | GCTYPE.Spread.Sheets.IGradientFill | GCTYPE.Spread.Sheets.IGradientPathFill | GCTYPE.Spread.Sheets.IPatternFill | undefined;
                index: number;
            }


            export interface ICellDoubleClickEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                sheetArea: SheetArea;
                row: number;
                col: number;
            }


            export interface ICellPosition{
                row: number;
                col: number;
            }


            export interface ICellsInfo{
                row: number;
                col: number;
                rowCount: number;
                colCount: number;
                sheetName: string;
            }


            export interface IClearChangeInfo{
                row?: number;
                col?: number;
                rowCount?: number;
                colCount?: number;
                clearType?: GCTYPE.Spread.Sheets.ClearPendingChangeType;
            }


            export interface IClipboardChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                copyData: GCTYPE.Spread.Sheets.ICopyData;
            }


            export interface IClipboardChangingEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                copyData: GCTYPE.Spread.Sheets.ICopyData;
                cancel: boolean;
            }


            export interface IClipboardPastedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                cellRange: Range;
                pasteOption: ClipboardPasteOptions;
            }


            export interface IClipboardPastingEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                cellRange: Range;
                pasteOption: ClipboardPasteOptions;
                cancel: boolean;
            }


            export interface IColorPickerGroup{
                name?: string;
                colors: string[][];
                needScaleColor?: boolean;
            }


            export interface IColorPickerOption{
                colorBlockSize?: number;
                groups?: GCTYPE.Spread.Sheets.IColorPickerGroup[];
            }


            export interface IColumn{
                name?: string;
                formatter?: string;
                cellType?: GCTYPE.Spread.Sheets.CellTypes.Base;
                width?: number;
                visible?: boolean;
                resizable?: boolean;
                pageBreak?: boolean;
                displayName?: string;
                size?: number | string;
                value?: Function;
                starSize?: string;
            }


            export interface IColumnBindingInfo{
                name: string;
                displayName?: string;
                formatter?: string;
                size?: number | string;
                visible?: boolean;
            }


            export interface IColumnChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                col: number;
                sheetArea: SheetArea;
                propertyName: string;
                oldValue: any;
                newValue: any;
                count?: number;
                isUndo?: boolean;
            }


            export interface IColumnWidthChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                colList: number[];
                header: boolean;
            }


            export interface IColumnWidthChangingEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                colList: any[];
                header: boolean;
                cancel: boolean;
            }


            export interface ICommentChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                comment: Comments.Comment;
                propertyName: string;
            }


            export interface ICommentRemovedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                comment: Comments.Comment;
            }


            export interface ICommentRemovingEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                comment: Comments.Comment;
                cancel: boolean;
            }


            export interface ICopyData{
                text?: string;
                html?: string
            }


            export interface ICustomSortInfo{
                compareFunction: (value1: any, value2: any) => number;
                ascending: boolean;
                index: number;
            }


            export interface IDirtyCellInfo{
                row: number;
                col: number;
                newValue: any;
                oldValue: any;
            }


            export interface IDragDropBlockCompletedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                fromRow: number;
                fromCol: number;
                toRow: number;
                toCol: number;
                rowCount: number;
                colCount: number;
                copy: boolean;
                insert: boolean;
                copyOption: CopyToOptions;
            }


            export interface IDragDropBlockEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                fromRow: number;
                fromCol: number;
                toRow: number;
                toCol: number;
                rowCount: number;
                colCount: number;
                copy: boolean;
                insert: boolean;
                copyOption: CopyToOptions;
                cancel: boolean;
            }


            export interface IDragFillBlockCompletedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                fillRange: GCTYPE.Spread.Sheets.Range;
                autoFillType: GCTYPE.Spread.Sheets.Fill.AutoFillType;
                fillDirection: GCTYPE.Spread.Sheets.Fill.FillDirection;
            }


            export interface IDragFillBlockEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                fillRange: GCTYPE.Spread.Sheets.Range;
                autoFillType: GCTYPE.Spread.Sheets.Fill.AutoFillType;
                fillDirection: GCTYPE.Spread.Sheets.Fill.FillDirection;
                cancel: boolean;
            }


            export interface IDropdown{
                type: GCTYPE.Spread.Sheets.DropDownType;
                option?: object;
                submitCommand?: string | ((sheet: GCTYPE.Spread.Sheets.Worksheet, value:any, option: any) => void);
            }


            export interface IEditChangeEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                editingText: any;
            }


            export interface IEditEndedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                editingText: Object;
            }


            export interface IEditEndingEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                editor: Object;
                editingText: Object;
                cancel: boolean;
            }


            export interface IEditorStatusChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                oldStatus: EditorStatus;
                newStatus: EditorStatus;
            }


            export interface IEditStartingEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                cancel: boolean;
            }


            export interface IEnterCellEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
            }


            export interface IFilterButtonHitInfo{
                rowFilter: GCTYPE.Spread.Sheets.Filter.RowFilterBase;
                row?: number;
                col?: number;
                x?: number;
                y?: number;
                width?: number;
                height?: number;
                sheetArea?: GCTYPE.Spread.Sheets.SheetArea;
            }


            export interface IFloatingObjectChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                floatingObject: FloatingObjects.FloatingObject;
                propertyName: string;
            }


            export interface IFloatingObjectRemovedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                floatingObject: FloatingObjects.FloatingObject;
            }


            export interface IFloatingObjectRemovingEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                floatingObject: FloatingObjects.FloatingObject;
                cancel: boolean;
            }


            export interface IFloatingObjectSelectionChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                floatingObject: FloatingObjects.FloatingObject;
            }


            export interface IFontColorSortInfo{
                order: "top" | "bottom";
                fontColor?: string;
                index: number;
            }


            export interface IFormulaInfo{
                hasFormula?: boolean;
                baseRange?: GCTYPE.Spread.Sheets.Range;
                isArrayFormula?: boolean;
                formula?: string;
                formulaWithCulture?: string;
                isDynamicArray?: boolean;
            }


            export interface IFormulaRangeHitInfo{
                paramRange: GCTYPE.Spread.Sheets.IParamRange; //param range info
                inTopLeft?: boolean;
                inTopRight?: boolean;
                inBottomLeft?: boolean;
                inBottomRight?: boolean;
                inBorder?: boolean;
            }


            export interface IGradientFill{
                degree?: number;
                stops: { color: string; position: number }[];
            }


            export interface IGradientPathFill{
                type: string;
                left?: number;
                right?: number;
                top?: number;
                bottom?: number;
                stops: { color: string; position: number }[];
            }


            export interface IHitTestCellTypeHitInfo{
                x?: number;
                y?: number;
                row?: number;
                col?: number;
                cellRect?: GCTYPE.Spread.Sheets.Rect;
                sheetArea?: GCTYPE.Spread.Sheets.SheetArea;
                isReservedLocation?: boolean;
            }


            export interface IHitTestCommentHitInfo{
                x?: number;
                y?: number;
                comment?: GCTYPE.Spread.Sheets.Comments.Comment;
                area?: string;
            }


            export interface IHitTestDragInfo{
                action?: string;
                side?: string;
                outside?: boolean;
            }


            export interface IHitTestFloatingObjectHitInfo{
                x?: number;
                y?: number;
                floatingObject?: GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject;
            }


            export interface IHitTestFooterCornerInfo{
                element?: string,
            }


            export interface IHitTestInformation{
                x?: number;
                y?: number;
                rowViewportIndex?: number;
                colViewportIndex?: number;
                row?: number;
                col?: number;
                hitTestType?: GCTYPE.Spread.Sheets.SheetArea;
                resizeInfo?: GCTYPE.Spread.Sheets.IHitTestResizeInfo;
                outlineHitInfo?: GCTYPE.Spread.Sheets.IHitTestOutlineHitInfo;
                filterButtonHitInfo?: GCTYPE.Spread.Sheets.IFilterButtonHitInfo;
                dragInfo?: GCTYPE.Spread.Sheets.IHitTestDragInfo;
                cellTypeHitInfo?: GCTYPE.Spread.Sheets.IHitTestCellTypeHitInfo;
                floatingObjectHitInfo?: GCTYPE.Spread.Sheets.IHitTestFloatingObjectHitInfo;
                formulaRangeHitInfo?: GCTYPE.Spread.Sheets.IFormulaRangeHitInfo;
                commentHitInfo?: GCTYPE.Spread.Sheets.IHitTestCommentHitInfo;
                pivotTableInfo?: any;
                pivotTableCellInfo?: any;
            }


            export interface IHitTestOutlineHitInfo{
                what?: string;
                info?: GCTYPE.Spread.Sheets.IOutlineHitInfo;
            }


            export interface IHitTestResizeInfo{
                action?: string;
                index?: number;
                sheetArea?: GCTYPE.Spread.Sheets.SheetArea;
                startY?: number;
                movingY?: number;
                startX?: number;
                movingX?: number;
            }


            export interface IHitTestScrollBarInfo{
                element?: string,
            }


            export interface IHyperlink{
                url: string;
                tooltip?: string;
                linkColor?: string;
                visitedLinkColor?: string;
                target?: number;
                drawUnderline?: boolean;
                command?: string | ((sheet: GCTYPE.Spread.Sheets.Worksheet, row: number, col: number, sheetArea?: GCTYPE.Spread.Sheets.SheetArea) => void);
            }


            export interface IIHitTestTabStripInfo{
                navButton?: string;
                sheetTab?: GCTYPE.Spread.Sheets.SheetTabInfo;
                resize?: boolean;
                blank?: boolean;
            }


            export interface IInvalidOperationEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                invalidType: InvalidOperationType;
                message: string;
            }


            export interface ILabelOptions{
                alignment: GCTYPE.Spread.Sheets.LabelAlignment;
                visibility: GCTYPE.Spread.Sheets.LabelVisibility;
                font: string;
                foreColor: string;
                margin: string;
            }


            export interface ILeaveCellEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                cancel: boolean;
            }


            export interface ILeftColumnChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                oldLeftCol: number;
                newLeftCol: number;
            }


            export interface IListItem{
                text?: string;
                value?: string;
                icon?: string;
            }


            export interface IListLayout{
                direction?: GCTYPE.Spread.Sheets.LayoutDirection;
                displayAs?: GCTYPE.Spread.Sheets.LayoutDisplayAs;
                collapsible?: boolean;
            }


            export interface IListOption{
                text?: string;
                layout?: GCTYPE.Spread.Sheets.IListLayout;
                multiSelect?: boolean;
                valueType?: GCTYPE.Spread.Sheets.DropdownListValue;
                onItemSelected?: (e: MouseEvent) => string;
                items:  GCTYPE.Spread.Sheets.IListItem[] | GCTYPE.Spread.Sheets.IListOption[] | (() => HTMLElement); // a function returns a DOM element
            }


            export interface IMonthPickerOption{
                startYear?: number;
                stopYear?: number;
                height?: number;
            }


            export interface IMultiColumnOption extends GCTYPE.Spread.Sheets.IBaseSpreadOption{
                width?: number;
                height?: number;
                dataSource: string | any[];
                bindingInfos?: GCTYPE.Spread.Sheets.IColumnBindingInfo[];
            }


            export interface IOutlineColumnCheckStatusChanged{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number,
                col: number,
                status: boolean
            }


            export interface IOutlineHitInfo{
                index?: number;
                isExpanded?: boolean;
                level?: number;
                lineDirection?: GCTYPE.Spread.Sheets.Outlines.OutlineDirection;
                paintLine?: boolean;
            }


            export interface IParamRange{
                textOffset: number; // range text offset in formulatextbox's value
                text: string; // range text
                index: number; // index in all ranges
            }


            export interface IPatternFill{
                type: GCTYPE.Spread.Sheets.PatternType;
                patternColor: string;
                backgroundColor?: string;
            }


            export interface IPictureChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                picture: FloatingObjects.Picture;
                propertyName: string;
            }


            export interface IPictureSelectionChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                picture: FloatingObjects.Picture;
            }


            export interface IPivotTableChangedEventArgs{
                pivotTableName: string;
                type: "filter" | "sort" | "collapse" | "fieldChanged";
                fieldName: string;
                value?: boolean;
                sortType?: number;
                area?: GCTYPE.Spread.Pivot.PivotTableFieldType;
                index?: number;
            }


            export interface IProtectionOptions{
                allowSelectLockedCells?: boolean; //True or undefined if the user can select locked cells.
                allowSelectUnlockedCells?: boolean; //True or undefined if the user can select unlocked cells.
                allowSort?: boolean; //True if the user can sort ranges.
                allowFilter?: boolean; //True if the user can filter ranges.
                allowEditObjects?: boolean; //True if the user can edit floating objects.
                allowResizeRows?: boolean; //True if the user can resize rows.
                allowResizeColumns?: boolean; //True if the user can resize columns.
                allowDragInsertRows?: boolean; //True if the user can drag to insert rows.
                allowDragInsertColumns?: boolean; //True if the user can drag to insert columns.
                allowInsertRows?: boolean; //True if the user can insert rows.
                allowInsertColumns?: boolean; //True if the user can insert columns.
                allowDeleteRows?: boolean; //True if the user can delete rows.
                allowDeleteColumns?: boolean; //True if the user can delete columns.
                allowOutlineColumns?: boolean; //True if the user can expand or collapse the column groups.
                allowOutlineRows?: boolean; //True if the user can expand or collapse the row groups.
            }


            export interface IRangeChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                rowCount: number;
                colCount: number;
                changedCells: ICellPosition[];
                action: RangeChangedAction;
                tableNames?: string[];
                isUndo?: boolean;
            }


            export interface IRangeFilterClearedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                col: number;
            }


            export interface IRangeFilterClearingEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                col: number;
            }


            export interface IRangeFilteredEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                col: number;
                filterValues: any[];
            }


            export interface IRangeFilteringEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                col: number;
                filterValues: any[];
                conditionInfo : Object;
            }


            export interface IRangeGroupStateChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                isRowGroup: boolean;
                index: number;
                level: number;
            }


            export interface IRangeGroupStateChangingEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                isRowGroup: boolean;
                index: number;
                level: number;
                cancel: boolean;
            }


            export interface IRangeSortedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                col: number;
                ascending: boolean;
            }


            export interface IRangeSortingEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                col: number;
                ascending: boolean;
                compareFunction?: ((value1: any, value2: any) => number);
                groupSort: GCTYPE.Spread.Sheets.GroupSort;
            }


            export interface IRowChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                sheetArea: SheetArea;
                propertyName: string;
                oldValue: any;
                newValue: any;
                count?: number;
                isUndo?: boolean;
            }


            export interface IRowHeightChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                rowList: number[];
                header: boolean;
            }


            export interface IRowHeightChangingEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                rowList: any[];
                header: boolean;
                cancel: boolean;
            }


            export interface ISelectionChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                oldSelections: Sheets.Range[];
                newSelections: Sheets.Range[];
            }


            export interface ISelectionChangingEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                oldSelections: GCTYPE.Spread.Sheets.Range[];
                newSelections: GCTYPE.Spread.Sheets.Range[];
            }


            export interface ISetBorderOptions{
                all?: boolean;
                left?: boolean;
                top?: boolean;
                right?: boolean;
                bottom?: boolean;
                outline?: boolean;
                inside?: boolean;
                innerHorizontal?: boolean;
                innerVertical?: boolean;
                diagonalUp?:boolean;
                diagonalDown?:boolean;
            }


            export interface IShapeChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                shape: GCTYPE.Spread.Sheets.Shapes.Shape;
                propertyName: string;
            }


            export interface IShapeRemovedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                shape: Shapes.Shape;
            }


            export interface IShapeRemovingEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                shape: Shapes.Shape;
                cancel: boolean;
            }


            export interface IShapeSelectionChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                shape: Shapes.Shape;
            }


            export interface ISheetChangedEventArgs{
                sheetName: string;
                propertyName: string;
                sheetIndex: number;
                newValue?: boolean;
                oldValue?: boolean;
            }


            export interface ISheetChangingEventArgs{
                sheetName: string;
                propertyName: string;
                sheetIndex: number;
                cancel: boolean;
                newValue?: boolean;
                oldValue?: boolean;
            }


            export interface ISheetDefaultOption{
                rowHeight?: number;
                colHeaderRowHeight?: number;
                colWidth?: number;
                rowHeaderColWidth?: number;
            }


            export interface ISheetNameChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                oldValue: string;
                newValue: string;
            }


            export interface ISheetNameChangingEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                oldValue: string;
                newValue: string;
                cancel: boolean;
            }


            export interface ISheetTabClickEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                sheetTabIndex: number;
            }


            export interface ISheetTabDoubleClickEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                sheetTabIndex: number;
            }


            export interface ISlicerChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                slicer: GCTYPE.Spread.Sheets.Slicers.Slicer;
                propertyName: string;
            }


            export interface ISliderOption{
                max?: number;
                min?: number;
                step?: number;
                direction? :GCTYPE.Spread.Sheets.LayoutDirection;
                tooltipVisible?: boolean;
                scaleVisible ?: boolean;
                marks?: number[];
                width?: number;
                height?: number;
                formatString?: string;
            }


            export interface ISortOptions{
                groupSort?: GCTYPE.Spread.Sheets.GroupSort;
                ignoreHidden?: boolean;
            }


            export interface ISparklineChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                sparkline: Sparklines.Sparkline;
            }


            export interface ITableFilterClearedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                table: GCTYPE.Spread.Sheets.Tables.Table;
                tableCol: number;
            }


            export interface ITableFilterClearingEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                table: GCTYPE.Spread.Sheets.Tables.Table;
                tableCol: number;
            }


            export interface ITableFilteredEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                table: GCTYPE.Spread.Sheets.Tables.Table;
                tableCol: number;
                filterValues: any[];
            }


            export interface ITableFilteringEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                table: GCTYPE.Spread.Sheets.Tables.Table;
                tableCol: number;
                filterValues: any[];
                conditionInfo: Object;
            }


            export interface ITimePickerOption{
                min?: GCTYPE.Spread.Sheets.ITimePickerValue;
                max?: GCTYPE.Spread.Sheets.ITimePickerValue;
                step?: GCTYPE.Spread.Sheets.ITimePickerValue;
                formatString?: string;
                height?: number;
            }


            export interface ITimePickerValue{
                hour?: number;
                minute?: number;
                second?: number;
            }


            export interface ITopRowChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                oldTopRow: number;
                newTopRow: number;
            }


            export interface ITouchToolStripOpeningEventArgs{
                x: number;
                y: number;
                handled: boolean;
            }


            export interface IUserFormulaEnteredEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                formula: string;
                isCircularReference: boolean;
            }


            export interface IUserZoomingEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                oldZoomFactor: number;
                newZoomFactor: number;
            }


            export interface IValidationErrorEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                validator: DataValidation.DefaultDataValidator;
                validationResult: DataValidation.DataValidationResult;
            }


            export interface IValueChangedEventArgs{
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                sheetName: string;
                row: number;
                col: number;
                oldValue: any;
                newValue: any;
            }


            export interface IValueSortInfo{
                ascending: boolean;
                index: number;
            }


            export interface IWorkBookDefaultOptions{
                allowUserDragDrop?: boolean;
                allowUserDragFill?: boolean;
                allowUserZoom?: boolean;
                allowUndo?: boolean;
                allowUserResize?: boolean;
                allowSheetReorder?: boolean;
                allowContextMenu?: boolean;
                allowUserDeselect?: boolean;
                defaultDragFillType?: GCTYPE.Spread.Sheets.Fill.AutoFillType;
                showDragFillSmartTag?: boolean;
                showHorizontalScrollbar?: boolean;
                showVerticalScrollbar?: boolean;
                scrollbarShowMax?: boolean;
                scrollbarMaxAlign?: boolean;
                tabStripVisible?: boolean;
                tabStripRatio?: number;
                tabEditable?: boolean;
                newTabVisible?: boolean;
                cutCopyIndicatorVisible?: boolean;
                cutCopyIndicatorBorderColor?: string;
                tabNavigationVisible?: boolean;
                backColor?: string;
                backgroundImage?: null | string;
                backgroundImageLayout?: GCTYPE.Spread.Sheets.ImageLayout;
                showResizeTip?: GCTYPE.Spread.Sheets.ShowResizeTip;
                showDragDropTip?: boolean;
                showDragFillTip?: boolean;
                scrollIgnoreHidden?: boolean;
                highlightInvalidData?: boolean;
                showScrollTip?: GCTYPE.Spread.Sheets.ShowScrollTip;
                columnResizeMode?: GCTYPE.Spread.Sheets.ResizeMode;
                rowResizeMode?: GCTYPE.Spread.Sheets.ResizeMode;
                grayAreaBackColor?: null | string;
                useTouchLayout?: boolean;
                hideSelection?: boolean;
                resizeZeroIndicator?: GCTYPE.Spread.Sheets.ResizeZeroIndicator;
                allowUserEditFormula?: boolean;
                enableFormulaTextbox?: boolean;
                referenceStyle?: number;
                allowDynamicArray?: boolean;
                iterativeCalculation?: boolean;
                iterativeCalculationMaximumIterations?: number;
                iterativeCalculationMaximumChange?: number;
                autoFitType?: GCTYPE.Spread.Sheets.AutoFitType;
                calcOnDemand?: boolean;
                allowCopyPasteExcelStyle?: boolean;
                allowExtendPasteRange?: boolean;
                copyPasteHeaderOptions?: GCTYPE.Spread.Sheets.CopyPasteHeaderOptions;
                pasteSkipInvisibleRange?: boolean;
                allowUserDragMerge?: boolean;
                scrollByPixel?: boolean;
                scrollPixel?: number;
                sheetCount?: number;
                allowAutoCreateHyperlink?: boolean;
                enableAccessibility?: boolean;
                font?: string;
                customList?: string[][];
            }


            export interface IWorkbookHitTestInformation{
                x?: number;
                y?: number;
                worksheetHitInfo: GCTYPE.Spread.Sheets.IHitTestInformation;
                tabStripHitInfo: GCTYPE.Spread.Sheets.IIHitTestTabStripInfo;
                horizontalScrollBarHitInfo: GCTYPE.Spread.Sheets.IHitTestScrollBarInfo;
                verticalScrollBarHitInfo: GCTYPE.Spread.Sheets.IHitTestScrollBarInfo;
                footerCornerHitInfo: GCTYPE.Spread.Sheets.IHitTestFooterCornerInfo;
            }


            export interface IWorkbookOptions{
                allowUserDragMerge:boolean ; //  Whether to allow the user to drag merge cells.
                allowUserDragDrop :boolean ; // Whether to allow the user to drag and drop range data.
                allowUserDragFill :boolean ; // Whether to allow the user to drag fill a range.
                allowUserZoom :boolean ; // Whether to zoom the display by scrolling the mouse wheel while pressing the Ctrl key.
                allowUserResize :boolean ; // Whether to allow the user to resize columns and rows.
                allowUndo :boolean ; // Whether to allow the user to undo edits.
                allowSheetReorder :boolean ; // Whether the user can reorder the sheets in the Spread component.
                allowContextMenu :boolean; // Whether to allow the user to open the built-in context menu.
                allowUserDeselect :boolean; // Whether to allow the user to can use deselect in selection.
                defaultDragFillType :GCTYPE.Spread.Sheets.Fill.AutoFillType; // The default fill type.
                showDragFillSmartTag :boolean ; // Whether to display the drag fill dialog.
                showHorizontalScrollbar :boolean ; // Whether to display the horizontal scroll bar.
                showVerticalScrollbar :boolean ; // Whether to display the vertical scroll bar.
                scrollbarShowMax :boolean ; // Whether the displayed scroll bars are based on the entire number of columns and rows in the sheet.
                scrollbarMaxAlign :boolean ; // Whether the scroll bar aligns with the last row and column of the active sheet.
                tabStripVisible :boolean ; // Whether to display the sheet tab strip.
                tabStripRatio :number; // The width of the tab strip expressed as a percentage of the overall horizontal scroll bar width.
                tabStripWidth :number; // The width of the tab strip when it is at the left or right position. The default and mimimum is 80.
                tabEditable :boolean ; // Whether to allow the user to edit the sheet tab strip.
                tabStripPosition :GCTYPE.Spread.Sheets.TabStripPosition; // The position of tab strip. The default is bottom.
                newTabVisible :boolean ; // Whether the spreadsheet displays the special tab to let users insert new sheets.
                tabNavigationVisible :boolean ; // Whether to display the sheet tab navigation.
                cutCopyIndicatorVisible :boolean ; // Whether to display an indicator when copying or cutting the selected item.
                cutCopyIndicatorBorderColor :string; // The border color for the indicator displayed when the user cuts or copies the selection.
                backColor :string; // A color string used to represent the background color of the Spread component, such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.
                backgroundImage :string; // The background image of the Spread component.
                backgroundImageLayout :GCTYPE.Spread.Sheets.ImageLayout; // The background image layout for the Spread component.
                grayAreaBackColor :string; // A color string used to represent the background color of the gray area , such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.
                showResizeTip :GCTYPE.Spread.Sheets.ShowResizeTip; // How to display the resize tip.
                showDragDropTip :boolean ; // Whether to display the drag-drop tip.
                showDragFillTip :boolean ; // Whether to display the drag-fill tip.
                showScrollTip :GCTYPE.Spread.Sheets.ShowScrollTip; // How to display the scroll tip.
                scrollIgnoreHidden :boolean ; // Whether the scroll bar ignores hidden rows or columns.
                highlightInvalidData :boolean ; // Whether to highlight invalid data.
                useTouchLayout :boolean ; // Whether to use touch layout to present the Spread component.
                hideSelection :boolean ; // Whether to display the selection highlighting when the Spread component does not have focus.
                resizeZeroIndicator :GCTYPE.Spread.Sheets.ResizeZeroIndicator; // The drawing policy when the row or column is resized to zero.
                allowUserEditFormula :boolean ; // Whether the user can edit formulas in a cell in the spreadsheet.
                enableFormulaTextbox :boolean ; // Whether to enable the formula text box in the spreadsheet.
                autoFitType :GCTYPE.Spread.Sheets.AutoFitType; // Whether content will be formatted to fit in cells or in cells and headers.
                referenceStyle :GCTYPE.Spread.Sheets.ReferenceStyle; // The style for cell and range references in cell formulas on this sheet.
                allowDynamicArray :boolean ; //Whether to enable the dynamic array.
                iterativeCalculation: boolean; //Whether to enable the iterative calculation.
                iterativeCalculationMaximumIterations: number; //The Maximum Iterations when iterative calculation.
                iterativeCalculationMaximumChange: number; //The Maximum Change when iterative calculation.
                calcOnDemand :boolean; // Whether to calculate formulas only when they are demanded.
                allowCopyPasteExcelStyle :boolean ; //Whether the user can copy style from Spread Sheets then paste to Excel, or copy style from Excel then paste to Spread Sheets.
                allowExtendPasteRange :boolean ; //Whether extend paste range if the paste range is not enough for pasting.
                copyPasteHeaderOptions :GCTYPE.Spread.Sheets.CopyPasteHeaderOptions; // Which headers are included when data is copied to or pasted.
                scrollByPixel: boolean; // Whether to enable the precision scrolling by pixel.
                scrollPixel: number; // Decides scrolling by that number of pixels at a time when scrollByPixel is true. The final scrolling pixels are the result of scrolling delta multiply scrollPixel. For example, the scrolling delta is 3, and the scrollPixel is 5, the final scrolling pixels are 15.
                enableAccessibility: boolean; // Whether to enable the accessibility support in the spreadsheet.
                allowAutoCreateHyperlink: boolean; // Whether to enable auto creating hyperlink in the spreadsheet.
                columnResizeMode: GCTYPE.Spread.Sheets.ResizeMode; // Specifies the way to resize column.
                rowResizeMode: GCTYPE.Spread.Sheets.ResizeMode; // Specifies the way to resize row.
                customList?: string[][]; // The list for user to customize drag fill, prioritize matching this list in each fill. Each array item is type of string array.
                scrollbarAppearance?: GCTYPE.Spread.Sheets.ScrollbarAppearance; // The scrollbar appearance, contains skin and mobile two enums. Default is skin.
                pasteSkipInvisibleRange: boolean; // Whether paste skip invisible range. Default is false.
            }


            export interface IWorkFlowItem{
                value: string;
                transitions: number[]|string[];
            }


            export interface IWorkFlowOption{
                items:GCTYPE.Spread.Sheets.IWorkFlowItem[];
            }


            export interface IWorkSheetGridlineOption{
                color?: string; //The grid line color
                showVerticalGridline?: boolean; //Whether to show the vertical grid line.
                showHorizontalGridline?: boolean; //Whether to show the horizontal grid line.
            }


            export interface IWorksheetOptions{
                allowCellOverflow: boolean; //indicates whether data can overflow into adjacent empty cells.
                showFormulas: boolean; //indicates whether display the formulas string not the formula result..
                sheetTabColor: string; //A color string used to represent the sheet tab color, such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.
                frozenlineColor: string; //A color string used to represent the frozen line color, such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.
                clipBoardOptions: GCTYPE.Spread.Sheets.ClipboardPasteOptions; //The clipboard option.
                gridline: GCTYPE.Spread.Sheets.IWorkSheetGridlineOption; //The grid line's options.
                rowHeaderVisible: boolean; //Indicates whether the row header is visible.
                colHeaderVisible: boolean; //Indicates whether the column header is visible.
                rowHeaderAutoText: GCTYPE.Spread.Sheets.HeaderAutoText; //Indicates whether the row header displays letters or numbers or is blank.
                colHeaderAutoText: GCTYPE.Spread.Sheets.HeaderAutoText; //Indicates whether the column header displays letters or numbers or is blank.
                rowHeaderAutoTextIndex: GCTYPE.Spread.Sheets.HeaderAutoText; //Specifies which row header column displays the automatic text when there are multiple row header columns.
                colHeaderAutoTextIndex: GCTYPE.Spread.Sheets.HeaderAutoText; //Specifies which column header row displays the automatic text when there are multiple column header rows.
                isProtected: boolean; //Indicates whether cells on this sheet that are marked as protected cannot be edited.
                protectionOptions: GCTYPE.Spread.Sheets.IProtectionOptions; //A value that indicates the elements that you want users to be able to change.
                selectionBackColor: string; //The selection's background color for the sheet.
                selectionBorderColor: string; //The selection's border color for the sheet.
            }


            export interface IWorkSheetSheetAreaOffsetOption{
                left?: number; //The offset left of sheet from host.
                top?: number; //The offset top of sheet from host
            }


            export interface SheetTabInfo{
                sheetName?: string;
                sheetIndex?: number;
            }

            /**
             * Represents whether the component automatically resizes cells or headers.
             * @enum {number}
             * @example
             * //This example uses the AutoFitType enumeration.
             * spread.options.autoFitType = GCTYPE.Spread.Sheets.AutoFitType.cellWithHeader;
             */
            export enum AutoFitType{
                /**
                 *  The component autofits cells.
                 */
                cell= 0,
                /**
                 *   The component autofits cells and headers.
                 */
                cellWithHeader= 1
            }

            /**
             * Specifies the type of cellbutton.
             * @enum {number}
             * @example
             * //This example sets the type of cellbutton.
             * //create config
             * leftButtonConfig1 = {
             *     caption: "left",
             *     enabled: true,
             *     isLeft: true,
             *     imageType:GCTYPE.Spread.Sheets.ButtonImageType.left,
             * };
             * rightButtonConfig1 = {
             *     caption: "left",
             *     enabled: true,
             *     isLeft: false,
             *     imageType:GCTYPE.Spread.Sheets.ButtonImageType.right,
             * };
             * //create style
             * var style = new GCTYPE.Spread.Sheets.Style();
             * style.cellButtons=[
             *      leftButtonConfig1,
             *      rightButtonConfig1
             * ];
             * sheet.setStyle(0, 0, style);
             */
            export enum ButtonImageType{
                /** Indicates the cellbutton image type is none.
                 * @type {number}
                 */
                none= 0,
                /** Indicates the cellbutton type is custom.
                 * @type {number}
                 */
                custom= 1,
                /** Indicates the cellbutton type is clear.
                 * @type {number}
                 */
                clear= 2,
                /** Indicates the cellbutton type is cancel.
                 * @type {number}
                 */
                cancel= 3,
                /** Indicates the cellbutton type is ok.
                 * @type {number}
                 */
                ok= 4,
                /** Indicates the cellbutton type is dropdown.
                 * @type {number}
                 */
                dropdown= 5,
                /** Indicates the cellbutton type is ellipsis.
                 * @type {number}
                 */
                ellipsis= 6,
                /** Indicates the cellbutton type is left.
                 * @type {number}
                 */
                left= 7,
                /** Indicates the cellbutton type is right.
                 * @type {number}
                 */
                right= 8,
                /** Indicates the cellbutton type is plus.
                 * @type {number}
                 */
                plus= 9,
                /** Indicates the cellbutton type is minus.
                 * @type {number}
                 */
                minus= 10,
                /** Indicates the cellbutton type is undo.
                 * @type {number}
                 */
                undo= 11,
                /** Indicates the cellbutton type is redo.
                 * @type {number}
                 */
                redo= 12,
                /** Indicates the cellbutton type is search.
                 * @type {number}
                 */
                search= 13,
                /** Indicates the cellbutton type is separator.
                 * @type {number}
                 */
                separator= 14,
                /** Indicates the cellbutton type is spinLeft.
                 * @type {number}
                 */
                spinLeft= 15,
                /** Indicates the cellbutton type is spinRight.
                 * @type {number}
                 */
                spinRight= 16,
                /** Indicates the cellbutton type is collapse.
                 * @type {number}
                 */
                collapse= 17,
                /** Indicates the cellbutton type is expand.
                 * @type {number}
                 */
                expand= 18
            }

            /**
             * Specifies the position of cellbutton.
             * @enum {number}
             * @example
             * //This example sets the position of cellbutton.
             * //create config
             * leftButtonConfig1 = {
             *     caption: "left",
             *     enabled: true,
             *     position: GCTYPE.Spread.Sheets.ButtonPosition.right,
             *     visibility:GCTYPE.Spread.Sheets.ButtonVisibility.always,
             * };
             * rightButtonConfig1 = {
             *     caption: "left",
             *     enabled: true,
             *     position: GCTYPE.Spread.Sheets.ButtonPosition.left,
             *     visibility:GCTYPE.Spread.Sheets.ButtonVisibility.onSelected,
             * };
             * //create style
             * var style = new GCTYPE.Spread.Sheets.Style();
             * style.cellButtons=[
             *      leftButtonConfig1,
             *      rightButtonConfig1
             * ];
             * sheet.setStyle(0, 0, style);
             */
            export enum ButtonPosition{
                /** Indicates the cellbutton is in left of the cell.
                 * @type {number}
                 */
                left= 0,
                /** Indicates the cellbutton is in right of the cell.
                 * @type {number}
                 */
                right= 1
            }

            /**
             * Specifies the visibility of cellbutton.
             * @enum {number}
             * @example
             * //This example sets the visibility of cellbutton.
             * //create config
             * leftButtonConfig1 = {
             *     caption: "left",
             *     enabled: true,
             *     isLeft: true,
             *     visibility:GCTYPE.Spread.Sheets.ButtonVisibility.always,
             * };
             * rightButtonConfig1 = {
             *     caption: "left",
             *     enabled: true,
             *     isLeft: false,
             *     visibility:GCTYPE.Spread.Sheets.ButtonVisibility.onSelected,
             * };
             * //create style
             * var style = new GCTYPE.Spread.Sheets.Style();
             * style.cellButtons=[
             *      leftButtonConfig1,
             *      rightButtonConfig1
             * ];
             * sheet.setStyle(0, 0, style);
             */
            export enum ButtonVisibility{
                /** Indicates the cellbutton alway visible.
                 * @type {number}
                 */
                always= 0,
                /** Indicates the cellbutton visible when the cell is active.
                 * @type {number}
                 */
                onSelected= 1,
                /** Indicates the cellbutton visible when the cell enter edit.
                 * @type {number}
                 */
                onEditing= 2
            }

            /**
             * Specifies the calendar's default page.
             * @enum {number}
             */
            export enum CalendarPage{
                /**
                 * Specifies the calendar's default page is year.
                 */
                year= 1,
                /**
                 * Specifies the calendar's default page is month.
                 */
                month= 2,
                /**
                 * Specifies the calendar's default page is day.
                 */
                day= 3
            }

            /**
             * Specifies the calendar's start day.
             * @enum {number}
             */
            export enum CalendarStartDay{
                /**
                 * Specifies the calendar's start day is Monday.
                 */
                monday= 1,
                /**
                 * Specifies the calendar's start day is Tuesday.
                 */
                tuesday= 2,
                /**
                 * Specifies the calendar's start day is Wednesday.
                 */
                wednesday= 3,
                /**
                 * Specifies the calendar's start day is Thursday.
                 */
                thursday= 4,
                /**
                 * Specifies the calendar's start day is Friday.
                 */
                friday= 5,
                /**
                 * Specifies the calendar's start day is Saturday.
                 */
                saturday= 6,
                /**
                 * Specifies the calendar's start day is Sunday.
                 */
                sunday= 7
            }

            /**
             * Specifies the position of caption.
             * @enum {number}
             * @example
             * //This example sets the position of caption.
             * //create config
             * leftButtonConfig1 = {
             *     caption: "left",
             *     enabled: true,
             *     position: GCTYPE.Spread.Sheets.ButtonPosition.right,
             *     captionAlign:GCTYPE.Spread.Sheets.CaptionAlignment.right,
             * };
             * rightButtonConfig1 = {
             *     caption: "left",
             *     enabled: true,
             *     position: GCTYPE.Spread.Sheets.ButtonPosition.left,
             *     captionAlign:GCTYPE.Spread.Sheets.CaptionAlignment.left,
             * };
             * //create style
             * var style = new GCTYPE.Spread.Sheets.Style();
             * style.cellButtons=[
             *      leftButtonConfig1,
             *      rightButtonConfig1
             * ];
             * sheet.setStyle(0, 0, style);
             */
            export enum CaptionAlignment{
                /** Indicates the caption is in left of the button.
                 * @type {number}
                 */
                left= 0,
                /** Indicates the caption is in right of the button.
                 * @type {number}
                 */
                right= 1
            }

            /**
             * Specifies the type of CellState.
             * @enum {number}
             */
            export enum CellStatesType{
                /** When mouse hover on the cell , cell state include "hover" state.
                 * @type {number}
                 */
                hover= 1,
                /** When the data-validation conditional evaluate fail, cell state include "invalid" state.
                 * @type {number}
                 */
                invalid= 2,
                /** When the cell is locked in protect worksheet , cell state include "readonly" state.
                 * @type {number}
                 */
                readonly= 4,
                /** When the cell is editing, cell state include "edit" state.
                 * @type {number}
                 */
                edit= 8,
                /** When the cell is focus, cell state include "active" state.
                 * @type {number}
                 */
                active= 16,
                /** When the cell is in the selection range, cell state include "selected" state.
                 * @type {number}
                 */
                selected= 32,
                /** When cell value is changed, cell state include "dirty" state.
                 * @type {number}
                 */
                dirty= 64
            }

            /**
             * Specifies the type of clearing pending change.
             * @enum {number}
             */
            export enum ClearPendingChangeType{
                /**
                 * Clear dirty change.
                 */
                dirty= 1,
                /**
                 * Clear insert change.
                 */
                insert= 2,
                /**
                 * Clear deleted change.
                 */
                delete= 4
            }

            /**
             * Specifies what data is pasted from the Clipboard.
             * @enum {number}
             * @example
             * //This example uses the ClipboardPasteOptions enumeration.
             * activeSheet.options.clipBoardOptions = GCTYPE.Spread.Sheets.ClipboardPasteOptions.values;
             */
            export enum ClipboardPasteOptions{
                /**
                 * Pastes all data objects, including values, formatting, and formulas.
                 */
                all= 0,
                /**
                 * Pastes only values.
                 */
                values= 1,
                /**
                 * Pastes only formatting.
                 */
                formatting= 2,
                /**
                 * Pastes only formulas.
                 */
                formulas= 3,
                /**
                 * Pastes values and formatting.
                 */
                valuesAndFormatting= 4,
                /**
                 * Pastes formulas and formatting.
                 */
                formulasAndFormatting= 5
            }

            /**
             * Specifies which headers are included when data is copied to or pasted.
             * @enum {number}
             * @example
             * //This example allows you to copy and paste headers.
             * spread.options.copyPasteHeaderOptions = GCTYPE.Spread.Sheets.CopyPasteHeaderOptions.allHeaders;
             * activeSheet.setRowCount(2,GCTYPE.Spread.Sheets.SheetArea.colHeader);
             * activeSheet.setColumnCount(2,GCTYPE.Spread.Sheets.SheetArea.rowHeader);
             * activeSheet.setValue(0, 2,"Column",GCTYPE.Spread.Sheets.SheetArea.colHeader);
             * activeSheet.setValue(1, 0,"Row",GCTYPE.Spread.Sheets.SheetArea.rowHeader);
             */
            export enum CopyPasteHeaderOptions{
                /**
                 * Includes neither column nor row headers when data is copied; does not overwrite selected column or row headers when data is pasted.
                 */
                noHeaders= 0,
                /**
                 * Includes selected row headers when data is copied; overwrites selected row headers when data is pasted.
                 */
                rowHeaders= 1,
                /**
                 * Includes selected column headers when data is copied; overwrites selected column headers when data is pasted.
                 */
                columnHeaders= 2,
                /**
                 * Includes selected headers when data is copied; overwrites selected headers when data is pasted.
                 */
                allHeaders= 3
            }

            /**
             * Specifies the copy to option.
             * @enum {number}
             * @example
             * //This example uses the CopyToOption enumeration.
             * activeSheet.getCell(0,0).value("1");
             * activeSheet.copyTo(0,0,1,1,2,2,GCTYPE.Spread.Sheets.CopyToOptions.value);
             */
            export enum CopyToOptions{
                /**
                 * Indicates the type of data is pure data.
                 */
                value= 1,
                /**
                 * Indicates the type of data is a formula.
                 */
                formula= 2,
                /**
                 * Indicates the type of data is a comment.
                 */
                comment= 4,
                /**
                 * Indicates to copy a range group.
                 */
                outline= 8,
                /**
                 * Indicates the type of data is a sparkline.
                 */
                sparkline= 16,
                /**
                 * Indicates to copy a span.
                 */
                span= 32,
                /**
                 * Indicates the type of data is a style.
                 */
                style= 64,
                /**
                 * Indicates the type of data is a tag.
                 */
                tag= 128,
                /**
                 * Indicates the type of data is a binding path.
                 */
                bindingPath= 256,
                /**
                 * Indicates the type of data is a conditional format.
                 */
                conditionalFormat= 512,
                /**
                 * Indicates the type of data is a hyperlink.
                 */
                hyperlink= 1024,
                /**
                 * Indicates all types of data.
                 */
                all= 2047
            }

            /**
             * Specifies the cell value type of dropdown list result.
             * @enum {number}
             */
            export enum DropdownListValue{
                /**
                 * Use the string of list select result, use comma to split.
                 */
                string= 0,
                /**
                 * Specifies the sort will move the group containt with sort.
                 */
                array= 1
            }

            /**
             * Specifies the type of dropdown.
             * @enum {number}
             * @example
             * //This example sets the type of dropdown.
             * //create style
             * var style = new GCTYPE.Spread.Sheets.Style();
             * style.dropDowns=[
             *    {
             *      type:GCTYPE.Spread.Sheets.DropDownType.dateTimePicker,
             *      option: {
             *          showTime:false
             *      }
             *    }
             * ];
             * sheet.setStyle(0, 0, style);
             */
            export enum DropDownType{
                /** Indicates the type of dropdown is colorpicker.
                 * @type {number}
                 */
                colorPicker= 0,
                /** Indicates the type of dropdown is dateTimePicker.
                 * @type {number}
                 */
                dateTimePicker= 1,
                /** Indicates the type of dropdown is timePicker.
                 * @type {number}
                 */
                timePicker= 2,
                /** Indicates the type of dropdown is monthPicker.
                 * @type {number}
                 */
                monthPicker= 3,
                /** Indicates the type of dropdown is list.
                 * @type {number}
                 */
                list= 4,
                /** Indicates the type of dropdown is slider.
                 * @type {number}
                 */
                slider= 5,
                /** Indicates the type of dropdown is calculator.
                 * @type {number}
                 */
                calculator= 6,
                /** Indicates the type of dropdown is workflowList.
                 * @type {number}
                 */
                workflowList= 7,
                /** Indicates the type of dropdown is multiColumn.
                 * @type {number}
                 */
                multiColumn= 8
            }

            /**
             * Specifies the editor status.
             * @enum {number}
             */
            export enum EditorStatus{
                /**
                 * Cell is in Ready mode.
                 */
                ready= 0,
                /**
                 * Cell is in editing mode and can commit the input value and navigate to or select other cells when invoking navigation or selection actions.
                 */
                enter= 1,
                /**
                 * Cell is in editing mode and cannot commit the input value and navigate to or select other cells.
                 */
                edit= 2
            }

            /**
             * Specifies the method when sort with group.
             * @enum {number}
             */
            export enum GroupSort{
                /**
                 * Specifies the sort don't move the group.
                 */
                none= 0,
                /**
                 * Specifies the sort will move the group containt with sort.
                 */
                group= 1,
                /**
                 * Specifies that only sort inner the group.
                 */
                child= 2,
                /**
                 * Specifies that sort will do with the group and inner the group.
                 */
                full= 3
            }

            /**
             * Specifies which default labels are displayed in headers.
             * @enum {number}
             */
            export enum HeaderAutoText{
                /**
                 *  Displays blanks in the headers.
                 */
                blank= 0,
                /**
                 *  Displays numbers in the headers.
                 */
                numbers= 1,
                /**
                 *  Displays letters in the headers.
                 */
                letters= 2
            }

            /**
             * Specifies which headers are included when export range data to HTML.
             * @enum {number}
             * @example
             * //This example shows you how to export range data to HTML with row header and column header.
             * activeSheet.getRange(-1, -1, -1, -1).toHtml(GCTYPE.Spread.Sheets.HeaderOptions.allHeaders);
             */
            export enum HeaderOptions{
                /**
                 * Includes neither column nor row headers when export range data to HTML.
                 */
                noHeaders= 0,
                /**
                 * Includes selected row headers when export range data to HTML.
                 */
                rowHeaders= 1,
                /**
                 * Includes selected column headers when export range data to HTML.
                 */
                columnHeaders= 2,
                /**
                 * Includes selected headers when export range data to HTML.
                 */
                allHeaders= 3
            }

            /**
             * Specifies the horizontal alignment.
             * @enum {number}
             * @example
             * //This example uses the HorizontalAlign type.
             * var style = new GCTYPE.Spread.Sheets.Style();
             * style.font = "8pt Arial";
             * style.hAlign = GCTYPE.Spread.Sheets.HorizontalAlign.center;
             * style.vAlign = GCTYPE.Spread.Sheets.VerticalAlign.center;
             * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
             * activeSheet.getCell(1,1).value("B2");
             */
            export enum HorizontalAlign{
                /**
                 *  Indicates that the cell content is left-aligned.
                 */
                left= 0,
                /**
                 *  Indicates that the cell content is centered.
                 */
                center= 1,
                /**
                 *  Indicates that the cell content is right-aligned.
                 */
                right= 2,
                /**
                 *  Indicates that the horizontal alignment is based on the value type.
                 */
                general= 3
            }

            /**
             * Specifies the horizontal position of the cell or column in the component.
             * @enum {number}
             * @example
             * //This example uses the HorizontalPosition enumeration.
             * activeSheet.setActiveCell(10,5);
             * activeSheet.showCell(10, 5, GCTYPE.Spread.Sheets.VerticalPosition.top, GCTYPE.Spread.Sheets.HorizontalPosition.center);
             */
            export enum HorizontalPosition{
                /**
                 *  Positions the cell or column to the left.
                 */
                left= 0,
                /**
                 *  Positions the cell or column in the center.
                 */
                center= 1,
                /**
                 *  Positions the cell or column to the right.
                 */
                right= 2,
                /**
                 *  Positions the cell or column to the nearest edge.
                 */
                nearest= 3
            }

            /**
             * Present the way that user open the hyperlinked document. Default is blank.
             * @enum {number}
             */
            export enum HyperlinkTargetType{
                /**
                 * Opens the hyperlinked document in a new window or tab.
                 */
                blank= 0,
                /**
                 * Opens the hyperlinked document in the same frame where the user clicked.
                 */
                self= 1,
                /**
                 * Opens the hyperlinked document in the parent frame.
                 */
                parent= 2,
                /**
                 * Opens the hyperlinked document in the full body of the window.
                 */
                top= 3
            }

            /**
             * Defines the background image layout.
             * @enum {number}
             * @example
             * var rowImage = "./css/images/quarter1.png";
             * sheet.getCell(1, -1).backgroundImage(rowImage);
             * sheet.getCell(1, -1).backgroundImageLayout(GCTYPE.Spread.Sheets.ImageLayout.center);
             */
            export enum ImageLayout{
                /** Specifies that the background image fills the area.
                 * @type {number}
                 */
                stretch= 0,
                /** Specifies that the background image displays in the center of the area.
                 * @type {number}
                 */
                center= 1,
                /** Specifies that the background image displays in the area with its original aspect ratio.
                 * @type {number}
                 */
                zoom= 2,
                /** Specifies that the background image displays in the upper left corner of the area with its original size.
                 * @type {number}
                 */
                none= 3
            }

            /**
             * Defines the IME mode to control the state of the Input Method Editor (IME).
             * @enum {number}
             * @example
             * //This example uses the imeMode method.
             * activeSheet.getRange(-1, 2, -1, 1).imeMode(GCTYPE.Spread.Sheets.ImeMode.auto);
             */
            export enum ImeMode{
                /**
                 * No change is made to the current input method editor state.
                 */
                auto= 1,
                /** All characters are entered through the IME. Users can still deactivate the IME.
                 */
                active= 2,
                /**
                 * All characters are entered without IME. Users can still activate the IME.
                 */
                inactive= 4,
                /**
                 * The input method editor is disabled and may not be activated by the user.
                 */
                disabled= 0
            }

            /**
             * Specifies paste the direction of the insertion finger.
             * @enum {number}
             */
            export enum InsertShiftCell{
                /** Specifies paste the direction right.
                 * @type {number}
                 */
                right= 0,
                /** Specifies paste the direction down.
                 * @type {number}
                 */
                down= 1
            }

            /**
             * Identifies which operation was invalid.
             * @enum {number}
             * @example
             * //This example gets the invalid type.
             * activeSheet.getCell(1,1).locked(true);
             * activeSheet.options.isProtected = true;
             * activeSheet.getCell(1,1).value(2);
             * //Bind event
             * activeSheet.bind(GCTYPE.Spread.Sheets.Events.InvalidOperation, function (e, info) {
             *         alert("Message (" + info.invalidType + ")");
             * });
             */
            export enum InvalidOperationType{
                /**
                 * Specifies the formula is invalid.
                 */
                setFormula= 0,
                /**
                 * Specifies the copy paste is invalid.
                 */
                copyPaste= 1,
                /**
                 * Specifies the drag fill is invalid.
                 */
                dragFill= 2,
                /**
                 * Specifies the drag drop is invalid.
                 */
                dragDrop= 3,
                /**
                 * Specifies the insert row is invalid.
                 */
                changePartOfArrayFormula= 4,
                /**
                 * Specifies the changed sheet name is invalid.
                 */
                changeSheetName= 5,
                /**
                 * Specifies the add filter is invalid.
                 */
                filter= 7,
                /**
                 * Specifies the change affect existed pivot table.
                 */
                pivotTable= 10,
                /**
                 * Specifies the pivotTable change will overlap the valued cell.
                 */
                ptOverlapValue= 11,
                /**
                 * Specifies the group can expand and collapse when sheet is unprotected.
                 */
                groupProtected= 12
            }

            /**
             * Specifies the cell label position.
             * @enum {number}
             * @example
             * //This example sets cell padding, alignment, and other options.
             * var type = new GCTYPE.Spread.Sheets.Style();
             * type.watermark = "User name";
             * type.cellPadding = "20";
             * type.labelOptions = {alignment:GCTYPE.Spread.Sheets.LabelAlignment.topLeft, visibility: GCTYPE.Spread.Sheets.LabelVisibility.visible};
             * activeSheet.setStyle(0, 1, type);
             * activeSheet.getRange(0, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).height(60);
             * activeSheet.getRange(-1, 1, -1, 1).width(150);
             * var combo = new GCTYPE.Spread.Sheets.CellTypes.ComboBox();
             * combo.items([{ text: "Oranges", value: "11k" }, { text: "Apples", value: "15k" }, { text: "Grape", value: "100k" }]);
             * combo.editorValueType(GCTYPE.Spread.Sheets.CellTypes.EditorValueType.text);
             * activeSheet.setCellType(2, 1, combo, GCTYPE.Spread.Sheets.SheetArea.viewport);
             * activeSheet.getCell(2, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).watermark("ComboBox Cell Type").cellPadding('10 10 20 10');
             * activeSheet.getCell(2, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).labelOptions({alignment: GCTYPE.Spread.Sheets.LabelAlignment.bottomCenter, foreColor: 'yellowgreen', font: 'bold 15px Arial'});
             * activeSheet.getRange(2, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).height(60);
             */
            export enum LabelAlignment{
                /**
                 *  Indicates that the cell label position is top-left.
                 */
                topLeft= 0,
                /**
                 *  Indicates that the cell label position is top-center.
                 */
                topCenter= 1,
                /**
                 *  Indicates that the cell label position is top-right.
                 */
                topRight= 2,
                /**
                 *  Indicates that the cell label position is bottom-left.
                 */
                bottomLeft= 3,
                /**
                 *  Indicates that the cell label position is bottom-center.
                 */
                bottomCenter= 4,
                /**
                 *  Indicates that the cell label position is bottom-right.
                 */
                bottomRight= 5
            }

            /**
             * Specifies the cell label visibility.
             * @enum {number}
             * @example
             * //This example sets label options for the watermark.
             * var type = new GCTYPE.Spread.Sheets.Style();
             * type.watermark = "User name";
             * type.cellPadding = "20";
             * type.labelOptions = {alignment:GCTYPE.Spread.Sheets.LabelAlignment.topLeft, visibility: GCTYPE.Spread.Sheets.LabelVisibility.visible};
             * activeSheet.setStyle(0, 1, type);
             * activeSheet.getRange(0, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).height(60);
             * activeSheet.getRange(-1, 1, -1, 1).width(150);
             * var combo = new GCTYPE.Spread.Sheets.CellTypes.ComboBox();
             * combo.items([{ text: "Oranges", value: "11k" }, { text: "Apples", value: "15k" }, { text: "Grape", value: "100k" }]);
             * combo.editorValueType(GCTYPE.Spread.Sheets.CellTypes.EditorValueType.text);
             * activeSheet.setCellType(2, 1, combo, GCTYPE.Spread.Sheets.SheetArea.viewport);
             * activeSheet.getCell(2, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).watermark("ComboBox Cell Type").cellPadding('10 10 20 10');
             * activeSheet.getCell(2, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).labelOptions({alignment: GCTYPE.Spread.Sheets.LabelAlignment.bottomCenter, foreColor: 'yellowgreen', font: 'bold 15px Arial'});
             * activeSheet.getRange(2, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).height(60);
             */
            export enum LabelVisibility{
                /**
                 *  Specifies to always show the watermark in the padding area and not to show the watermark in the cell area, regardless of the cell value.
                 */
                visible= 0,
                /**
                 *  Specifies to not show the watermark in the padding area, but to show the watermark in the cell area based on a value condition.
                 */
                hidden= 1,
                /**
                 *  Specifies to show the watermark in the padding area when the cell has a value or to show the watermark in the cell area if the cell does not have a value.
                 */
                auto= 2
            }

            /**
             * Specifies the layout direction.
             * @enum {number}
             */
            export enum LayoutDirection{
                /**
                 * Specifies layout direction is horizontal.
                 */
                horizontal= 0,
                /**
                 * Specifies layout direction is vertical.
                 */
                vertical= 1
            }

            /**
             * Specifies the layout display.
             * @enum {number}
             */
            export enum LayoutDisplayAs{
                /**
                 * Specifies layout display is inline.
                 */
                inline= 0,
                /**
                 * Specifies layout display is popup
                 */
                popup= 1,
                /**
                 * Specifies layout display is tree
                 */
                tree= 2
            }

            /**
             * Specifies the line drawing style for the border.
             * @enum {number}
             * @example
             * //This example creates a border.
             * var border = new GCTYPE.Spread.Sheets.LineBorder
             * border.color = "#7FFFD4";
             * border.style = GCTYPE.Spread.Sheets.LineStyle.double;
             * var cell = activeSheet.getCell(1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport);
             * cell.borderLeft(border);
             */
            export enum LineStyle{
                /**
                 * Indicates a border line without a style.
                 */
                empty= 0,
                /**
                 *  Indicates a border line with a solid thin line.
                 */
                thin= 1,
                /**
                 *  Indicates a medium border line with a solid line.
                 */
                medium= 2,
                /**
                 *  Indicates a border line with dashes.
                 */
                dashed= 3,
                /**
                 *  Indicates a border line with dots.
                 */
                dotted= 4,
                /**
                 *  Indicates a thick border line with a solid line.
                 */
                thick= 5,
                /**
                 *  Indicates a double border line.
                 */
                double= 6,
                /**
                 *  Indicates a border line with all dots.
                 */
                hair= 7,
                /**
                 *  Indicates a medium border line with dashes.
                 */
                mediumDashed= 8,
                /**
                 *  Indicates a border line with dash-dot.
                 */
                dashDot= 9,
                /**
                 *  Indicates a medium border line with dash-dot-dot.
                 */
                mediumDashDot= 10,
                /**
                 *  Indicates a border line with dash-dot-dot.
                 */
                dashDotDot= 11,
                /**
                 *  Indicates a medium border line with dash-dot-dot.
                 */
                mediumDashDotDot= 12,
                /**
                 *  Indicates a slanted border line with dash-dot.
                 */
                slantedDashDot= 13
            }

            /**
             * Change display mode when date/number data width longer than column width.
             * @enum {number}
             * @example
             * //This example uses the NumbersFitMode enumeration.
             * spread.options.numbersFitMode = GCTYPE.Spread.Sheets.NumbersFitMode.overflow;
             */
            export enum NumbersFitMode{
                /** Indicates replacing data content with "###" and show tip.
                 * @type {number}
                 */
                mask= 0,
                /** Indicates display data content as a string, if next cell is empty, overflow the content.
                 * @type {number}
                 */
                overflow= 1
            }

            /**
             * Specifies the cell value type of dropdown list result.
             * @enum {number}
             */
            export enum PatternType{
                /**
                 * Specifies the pattern type is solid.
                 */
                solid= 1,
                /**
                 * Specifies the pattern type is darkGray.
                 */
                darkGray= 2,
                /**
                 * Specifies the pattern type is mediumGray.
                 */
                mediumGray= 3,
                /**
                 * Specifies the pattern type is lightGray.
                 */
                lightGray= 4,
                /**
                 * Specifies the pattern type is gray125.
                 */
                gray125= 5,
                /**
                 * Specifies the pattern type is gray0625.
                 */
                gray0625= 6,
                /**
                 * Specifies the pattern type is darkHorizontal.
                 */
                darkHorizontal= 7,
                /**
                 * Specifies the pattern type is darkVertical.
                 */
                darkVertical= 8,
                /**
                 * Specifies the pattern type is darkDown.
                 */
                darkDown= 9,
                /**
                 * Specifies the pattern type is darkUp.
                 */
                darkUp= 10,
                /**
                 * Specifies the pattern type is darkGrid.
                 */
                darkGrid= 11,
                /**
                 * Specifies the pattern type is darkTrellis.
                 */
                darkTrellis= 12,
                /**
                 * Specifies the pattern type is lightHorizontal.
                 */
                lightHorizontal= 13,
                /**
                 * Specifies the pattern type is lightVertical.
                 */
                lightVertical= 14,
                /**
                 * Specifies the pattern type is lightDown.
                 */
                lightDown= 15,
                /**
                 * Specifies the pattern type is lightUp.
                 */
                lightUp= 16,
                /**
                 * Specifies the pattern type is lightGrid.
                 */
                lightGrid= 17,
                /**
                 * Specifies the pattern type is lightTrellis.
                 */
                lightTrellis= 18
            }

            /**
             * Defines the type of action that raised the RangeChanged event.
             * @enum {number}
             */
            export enum RangeChangedAction{
                /**
                 * Indicates drag drop undo action.
                 */
                dragDrop= 0,
                /**
                 * Indicates drag fill undo action.
                 */
                dragFill= 1,
                /**
                 * Indicates clear range value undo action.
                 */
                clear= 2,
                /**
                 * Indicates paste undo action.
                 */
                paste= 3,
                /**
                 * Indicates sorting a range of cells.
                 */
                sort= 4,
                /**
                 * Indicates setting a formula in a specified range of cells .
                 */
                setArrayFormula= 5,
                /**
                 * Indicates setting a formula in a specified range of cells .
                 */
                evaluateFormula= 6
            }

            /**
             * Specifies the formula reference style.
             * @enum {number}
             * @example
             * //This example sets the reference style for the active sheet.
             * activeSheet.options.referenceStyle = GCTYPE.Spread.Sheets.ReferenceStyle.r1c1;
             */
            export enum ReferenceStyle{
                /**
                 * Indicates a1 style.
                 */
                a1= 0,
                /**
                 * Indicates r1c1 style.
                 */
                r1c1= 1
            }

            /**
             * Specifies the way resizing use.
             * @enum {number}
             * @example
             * //This example shows you how to specify the resize way.
             * spread.options.columnResizeMode = GCTYPE.Spread.Sheets.ResizeMode.split;
             * spread.options.rowResizeMode = GCTYPE.Spread.Sheets.ResizeMode.normal;
             */
            export enum ResizeMode{
                /** Specifies use normal way to resize.
                 * @type {number}
                 */
                normal= 0,
                /** Specifies use split way to resize.
                 * @type {number}
                 */
                split= 1
            }

            /**
             * Specifies the drawing policy of the row or column when it is resized to zero.
             * @enum {number}
             * @example
             * //This example displays double grid lines for the column or row with zero width or height.
             * spread.options.resizeZeroIndicator = GCTYPE.Spread.Sheets.ResizeZeroIndicator.enhanced;
             * activeSheet.getRange(-1, 2, -1, 1).width(0);
             * activeSheet.getRange(1, -1, 1, -1).height(0);
             */
            export enum ResizeZeroIndicator{
                /**
                 *  Uses the current drawing policy when the row or column is resized to zero.
                 */
                default= 0,
                /**
                 * Draws two short lines when the row or column is resized to zero.
                 */
                enhanced= 1
            }

            /**
             * Specifies the appearance of both vertical and horizontal scrollbar.
             * @enum {number}
             * @example
             * //This example displays a mobile scrollbar mode.
             * spread.options.scrollbarAppearance = GCTYPE.Spread.Sheets.ScrollbarAppearance.mobile;
             */
            export enum ScrollbarAppearance{
                /** Specifies the excel-like classic scrollbars appearance.
                 * @type {number}
                 */
                skin= 0,
                /** Specifies the fashionable mobile scrollbars appearance which could be customized.
                 * @type {number}
                 */
                mobile= 1
            }

            /**
             * Specifies how users can select items in the control.
             * @enum {number}
             * @example
             * //This example sets the selection policy.
             * activeSheet.selectionUnit(GCTYPE.Spread.Sheets.SelectionUnit.row);
             * activeSheet.selectionPolicy(GCTYPE.Spread.Sheets.SelectionPolicy.range);
             */
            export enum SelectionPolicy{
                /**
                 * Allows users to only select single items.
                 */
                single= 0,
                /**
                 * Allows users to select single items and ranges of items, but not multiple ranges.
                 */
                range= 1,
                /**
                 * Allows users to select single items and ranges of items, including multiple ranges.
                 */
                multiRange= 2
            }

            /**
             * Specifies the smallest unit users or the application can select.
             * @enum {number}
             * @example
             * //This example sets the unit type.
             * activeSheet.selectionUnit(GCTYPE.Spread.Sheets.SelectionUnit.row);
             * activeSheet.selectionPolicy(GCTYPE.Spread.Sheets.SelectionPolicy.range);
             */
            export enum SelectionUnit{
                /**
                 * Indicates that the smallest unit that can be selected is a cell.
                 */
                cell= 0,
                /**
                 * Indicates that the smallest unit that can be selected is a row.
                 */
                row= 1,
                /**
                 * Indicates that the smallest unit that can be selected is a column.
                 */
                column= 2
            }

            /**
             * Specifies the sheet area.
             * @enum {number}
             * @example
             * //Creates log text describing which area in the sheet was clicked.
             * // Use IE to see the console log text
             * activeSheet.bind(GCTYPE.Spread.Sheets.Events.CellClick, function (sender, args) {
             *     if(args.sheetArea === GCTYPE.Spread.Sheets.SheetArea.colHeader){
             *         console.log("The column header was clicked.");
             *     }
             *     if(args.sheetArea === GCTYPE.Spread.Sheets.SheetArea.rowHeader){
             *         console.log("The row header was clicked.");
             *     }
             *     if(args.sheetArea === GCTYPE.Spread.Sheets.SheetArea.corner){
             *         console.log("The corner header was clicked.");
             *     }
             *     console.log("Clicked column index: " + args.col);
             *     console.log("Clicked row index: " + args.row);
             * });
             * //Bind event
             * activeSheet.bind(GCTYPE.Spread.Sheets.Events.CellDoubleClick, function (sender, args) {
             *     if(args.sheetArea === GCTYPE.Spread.Sheets.SheetArea.colHeader){
             *         console.log("The column header was double clicked.");
             *     }
             *     if(args.sheetArea === GCTYPE.Spread.Sheets.SheetArea.rowHeader){
             *         console.log("The row header was double clicked.");
             *     }
             *     if(args.sheetArea === GCTYPE.Spread.Sheets.SheetArea.corner){
             *         console.log("The corner header was double clicked.");
             *     }
             *     console.log("Double clicked column index: " + args.col);
             *     console.log("Double clicked row index: " + args.row);
             * });
             */
            export enum SheetArea{
                /**
                 * Indicates the sheet corner.
                 */
                corner= 0,
                /**
                 * Indicates the column header.
                 */
                colHeader= 1,
                /**
                 * Indicates the row header.
                 */
                rowHeader= 2,
                /**
                 * Indicates the viewport.
                 */
                viewport= 3
            }

            /**
             * Present the type of sheet tab.
             * @enum {number}
             */
            export enum SheetType{
                /**
                 * Specifies the sheet tab is table sheet.
                 */
                tableSheet= 0
            }

            /**
             * Defines how the resize tip is displayed.
             * @enum {number}
             * @example
             * //This example displays both resize tips.
             * spread.options.showDragDropTip = true;
             * spread.options.showDragFillTip = true;
             * spread.options.showScrollTip = GCTYPE.Spread.Sheets.ShowScrollTip.both;
             * spread.options.showResizeTip = GCTYPE.Spread.Sheets.ShowResizeTip.both;
             */
            export enum ShowResizeTip{
                /** Specifies that no resize tip is displayed.
                 * @type {number}
                 */
                none= 0,
                /** Specifies that only the horizontal resize tip is displayed.
                 * @type {number}
                 */
                column= 1,
                /** Specifies that only the vertical resize tip is displayed.
                 * @type {number}
                 */
                row= 2,
                /** Specifies that horizontal and vertical resize tips are displayed.
                 * @type {number}
                 */
                both= 3
            }

            /**
             * Specifies how the scroll tip is displayed.
             * @enum {number}
             * @example
             * //This example displays both resize tips.
             * spread.options.showDragDropTip = true;
             * spread.options.showDragFillTip = true;
             * spread.options.showScrollTip = GCTYPE.Spread.Sheets.ShowScrollTip.both;
             * spread.options.showResizeTip = GCTYPE.Spread.Sheets.ShowResizeTip.both;
             */
            export enum ShowScrollTip{
                /** Specifies that no scroll tip is displayed.
                 * @type {number}
                 */
                none= 0,
                /** Specifies that only the horizontal scroll tip is displayed.
                 * @type {number}
                 */
                horizontal= 1,
                /** Specifies that only the vertical scroll tip is displayed.
                 * @type {number}
                 */
                vertical= 2,
                /** Specifies that horizontal and vertical scroll tips are displayed.
                 * @type {number}
                 */
                both= 3
            }

            /**
             * Specifies the type of sorting to perform.
             * @enum {number}
             * @example
             * //This example sets the sort order of the items in the slicer.
             * //create a table
             * datas = [
             *     ["1", "NewYork", "1968/6/8", "80", "180"],
             *     ["4", "NewYork", "1972/7/3", "72", "168"],
             *     ["4", "NewYork", "1964/3/2", "71", "179"],
             *     ["5", "Washington", "1972/8/8","80", "171"],
             *     ["6", "Washington", "1986/2/2", "89", "161"],
             *     ["7", "Washington", "2012/2/15", "71", "240"]];
             * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
             * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
             * table.setColumnName(0, dataColumns[0]);
             * table.setColumnName(1, dataColumns[1]);
             * table.setColumnName(2, dataColumns[2]);
             * table.setColumnName(3, dataColumns[3]);
             * table.setColumnName(4, dataColumns[4]);
             * //create style
             * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.light4();
             * //add a slicer to the sheet and return the slicer instance
             * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Height");
             * //set slicer properties
             * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
             * slicer.sortState(GCTYPE.Spread.Sheets.SortState.descending);
             * slicer.style(style1);
             */
            export enum SortState{
                /** Indicates the sorting is disabled.
                 * @type {number}
                 */
                none= 0,
                /** Indicates the sorting is ascending.
                 * @type {number}
                 */
                ascending= 1,
                /** Indicates the sorting is descending.
                 * @type {number}
                 */
                descending= 2
            }

            /**
             * Specifies the type of row and column state.
             * @enum {number}
             */
            export enum StatesType{
                /** When mouse hover on the row and the column , its state include "hover" state.
                 * @type {number}
                 */
                hover= 1,
                /** When the data-validation conditional evaluate fail, its row and column state include "invalid" state. This state doesn't support for worksheet.
                 * @type {number}
                 */
                invalid= 2,
                /** When the row or the column is locked in protect worksheet or tablesheet, its state include "readonly" state. This row state doesn't support for tablesheet.
                 * @type {number}
                 */
                readonly= 4,
                /** When the cell is editing, the cell row and column state include "edit" state. This state doesn't support for tablesheet.
                 * @type {number}
                 */
                edit= 8,
                /** When the row or the column is focus, its state include "active" state.
                 * @type {number}
                 */
                active= 16,
                /** When the cell is in the selection range, the cell row and column state include "selected" state.
                 * @type {number}
                 */
                selected= 32,
                /** When cell value is changed, cell row and column state include "dirty" state. This column state doesn't support for tablesheet.
                 * @type {number}
                 */
                dirty= 64,
                /** When inserted a row, its state include "inserted" state. This state only support for row.
                 * @type {number}
                 */
                inserted= 128,
                /** When updated a row, its state include "updated" state. This state only support for row.
                 * @type {number}
                 */
                updated= 256
            }

            /**
             * Represents the storage data type.
             * @enum {number}
             * @example
             * //This example uses the StorageType enumeration.
             * activeSheet.getCell(0,0).value("A1");
             * activeSheet.clear(0,0,3,3,GCTYPE.Spread.Sheets.SheetArea.viewport,GCTYPE.Spread.Sheets.StorageType.data);
             */
            export enum StorageType{
                /**
                 *  Indicates the storage data type is pure value.
                 */
                data= 1,
                /**
                 *  Indicates the storage data type is style.
                 */
                style= 2,
                /**
                 *  Indicates the storage data type is comment.
                 */
                comment= 4,
                /**
                 *  Indicates the storage data type is tag.
                 */
                tag= 8,
                /**
                 *  Indicates the storage data type is sparkline.
                 */
                sparkline= 16,
                /**
                 *  Indicates the storage data type is the axis information.
                 */
                axis= 32,
                /**
                 *  Indicates the storage data type is data binding path.
                 */
                bindingPath= 64,
                /**
                 *  Indicates the storage data type is hyperlink.
                 */
                hyperlink= 256
            }

            /**
             * Specifies the position of the tab strip relative to the workbook.
             * @enum {number}
             */
            export enum TabStripPosition{
                /**
                 * Specifies the position of the tab strip relative to the bottom of the workbook.
                 */
                bottom= 0,
                /**
                 * Specifies the position of the tab strip relative to the top of the workbook.
                 */
                top= 1,
                /**
                 * Specifies the position of the tab strip relative to the left of the workbook.
                 */
                left= 2,
                /**
                 * Specifies the position of the tab strip relative to the right of the workbook.
                 */
                right= 3
            }

            /**
             * Defines the type of the text decoration.
             * @enum {number}
             * @example
             * //This example uses the TextDecorationType enumeration.
             * activeSheet.getCell(0, 0).textDecoration(GCTYPE.Spread.Sheets.TextDecorationType.underline);
             * activeSheet.getRange(1, -1, 1, -1).textDecoration(GCTYPE.Spread.Sheets.TextDecorationType.overline | GCTYPE.Spread.Sheets.TextDecorationType.underline);
             * activeSheet.getRange(-1, 1, -1, 1).textDecoration(GCTYPE.Spread.Sheets.TextDecorationType.overline | GCTYPE.Spread.Sheets.TextDecorationType.lineThrough | GCTYPE.Spread.Sheets.TextDecorationType.underline);
             * var style = new GCTYPE.Spread.Sheets.Style();
             * style.textDecoration = GCTYPE.Spread.Sheets.TextDecorationType.overline | GCTYPE.Spread.Sheets.TextDecorationType.underline;
             * activeSheet.setStyle(1, 1, style, GCTYPE.Spread.Sheets.SheetArea.viewport);
             * activeSheet.getCell(0, 0).value("Test");
             * activeSheet.getCell(1, 0).value("Test");
             * activeSheet.getCell(0, 1).value("Test");
             */
            export enum TextDecorationType{
                /** Specifies to display a line below the text.
                 */
                underline= 1,
                /** Specifies to display a line through the text.
                 */
                lineThrough= 2,
                /** Specifies to display a line above the text.
                 */
                overline= 4,
                /** Specifies to display double line below the text.
                 */
                doubleUnderline= 8,
                /** Specifies normal text.
                 */
                none= 0
            }

            /**
             * Specifies cell value's type.
             * @enum {number}
             */
            export enum ValueType{
                /**
                 *  indicate normal value type.
                 */
                normal= 0,
                /**
                 *  indicate rich text value type.
                 */
                richText= 1
            }

            /**
             * Defines the type of the text vertAlign.
             * @enum {number}
             * @example
             * //This example uses the VertAlign enumeration.
             * activeSheet.setValue(1, 1, {richText:[{style:{vertAlign:GCTYPE.Spread.Sheets.Style.VertAlign.subscript},text:'SpreadJS'}]}, GCTYPE.Spread.Sheets.SheetArea.viewport);
             */
            export enum VertAlign{
                /**
                 *  indicate normal text align.
                 */
                normal= 0,
                /**
                 *  indicate superscript.
                 */
                superscript= 1,
                /**
                 *  indicate subscript.
                 */
                subscript= 2
            }

            /**
             * Specifies the vertical alignment.
             * @enum {number}
             * @example
             * //This example uses the VerticalAlign type.
             * var style = new GCTYPE.Spread.Sheets.Style();
             * style.font = "8pt Arial";
             * style.hAlign = GCTYPE.Spread.Sheets.HorizontalAlign.center;
             * style.vAlign = GCTYPE.Spread.Sheets.VerticalAlign.center;
             * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
             * activeSheet.getCell(1,1).value("B2");
             */
            export enum VerticalAlign{
                /**
                 *  Indicates that the cell content is top-aligned.
                 */
                top= 0,
                /**
                 *  Indicates that the cell content is centered.
                 */
                center= 1,
                /**
                 *  Indicates that the cell content is bottom-aligned.
                 */
                bottom= 2
            }

            /**
             * Specifies the vertical position of the cell or row in the component.
             * @enum {number}
             * @example
             * //This example uses the VerticalPosition enumeration.
             * activeSheet.setActiveCell(10,5);
             * activeSheet.showCell(10, 5, GCTYPE.Spread.Sheets.VerticalPosition.top, GCTYPE.Spread.Sheets.HorizontalPosition.center);
             */
            export enum VerticalPosition{
                /**
                 *  Positions the cell or row at the top.
                 */
                top= 0,
                /**
                 *  Positions the cell or row in the center.
                 */
                center= 1,
                /**
                 *  Positions the cell or row at the bottom.
                 */
                bottom= 2,
                /**
                 *  Positions the cell or row at the nearest edge.
                 */
                nearest= 3
            }

            /**
             * Specifies the visual state.
             * @enum {number}
             */
            export enum VisualState{
                /**
                 * Indicates normal visual state.
                 */
                normal= 0,
                /**
                 * Indicates highlight visual state.
                 */
                highlight= 1,
                /**
                 * Indicates selected visual state.
                 */
                selected= 2,
                /**
                 * Indicates active visual state.
                 */
                active= 3,
                /**
                 * Indicates hover visual state.
                 */
                hover= 4
            }


            export class CellRange{
                /**
                 * Represents a cell range in a sheet.
                 * @class
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that contains this cell range.
                 * @param {number} row The row index of the cell.
                 * @param {number} col The column index of the cell.
                 * @param {number} [rowCount] The row count of the cell. If you do not provide this parameter, it defaults to <b>1</b>.
                 * @param {number} [colCount] The column count of the cell. If you do not provide this parameter, it defaults to <b>1</b>.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If you do not provide this parameter, it defaults to <b>viewport</b>.
                 * If row is -1 and rowCount is -1, the range represents columns. For example, new GCTYPE.Spread.Sheets.CellRange(-1,4,-1,6) represents columns "E:J".
                 * If col is -1 and colCount is -1, the range represents rows. For example, new GCTYPE.Spread.Sheets.CellRange(4,-1,6,-1) represents rows "5:10".
                 */
                constructor(sheet: GCTYPE.Spread.Sheets.Worksheet,  row: number,  col: number,  rowCount?: number,  colCount?: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea);
                /**
                 * Gets the starting column index.
                 * @type {number}
                 */
                col: number;
                /**
                 * Gets the column count.
                 * @type {number}
                 */
                colCount: number;
                /**
                 * Gets the starting row index.
                 *@type {number}
                 */
                row: number;
                /**
                 * Gets the row count.
                 * @type {number}
                 */
                rowCount: number;
                /**
                 * Gets the sheet that contains this cell range.
                 * @type {GCTYPE.Spread.Sheets.Worksheet}
                 */
                sheet: GCTYPE.Spread.Sheets.Worksheet;
                /**
                 * Gets the area that contains this cell range.
                 * @type {GCTYPE.Spread.Sheets.SheetArea}
                 */
                sheetArea: GCTYPE.Spread.Sheets.SheetArea;
                /**
                 * Gets or sets the background color for the cell, such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.
                 * @param {string|undefined|GCTYPE.Spread.Sheets.IPatternFill|GCTYPE.Spread.Sheets.IGradientFill|GCTYPE.Spread.Sheets.IGradientPathFill} [value] The cell background color.
                 * @returns {string|undefined|GCTYPE.Spread.Sheets.IPatternFill|GCTYPE.Spread.Sheets.IGradientFill|GCTYPE.Spread.Sheets.IGradientPathFill|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell background color; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).backColor("pink");
                 */
                backColor(value?: string | GCTYPE.Spread.Sheets.IPatternFill | GCTYPE.Spread.Sheets.IGradientFill | GCTYPE.Spread.Sheets.IGradientPathFill): any;
                /**
                 * Gets or sets the background image for the cell.
                 * @param {string} [value] The cell background image.
                 * @returns {string|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell background image; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(1,1).backgroundImage("images/example.jpg");
                 */
                backgroundImage(value?: string): any;
                /**
                 * Gets or sets the background image layout for the cell.
                 * @param {GCTYPE.Spread.Sheets.ImageLayout} [value] The cell background image layout.
                 * @returns {GCTYPE.Spread.Sheets.ImageLayout|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell background image layout; otherwise, returns the cell.
                 * @example
                 * var layout = GCTYPE.Spread.Sheets.ImageLayout.stretch;
                 * activeSheet.getRange(-1, 1, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).backgroundImageLayout(layout);
                 */
                backgroundImageLayout(value?: GCTYPE.Spread.Sheets.ImageLayout): any;
                /**
                 * Gets or sets the binding path for cell binding.
                 * @param {string} path The binding path for cell binding.
                 * @returns {string | GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the binding path for cell binding; otherwise, returns the worksheet.
                 * @example
                 * //This example uses the bindingPath method.
                 * var test = {name: "John"};
                 * activeSheet.getCell(0,0).bindingPath( "name");
                 * activeSheet.setDataSource(new GCTYPE.Spread.Sheets.Bindings.CellBindingSource(test));
                 */
                bindingPath(path?: string): any;
                /**
                 * Gets or sets the bottom border of the cell.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} [value] The cell bottom border line.
                 * @returns {GCTYPE.Spread.Sheets.LineBorder|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell bottom border line; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).borderBottom(new GCTYPE.Spread.Sheets.LineBorder("blue", GCTYPE.Spread.Sheets.LineStyle.mediumDashed));
                 */
                borderBottom(value?: GCTYPE.Spread.Sheets.LineBorder): any;
                /**
                 * Gets or sets the left border of the cell.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} [value] The cell left border line.
                 * @returns {GCTYPE.Spread.Sheets.LineBorder|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell left border line; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(2, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).borderLeft(new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.mediumDashed));
                 * @example
                 * activeSheet.getCell(1,1).borderLeft(new GCTYPE.Spread.Sheets.LineBorder("red", GCTYPE.Spread.Sheets.LineStyle.double));
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).borderLeft(new GCTYPE.Spread.Sheets.LineBorder("blue", GCTYPE.Spread.Sheets.LineStyle.mediumDashed));
                 */
                borderLeft(value?: GCTYPE.Spread.Sheets.LineBorder): any;
                /**
                 * Gets or sets the right border of the cell.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} [value] The cell right border line.
                 * @returns {GCTYPE.Spread.Sheets.LineBorder|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell right border line; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(2, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).borderRight(new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.mediumDashed));
                 * @example
                 * activeSheet.getCell(1,1).borderRight(new GCTYPE.Spread.Sheets.LineBorder("red", GCTYPE.Spread.Sheets.LineStyle.double));
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).borderRight(new GCTYPE.Spread.Sheets.LineBorder("blue", GCTYPE.Spread.Sheets.LineStyle.mediumDashed));
                 */
                borderRight(value?: GCTYPE.Spread.Sheets.LineBorder): any;
                /**
                 * Gets or sets the top border of the cell.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} [value] The cell top border line.
                 * @returns {GCTYPE.Spread.Sheets.LineBorder|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell top border line; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(2, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).borderTop(new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.mediumDashed));
                 * @example
                 * activeSheet.getCell(1,1).borderTop(new GCTYPE.Spread.Sheets.LineBorder("red", GCTYPE.Spread.Sheets.LineStyle.double));
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).borderTop(new GCTYPE.Spread.Sheets.LineBorder("blue", GCTYPE.Spread.Sheets.LineStyle.mediumDashed));
                 */
                borderTop(value?: GCTYPE.Spread.Sheets.LineBorder): any;
                /**
                 * Gets or sets the cellButtons of the cell.
                 * @param {Object[]} value the cellButtons of the cell.
                 * @returns {Object[] |GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cellButtons of the cell; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(2,-1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).cellButtons([caption:"Text"]]);
                 * @example
                 * var cellButtons = activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).cellButtons();
                 */
                cellButtons(value?: GCTYPE.Spread.Sheets.ICellButton[]): any;
                /**
                 * Gets or sets the cell padding.
                 * @param {string} [value] The cell padding.
                 * @returns {string|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the value of the cell padding; otherwise, returns the cell.
                 * @example
                 * // This example adds cell padding around the watermark.
                 * var type = new GCTYPE.Spread.Sheets.Style();
                 * type.watermark = "User name";
                 * type.cellPadding = "20";
                 * type.labelOptions = {alignment:GCTYPE.Spread.Sheets.LabelAlignment.topLeft, visibility: GCTYPE.Spread.Sheets.LabelVisibility.visible};
                 * activeSheet.setStyle(0, 1, type);
                 * activeSheet.getRange(0, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).height(60);
                 * activeSheet.getRange(-1, 1, -1, 1).width(150);
                 * var combo = new GCTYPE.Spread.Sheets.CellTypes.ComboBox();
                 * combo.items([{ text: "Oranges", value: "11k" }, { text: "Apples", value: "15k" }, { text: "Grape", value: "100k" }]);
                 * combo.editorValueType(GCTYPE.Spread.Sheets.CellTypes.EditorValueType.text);
                 * activeSheet.setCellType(2, 1, combo, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(2, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).watermark("ComboBox Cell Type").cellPadding('10 10 20 10');
                 * activeSheet.getCell(2, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).labelOptions({alignment: GCTYPE.Spread.Sheets.LabelAlignment.bottomCenter, foreColor: 'yellowgreen', font: 'bold 15px Arial'});
                 * activeSheet.getRange(2, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).height(60);
                 */
                cellPadding(value?: string): any;
                /**
                 * Gets or sets the cell type of the cell.
                 * @param {GCTYPE.Spread.Sheets.CellTypes.Base} [value] The cell type.
                 * @returns {GCTYPE.Spread.Sheets.CellTypes.Base|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell type; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 1, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).cellType(new GCTYPE.Spread.Sheets.CellTypes.CheckBox());
                 */
                cellType(value?: GCTYPE.Spread.Sheets.CellTypes.Base): any;
                /**
                 * Clears the specified area.
                 * @param {GCTYPE.Spread.Sheets.StorageType} type The clear type.
                 */
                clear(type: GCTYPE.Spread.Sheets.StorageType): void;
                /**
                 * Gets or sets the comment for the cell.
                 * @param {GCTYPE.Spread.Sheets.Comments.Comment} value The comment to set in the cell.
                 * @returns {GCTYPE.Spread.Sheets.Comments.Comment | GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the comment in the cell; otherwise, returns the cell range.
                 * @example
                 * // This example creates a cell comment.
                 * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                 * comment.text("new comment!");
                 * comment.backColor("yellow");
                 * comment.foreColor("green");
                 * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                 * activeSheet.getCell(5,5).comment(comment);
                 */
                comment(value?: GCTYPE.Spread.Sheets.Comments.Comment): any;
                /**
                 * Gets or sets the diagonalDown of the cell.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} [value] The cell diagonalDown line.
                 * @returns {GCTYPE.Spread.Sheets.LineBorder|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell diagonalDown line; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).diagonalDown(new GCTYPE.Spread.Sheets.LineBorder("blue", GCTYPE.Spread.Sheets.LineStyle.mediumDashed));
                 */
                diagonalDown(value?: GCTYPE.Spread.Sheets.LineBorder): any;
                /**
                 * Gets or sets the diagonalUp of the cell.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} [value] The cell diagonalUp line.
                 * @returns {GCTYPE.Spread.Sheets.LineBorder|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell diagonalUp line; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).diagonalUp(new GCTYPE.Spread.Sheets.LineBorder("blue", GCTYPE.Spread.Sheets.LineStyle.mediumDashed));
                 */
                diagonalUp(value?: GCTYPE.Spread.Sheets.LineBorder): any;
                /**
                 * Gets or sets the dropDowns of the cell.
                 * @param {Object[]} [value] the dropDowns of the cell.
                 * @returns {Object[] |GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the dropDowns of the cell; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(2,-1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).dropDowns([caption:"Text"]]);
                 * @example
                 * var dropDowns = activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).dropDowns();
                 */
                dropDowns(value?: GCTYPE.Spread.Sheets.IDropdown[]): any;
                /**
                 * Gets or sets the font for the cell, such as "normal normal normal 20px/normal Arial".
                 * @param {string} [value] The cell font.
                 * @returns {string|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell's font; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(2, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).font("12pt Arial");
                 * @example
                 * activeSheet.getCell(1,1).font("8pt Arial");
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).font("12pt Arial");
                 */
                font(value?: string): any;
                /**
                 * Gets or sets the color of the text in the cell, such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.
                 * @param {string} [value] The color of the text.
                 * @returns {string|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell foreground color; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).foreColor("blue");
                 */
                foreColor(value?: string): any;
                /**
                 * Gets or sets the formatter for the cell.
                 * @param {string | GCTYPE.Spread.Formatter.GeneralFormatter} [value] The cell formatter string or object.
                 * @returns {string | GCTYPE.Spread.Formatter.GeneralFormatter |GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell formatter string or object; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(1,1).formatter("0.000%");
                 * @example
                 * activeSheet.getCell(1, -1).formatter("0.000%");
                 * activeSheet.getCell(1,0).value("2");
                 * @example
                 * activeSheet.getCell(-1, 0).formatter("0.000%");
                 * activeSheet.getCell(0,0).value("2");
                 */
                formatter(value?: string | GCTYPE.Spread.Formatter.GeneralFormatter): any;
                /**
                 * Gets or sets the formula for the cell.
                 * @param {string} [value] The cell formula.
                 * @returns {string|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell formula; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(0,2).formula("DATEDIF(DATE(2003,1,1),DATE(2016,1,1),\"Y\")");
                 */
                formula(value?: string): any;
                /**
                 * Gets or sets the horizontal alignment of the contents of the cell.
                 * @param {GCTYPE.Spread.Sheets.HorizontalAlign} [value] The horizontal alignment.
                 * @returns {GCTYPE.Spread.Sheets.HorizontalAlign|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the horizontal alignment of the contents of the cell; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).hAlign(GCTYPE.Spread.Sheets.HorizontalAlign.right);
                 */
                hAlign(value?: GCTYPE.Spread.Sheets.HorizontalAlign): any;
                /**
                 * Gets or sets the height of the row in pixels.
                 * @param {number} [value] The cell row height.
                 * @returns {number|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the row height; otherwise, returns the row.
                 * @example
                 * activeSheet.getRange(0, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).height(90);
                 */
                height(value?: number): any;
                /**
                 * Gets or sets the imeMode of the cell.
                 * @param {GCTYPE.Spread.Sheets.ImeMode} [value] The cell imeMode.
                 * @returns {GCTYPE.Spread.Sheets.ImeMode|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell imeMode; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(0, 0).imeMode(GCTYPE.Spread.Sheets.ImeMode.disabled);
                 * //or
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.imeMode = GCTYPE.Spread.Sheets.ImeMode.disabled;
                 * activeSheet.setStyle(0, 0, style);
                 * @example
                 * activeSheet.getRange(2, -1, 1, -1).imeMode(GCTYPE.Spread.Sheets.ImeMode.active);
                 * @example
                 * activeSheet.getRange(-1, 2, -1, 1).imeMode(GCTYPE.Spread.Sheets.ImeMode.auto);
                 */
                imeMode(value?: GCTYPE.Spread.Sheets.ImeMode): any;
                /**
                 * Gets or sets whether the cell's text is vertical.
                 * @param {boolean} [value] Set to <c>true</c> to have the cell's text vertical.
                 * @returns {boolean|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns whether the cell's text vertical; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(2,-1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).isVerticalText(false);
                 * activeSheet.setText(2,0,"This is a test");
                 * @example
                 * activeSheet.getCell(1,1).isVerticalText(true);
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).isVerticalText(true);
                 */
                isVerticalText(value?: boolean): any;
                /**
                 * Gets or sets the cell label options.
                 * @param {Object} [value] The cell label options.
                 * @param {GCTYPE.Spread.Sheets.LabelAlignment} [value.alignment] - The cell label position.
                 * @param {GCTYPE.Spread.Sheets.LabelVisibility} [value.visibility] - The cell label visibility.
                 * @param {string} [value.font] - The cell label font.
                 * @param {string} [value.foreColor] - The cell label forecolor.
                 * @param {string} [value.margin] - The cell label margin.
                 * @returns {Object|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the value of the cell label options; otherwise, returns the cell.
                 * @example
                 * //This example sets label options for the watermark.
                 * var type = new GCTYPE.Spread.Sheets.Style();
                 * type.watermark = "User name";
                 * type.cellPadding = "20";
                 * type.labelOptions = {alignment:GCTYPE.Spread.Sheets.LabelAlignment.topLeft, visibility: GCTYPE.Spread.Sheets.LabelVisibility.visible};
                 * activeSheet.setStyle(0, 1, type);
                 * activeSheet.getRange(0, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).height(60);
                 * activeSheet.getRange(-1, 1, -1, 1).width(150);
                 * var combo = new GCTYPE.Spread.Sheets.CellTypes.ComboBox();
                 * combo.items([{ text: "Oranges", value: "11k" }, { text: "Apples", value: "15k" }, { text: "Grape", value: "100k" }]);
                 * combo.editorValueType(GCTYPE.Spread.Sheets.CellTypes.EditorValueType.text);
                 * activeSheet.setCellType(2, 1, combo, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(2, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).watermark("ComboBox Cell Type").cellPadding('10 10 20 10');
                 * activeSheet.getCell(2, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).labelOptions({alignment: GCTYPE.Spread.Sheets.LabelAlignment.bottomCenter, foreColor: 'yellowgreen', font: 'bold 15px Arial'});
                 * activeSheet.getRange(2, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).height(60);
                 */
                labelOptions(value?: GCTYPE.Spread.Sheets.ILabelOptions): any;
                /**
                 * Gets or sets whether the cell is locked. When the sheet is protected, the locked cell cannot be edited.
                 * @param {boolean} [value] Set to <c>true</c> to lock the cell.
                 * @returns {boolean|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns whether the cell is locked; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).locked(true);
                 */
                locked(value?: boolean): any;
                /**
                 * Gets or sets the quote prefix of the cell.
                 * @param {boolean} [value] The value of the quote Prefix.
                 * @returns {boolean|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the content of the quotePrefix; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(1,1).quotePrefix(true);
                 */
                quotePrefix(value?: boolean): any;
                /**
                 * Gets or sets whether the row or column can be resized by the user.
                 * @param {boolean} [value] Set to <c>true</c> to make the row resizable.
                 * @returns {boolean|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns whether the user can resize the row; otherwise, returns the row or column.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1. GCTYPE.Spread.Sheets.SheetArea.viewport).resizable(true);
                 */
                resizable(value?: boolean): any;
                /**
                 * Sets the border for the specified area.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} border The border line.
                 * @param {Object} option Determines which part of the cell range to set, the option object contains {all:true, left:true, top:true, right:true, bottom:true, diagonalUp:true, diagonalDown:true, outline:true,inside:true, innerHorizontal:true, innerVertical:true}
                 * @param {boolean} [options.all] - all border.
                 * @param {boolean} [options.left] - left border.
                 * @param {boolean} [options.top] - top border.
                 * @param {boolean} [options.right] - right border.
                 * @param {boolean} [options.bottom] - bottom border.
                 * @param {boolean} [options.outline] - outline border.
                 * @param {boolean} [options.inside] - inside border.
                 * @param {boolean} [options.innerHorizontal] - innerHorizontal border.
                 * @param {boolean} [options.innerVertical] - innerVertical border.
                 * @param {boolean} [options.diagonalUp] - diagonalUp border.
                 * @param {boolean} [options.diagonalDown] - diagonalDown border.
                 * @example
                 * //This example creates borders.
                 * sheet.getCell(1, 1).borderTop(new GCTYPE.Spread.Sheets.LineBorder("#F0F8FF",GCTYPE.Spread.Sheets.LineStyle.double));
                 * sheet.getCell(1, 1).borderLeft(new GCTYPE.Spread.Sheets.LineBorder("#F0F8FF",GCTYPE.Spread.Sheets.LineStyle.hair));
                 * sheet.getCell(1, 1).borderRight(new GCTYPE.Spread.Sheets.LineBorder("#FAEBD7",GCTYPE.Spread.Sheets.LineStyle.dashDot));
                 * sheet.getCell(1, 1).borderBottom(new GCTYPE.Spread.Sheets.LineBorder("#00FFFF",GCTYPE.Spread.Sheets.LineStyle.medium));
                 * sheet.getRange(-1, 5, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).borderTop(new GCTYPE.Spread.Sheets.LineBorder("#F0FFFF",GCTYPE.Spread.Sheets.LineStyle.medium));
                 * sheet.getRange(-1, 5, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).borderLeft(new GCTYPE.Spread.Sheets.LineBorder("#F5F5DC",GCTYPE.Spread.Sheets.LineStyle.medium));
                 * sheet.getRange(-1, 5, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).borderRight(new GCTYPE.Spread.Sheets.LineBorder("#FF02FF", GCTYPE.Spread.Sheets.LineStyle.dashDot));
                 * sheet.getRange(-1, 5, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).borderBottom (new GCTYPE.Spread.Sheets.LineBorder("#FFE4C4",GCTYPE.Spread.Sheets.LineStyle.thin));
                 * sheet.getRange(2, 2, 2, 2, GCTYPE.Spread.Sheets.SheetArea.viewport).setBorder(new GCTYPE.Spread.Sheets.LineBorder("#8A2BE2",GCTYPE.Spread.Sheets.LineStyle.thick), { all:true });
                 * sheet.getRange(5, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).borderTop( new GCTYPE.Spread.Sheets.LineBorder("#A52A2A",GCTYPE.Spread.Sheets.LineStyle.mediumDashed));
                 * sheet.getRange(5, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).borderLeft( new GCTYPE.Spread.Sheets.LineBorder("#FF02FF",GCTYPE.Spread.Sheets.LineStyle.medium));
                 * sheet.getRange(5, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).borderRight(new GCTYPE.Spread.Sheets.LineBorder("#5F9EA0", GCTYPE.Spread.Sheets.LineStyle.dashDot));
                 * sheet.getRange(5, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).borderBottom(new GCTYPE.Spread.Sheets.LineBorder("#6495ED",GCTYPE.Spread.Sheets.LineStyle.dotted));
                 * sheet.getRange(5, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).diagonalUp(new GCTYPE.Spread.Sheets.LineBorder("#FF02FF",GCTYPE.Spread.Sheets.LineStyle.dotted));
                 * sheet.getRange(5, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).diagonalDown(new GCTYPE.Spread.Sheets.LineBorder("#6495ED",GCTYPE.Spread.Sheets.LineStyle.medium));
                 */
                setBorder(border: GCTYPE.Spread.Sheets.LineBorder,  option: GCTYPE.Spread.Sheets.ISetBorderOptions): void;
                /**
                 * Gets or sets the cell ellipsis property.
                 * @param {boolean} [value] Set to <c>true</c> to have the cell test show ellipsis.
                 * @returns {boolean|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns whether the cell ellipsis property.
                 * @example
                 * activeSheet.getRange(2,-1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).showEllipsis(false);
                 * activeSheet.setText(2,0,"This is a test");
                 * @example
                 * activeSheet.getCell(1,1).showEllipsis(true);
                 */
                showEllipsis(value?: boolean): any;
                /**
                 * Gets or sets whether the cell shrinks the text to fit the cell size.
                 * @param {boolean} [value] Set to <c>true</c> to have the cell shrink text to fit.
                 * @returns {boolean|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns whether the cell shrinks the text to fit; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(2,-1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).shrinkToFit(false);
                 * activeSheet.setText(2,0,"This is a test");
                 * @example
                 * activeSheet.getCell(1,1).shrinkToFit(true);
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).shrinkToFit(true);
                 */
                shrinkToFit(value?: boolean): any;
                /**
                 * Gets or sets a value that indicates whether the user can set focus to the cell using the Tab key.
                 * @param {boolean} [value] Set to <c>true</c> to set focus to the cell using the Tab key.
                 * @returns {boolean|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns whether the user can set focus to the cell using the Tab key; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(1,1).tabStop(false);
                 * activeSheet.getRange(1, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).tabStop(false);
                 * activeSheet.getRange(-1, 1, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).tabStop(false);
                 */
                tabStop(value?: boolean): any;
                /**
                 * Gets or sets the tag for the cell.
                 * @param {Object} [value] The tag value.
                 * @returns {Object|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the tag value; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(1,1).tag("cell tag");
                 */
                tag(value?: any): any;
                /**
                 * Gets or sets the formatted text for the cell.
                 * @param {string} [value] The cell text.
                 * @returns {string|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell text; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(1,1).text("cell object");
                 */
                text(value?: string): any;
                /**
                 * Gets or sets the type of the decoration added to the cell's text.
                 * @param {GCTYPE.Spread.Sheets.TextDecorationType} [value] The type of the decoration.
                 * @returns {GCTYPE.Spread.Sheets.TextDecorationType|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the type of the decoration; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(1, -1, 1, -1).textDecoration(GCTYPE.Spread.Sheets.TextDecorationType.overline | GCTYPE.Spread.Sheets.TextDecorationType.underline);
                 */
                textDecoration(value?: GCTYPE.Spread.Sheets.TextDecorationType): any;
                /**
                 * Gets or sets the text indent of the cell.
                 * @param {number} [value] The cell text indent.
                 * @returns {number|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell text indent; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).textIndent(1);
                 */
                textIndent(value?: number): any;
                /**
                 * Gets or sets the text rotation angle of the cell.
                 * @param {number}  [value] The cell text rotation angle, form -90 to 90 angle.
                 * @returns {number|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell text rotation angle; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).textOrientation(66);
                 */
                textOrientation(value?: number): any;
                /**
                 * Gets or sets the theme font for the cell.
                 * @param {string} [value] The cell's theme font.
                 * @returns {string|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell's theme font; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(-1, 0).themeFont("Body");
                 * activeSheet.getCell(0,0).value("Test");
                 */
                themeFont(value?: string): any;
                /**
                 * Gets the HTML content from the specified area.
                 * @param {GCTYPE.Spread.Sheets.HeaderOptions} [headerOptions] Indicates whether to include row header and column header or not, when cell range is whole rows or whole columns in viewport area, it defaults to <b>noHeaders</b>.
                 * @param {boolean} [includeStyle] Indicates whether to include style and span or not, it defaults to <b>true</b>.
                 * @returns {string} The HTML content that contains cell text, cell span and cell style.
                 * @example
                 * activeSheet.getRange(0, 0, 10, 10).toHtml();
                 */
                toHtml(headerOptions?: GCTYPE.Spread.Sheets.HeaderOptions,  includeStyle?: boolean): string;
                /**
                 * Gets or sets the data validator for the cell.
                 * @param {GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} value The cell data validator.
                 * @returns {GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell data validator; otherwise, returns the cell.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GCTYPE.Spread.Sheets.DataValidation.createDateValidator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between, new Date(2012, 11, 31), new Date(2013, 11, 31));
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Enter a date between 12/31/2012 and 12/31/2013.");
                 * dv.inputTitle("Tip");
                 * activeSheet.getCell(0,0).validator(dv);
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GCTYPE.Spread.Sheets.DataValidation.createDateValidator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between, new Date(2012, 11, 31), new Date(2013, 11, 31));
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Enter a date between 12/31/2012 and 12/31/2013.");
                 * dv.inputTitle("Tip");
                 * activeSheet.getCell(1, -1).validator(dv);
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GCTYPE.Spread.Sheets.DataValidation.createListValidator("1,2,3");
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Value must be 1,2 or 3");
                 * dv.inputTitle("tip");
                 * activeSheet.setDataValidator(-1,0,dv);
                 */
                validator(value?: GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator): any;
                /**
                 * Gets or sets the vertical alignment of the contents of the cell.
                 * @param {GCTYPE.Spread.Sheets.VerticalAlign} [value] The vertical alignment.
                 * @returns {GCTYPE.Spread.Sheets.VerticalAlign|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the vertical alignment of the contents of the cell; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).vAlign(GCTYPE.Spread.Sheets.VerticalAlign.top);
                 */
                vAlign(value?: GCTYPE.Spread.Sheets.VerticalAlign): any;
                /**
                 * Gets or sets the unformatted value of the cell.
                 * @param {Object} [value] The cell value.
                 * @returns {Object|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the cell value; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(1,1).value(10);
                 */
                value(value?: any): any;
                /**
                 * Gets or sets whether the row or column is displayed.
                 * @param {boolean} [value] Set to <c>true</c> to make the row visible.
                 * @returns {boolean|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the visible of the row or column; otherwise, returns the row or column.
                 * @example
                 * activeSheet.getCell(-1, 0).visible(false);
                 */
                visible(value?: boolean): any;
                /**
                 * Gets or sets the content of the cell watermark.
                 * @param {string} [value] The content of the watermark.
                 * @returns {string|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the content of the watermark; otherwise, returns the cell.
                 * @example
                 * activeSheet.getCell(1,1).watermark("lightgreen");
                 */
                watermark(value?: string): any;
                /**
                 * Gets or sets the width of the column in pixels.
                 * @param {number} [value] The column width.
                 * @returns {number|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns the column width; otherwise, returns the column.
                 * @example
                 * activeSheet.getCell(-1, 0).width(20);
                 */
                width(value?: number): any;
                /**
                 * Gets or sets whether the cell lets text wrap.
                 * @param {boolean} [value] Set to <c>true</c> to let text wrap within the cell.
                 * @returns {boolean|GCTYPE.Spread.Sheets.CellRange} If no value is set, returns whether the cell lets text wrap; otherwise, returns the cell.
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).wordWrap(true);
                 */
                wordWrap(value?: boolean): any;
            }

            export class ColorScheme{
                /**
                 * Creates a ColorScheme instance.
                 * @constructor
                 * @class
                 * @classdesc Represents the theme color.
                 * @param {string} name The owner that contains the named variable.
                 * @param {string} background1 The theme color for background1.
                 * @param {string} background2 The theme color for background2.
                 * @param {string} text1 The theme color for text1.
                 * @param {string} text2 The theme color for text2.
                 * @param {string} accent1 The theme color for accent1.
                 * @param {string} accent2 The theme color for accent2.
                 * @param {string} accent3 The theme color for accent3.
                 * @param {string} accent4 The theme color for accent4.
                 * @param {string} accent5 The theme color for accent5.
                 * @param {string} accent6 The theme color for accent6.
                 * @param {string} link The color of the link.
                 * @param {string} followedLink The color of the followedLink.
                 * @example
                 * //This example creates colors for the theme.
                 * var ntheme = new GCTYPE.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("accent 1 30");
                 */
                constructor(name: string,  background1: string,  background2: string,  text1: string,  text2: string,  accent1: string,  accent2: string,  accent3: string,  accent4: string,  accent5: string,  accent6: string,  link: string,  followedLink: string);
                /**
                 * Gets or sets the accent1 theme color of the color scheme.
                 * @param {string} value The accent1 theme color string.
                 * @returns {string|GCTYPE.Spread.Sheets.ColorScheme} If no value is set, returns the accent1 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the accent1 color.
                 * var ntheme = new GCTYPE.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("accent 1 30");
                 */
                accent1(value?: string): any;
                /**
                 * Gets or sets the accent2 theme color of the color scheme.
                 * @param {string} value The accent2 theme color string.
                 * @returns {string|GCTYPE.Spread.Sheets.ColorScheme} If no value is set, returns the accent2 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the accent2 color.
                 * var ntheme = new GCTYPE.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().accent2("red");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("accent 2");
                 */
                accent2(value?: string): any;
                /**
                 * Gets or sets the accent3 theme color of the color scheme.
                 * @param {string} value The accent3 theme color string.
                 * @returns {string|GCTYPE.Spread.Sheets.ColorScheme} If no value is set, returns the accent3 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the accent3 color.
                 * var ntheme = new GCTYPE.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().accent3("yellow");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("accent 3");
                 */
                accent3(value?: string): any;
                /**
                 * Gets or sets the accent4 theme color of the color scheme.
                 * @param {string} value The accent4 theme color string.
                 * @returns {string|GCTYPE.Spread.Sheets.ColorScheme} If no value is set, returns the accent4 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the accent4 color.
                 * var ntheme = new GCTYPE.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().accent4("blue");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("accent 4");
                 */
                accent4(value?: string): any;
                /**
                 * Gets or sets the accent5 theme color of the color scheme.
                 * @param {string} value The accent5 theme color string.
                 * @returns {string|GCTYPE.Spread.Sheets.ColorScheme} If no value is set, returns the accent5 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the accent5 color.
                 * var ntheme = new GCTYPE.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().accent5("blue");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("accent 5");
                 */
                accent5(value?: string): any;
                /**
                 * Gets or sets the accent6 theme color of the color scheme.
                 * @param {string} value The accent6 theme color string.
                 * @returns {string|GCTYPE.Spread.Sheets.ColorScheme} If no value is set, returns the accent6 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the accent6 color.
                 * var ntheme = new GCTYPE.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().accent6("blue");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("accent 6");
                 */
                accent6(value?: string): any;
                /**
                 * Gets or sets the background1 theme color of the color scheme.
                 * @param {string} value The background1 theme color string.
                 * @returns {string|GCTYPE.Spread.Sheets.ColorScheme} If no value is set, returns the background1 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the background1 color.
                 * var ntheme = new GCTYPE.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().background1("orange");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("background 1");
                 */
                background1(value?: string): any;
                /**
                 *  Gets or sets the background2 theme color of the color scheme.
                 * @param {string} value The background2 theme color string.
                 * @returns {string|GCTYPE.Spread.Sheets.ColorScheme} If no value is set, returns the background2 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the background2 color.
                 * var ntheme = new GCTYPE.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().background2("orange");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("background 2");
                 */
                background2(value?: string): any;
                /**
                 * Gets or sets the followed hyperlink theme color of the color scheme.
                 * @param {string} value The followed hyperlink theme color string.
                 * @returns {string|GCTYPE.Spread.Sheets.ColorScheme} If no value is set, returns the followed hyperlink theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the followedHyperline color.
                 * var ntheme = new GCTYPE.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().followedHyperlink("orange");
                 * ntheme.colors().hyperlink("red");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("followedHyperlink");
                 * activeSheet.getCell(2, 0).backColor("hyperlink");
                 */
                followedHyperlink(value?: string): any;
                /**
                 * Gets the color based on the theme color.
                 * @param {string} name The theme color name.
                 * @returns {string} The theme color.
                 * @example
                 * //This example gets the theme color.
                 * var ntheme = new GCTYPE.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().followedHyperlink("orange");
                 * ntheme.colors().hyperlink("red");
                 * ntheme.colors().name("test");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("followedHyperlink");
                 * activeSheet.getCell(2, 0).backColor("hyperlink");
                 * var cname = ntheme.getColor("accent 1");
                 * alert(cname);
                 */
                getColor(name: string): string;
                /**
                 * Gets or sets the hyperlink theme color of the color scheme.
                 * @param {string} value The hyperlink theme color string.
                 * @returns {string|GCTYPE.Spread.Sheets.ColorScheme} If no value is set, returns the hyperlink theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the hyperline color.
                 * var ntheme = new GCTYPE.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().followedHyperlink("orange");
                 * ntheme.colors().hyperlink("red");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("followedHyperlink");
                 * activeSheet.getCell(2, 0).backColor("hyperlink");
                 */
                hyperlink(value?: string): any;
                /**
                 * Gets or sets the name of the color scheme.
                 * @param {string} value The name.
                 * @returns {string|GCTYPE.Spread.Sheets.ColorScheme} If no value is set, returns the name; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the theme name.
                 * var ntheme = new GCTYPE.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().name("green theme");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 */
                name(value?: string): any;
                /**
                 * Gets or sets the textcolor1 theme color of the color scheme.
                 * @param {string} value The textcolor1 theme color string.
                 * @returns {string|GCTYPE.Spread.Sheets.ColorScheme} If no value is set, returns the textcolor1 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the textColor1 color.
                 * var ntheme = new GCTYPE.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().textColor1("orange");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("Text 1");
                 */
                textColor1(value?: string): any;
                /**
                 * Gets or sets the textcolor2 theme color of the color scheme.
                 * @param {string} value The textcolor2 theme color string.
                 * @returns {string|GCTYPE.Spread.Sheets.ColorScheme} If no value is set, returns the textcolor2 theme color; otherwise, returns the color scheme.
                 * @example
                 * //This example sets the textColor2 color.
                 * var ntheme = new GCTYPE.Spread.Sheets.Theme("customThemeColor");
                 * ntheme.colors().accent1("lightgreen");
                 * ntheme.colors().textColor2("orange");
                 * activeSheet.currentTheme(ntheme);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("Text 2");
                 */
                textColor2(value?: string): any;
            }

            export class Events{
                /**
                 * Defines the events supported in SpreadJS.
                 * @class
                 */
                constructor();
                /**
                 * Occurs when the user has changed the active sheet.
                 * @name GCTYPE.Spread.Sheets.Workbook#ActiveSheetChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} oldSheet The old sheet.
                 * @param {GCTYPE.Spread.Sheets.Worksheet} newSheet The new sheet.
                 * @example
                 * //This example creates log text for the ActiveSheetChanged event.
                 * // Use IE to see the console log text
                 * spread.bind(GCTYPE.Spread.Sheets.Events.ActiveSheetChanged, function (sender, args) {
                 *     console.log("Active sheet has been switched.");
                 * });
                 */
                static ActiveSheetChanged: string;
                /**
                 * Occurs when the user is changing the active sheet.
                 * @name GCTYPE.Spread.Sheets.Workbook#ActiveSheetChanging
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} oldSheet The old sheet.
                 * @param {GCTYPE.Spread.Sheets.Worksheet} newSheet The new sheet.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example stops the active sheet from changing.
                 * spread.bind(GCTYPE.Spread.Sheets.Events.ActiveSheetChanging, function (sender, args) {
                 *     //Cancel sheet switching.
                 *     args.cancel = true;
                 * });
                 */
                static ActiveSheetChanging: string;
                /**
                 * Occurs before the print
                 * @name GCTYPE.Spread.Sheets.WorkBook.BeforePrint
                 * @event
                 * @param {Object} iframe The print Dom
                 * @param {booble} cancel Whether cancel print
                 * @example
                 * //This example uses the BeforePrint.
                 * window.onload = function(){
                 *      var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 *      spread.bind(GCTYPE.Spread.Sheets.Events.BeforePrint, function (e, data) {
                 *          alert(data.iframe + '\n' + 'cancel: ' + data.cancel);
                 *      });
                 * }
                 */
                static BeforePrint: string;
                /**
                 * Occurs when the user clicks a button, check box, or hyperlink in a cell.
                 * @name GCTYPE.Spread.Sheets.Workbook#ButtonClicked
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of the cell.
                 * @param {number} col The column index of the cell.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheet area that contains the cell.
                 * @example
                 * //This example creates a button cell.
                 * var cellType = new GCTYPE.Spread.Sheets.CellTypes.Button();
                 * cellType.buttonBackColor("#FFFF00");
                 * cellType.text("this is a button");
                 * activeSheet.setCellType(1,1,cellType);
                 * //bind
                 * spread.bind(GCTYPE.Spread.Sheets.Events.ButtonClicked, function (e, args) {
                 *     var sheet = args.sheet, row = args.row, col = args.col;
                 *     var cellType = activeSheet.getCellType(row, col);
                 *     if (cellType instanceof GCTYPE.Spread.Sheets.CellTypes.Button) {
                 *         alert("Button Clicked");
                 *     }
                 * });
                 */
                static ButtonClicked: string;
                /**
                 * Occurs when a change is made to a cell in this sheet that may require the cell to be repainted.
                 * @name GCTYPE.Spread.Sheets.Worksheet#CellChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of the cell.
                 * @param {number} col The column index of the cell.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheetArea of the cell.
                 * @param {string} propertyName The name of the cell's property that has changed.
                 * @param {boolean} isUndo Whether this event is from a undo operation.
                 * @example
                 * //This example uses the CellChanged event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.CellChanged, function (e, info) {
                 *     if(info.sheetArea === GCTYPE.Spread.Sheets.SheetArea.viewport){
                 *         alert("Cell index (" + info.row + "," + info.col + ")");
                 *     }
                 * });
                 */
                static CellChanged: string;
                /**
                 * Occurs when the user presses down the left mouse button in a cell.
                 * @name GCTYPE.Spread.Sheets.Worksheet#CellClick
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheet area the clicked cell is in.
                 * @param {number} row The row index of the clicked cell.
                 * @param {number} col The column index of the clicked cell.
                 * @example
                 * //This example uses the CellClick event.
                 * // Use IE to see the console log text
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.CellClick, function (sender, args) {
                 *     if(args.sheetArea === GCTYPE.Spread.Sheets.SheetArea.colHeader){
                 *         console.log("The column header was clicked.");
                 *     }
                 *     if(args.sheetArea === GCTYPE.Spread.Sheets.SheetArea.rowHeader){
                 *         console.log("The row header was clicked.");
                 *     }
                 *     if(args.sheetArea === GCTYPE.Spread.Sheets.SheetArea.corner){
                 *         console.log("The corner header was clicked.");
                 *     }
                 *     console.log("Clicked column index: " + args.col);
                 *     console.log("Clicked row index: " + args.row);
                 * });
                 * //bind
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.CellDoubleClick, function (sender, args) {
                 *     if(args.sheetArea === GCTYPE.Spread.Sheets.SheetArea.colHeader){
                 *         console.log("The column header was double clicked.");
                 *    }
                 *     if(args.sheetArea === GCTYPE.Spread.Sheets.SheetArea.rowHeader){
                 *         console.log("The row header was double clicked.");
                 *     }
                 *     if(args.sheetArea === GCTYPE.Spread.Sheets.SheetArea.corner){
                 *         console.log("The corner header was double clicked.");
                 *     }
                 *     console.log("Double clicked column index: " + args.col);
                 *     console.log("Double clicked row index: " + args.row);
                 * })
                 */
                static CellClick: string;
                /**
                 * Occurs when the user presses down the left mouse button twice (double-clicks) in a cell.
                 * @name GCTYPE.Spread.Sheets.Worksheet#CellDoubleClick
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheet area the clicked cell is in.
                 * @param {number} row The row index of the clicked cell.
                 * @param {number} col The column index of the clicked cell.
                 * @example
                 * //This example uses the CellDoubleClick event.
                 * // Use IE to see the console log text
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.CellClick, function (sender, args) {
                 *     if(args.sheetArea === GCTYPE.Spread.Sheets.SheetArea.colHeader){
                 *         console.log("The column header was clicked.");
                 *     }
                 *     if(args.sheetArea === GCTYPE.Spread.Sheets.SheetArea.rowHeader){
                 *         console.log("The row header was clicked.");
                 *     }
                 *     if(args.sheetArea === GCTYPE.Spread.Sheets.SheetArea.corner){
                 *         console.log("The corner header was clicked.");
                 *     }
                 *     console.log("Clicked column index: " + args.col);
                 *     console.log("Clicked row index: " + args.row);
                 * });
                 * //bind
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.CellDoubleClick, function (sender, args) {
                 *     if(args.sheetArea === GCTYPE.Spread.Sheets.SheetArea.colHeader){
                 *         console.log("The column header was double clicked.");
                 *     }
                 *     if(args.sheetArea === GCTYPE.Spread.Sheets.SheetArea.rowHeader){
                 *         console.log("The row header was double clicked.");
                 *     }
                 *     if(args.sheetArea === GCTYPE.Spread.Sheets.SheetArea.corner){
                 *         console.log("The corner header was double clicked.");
                 *     }
                 *     console.log("Double clicked column index: " + args.col);
                 *     console.log("Double clicked row index: " + args.row);
                 * });
                 */
                static CellDoubleClick: string;
                /**
                 * Occurs when a Clipboard change occurs that affects Spread.Sheets.
                 * @name GCTYPE.Spread.Sheets.Worksheet#ClipboardChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {Object} copyData The data from Spread.Sheets that has been set into the clipboard.
                 * @param {string} copyData.text The text string of the clipboard.
                 * @param {string} copyData.html The html string of the clipboard.
                 * @param {Array} objects The copied floating objects, it contains picture, custom floating object, slicer, chart and shape.
                 * @example
                 * //This example uses the ClipboardChanged event.
                 * // Use IE to see the console log text
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ClipboardChanged, function (sender, args) {
                 *     console.log("ClipboardChanged.");
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ClipboardChanging, function (sender, args) {
                 *     console.log("ClipboardChanging");
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ClipboardPasted, function (sender, args) {
                 *     console.log("ClipboardPasted");
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ClipboardPasting, function (sender, args) {
                 *     console.log("ClipboardPasting");
                 * });
                 */
                static ClipboardChanged: string;
                /**
                 * Occurs when the Clipboard is changing due to a Spread.Sheets action.
                 * @name GCTYPE.Spread.Sheets.Worksheet#ClipboardChanging
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {Object} copyData The data from Spread.Sheets that is set into the clipboard.
                 * @param {string} copyData.text The text string of the clipboard.
                 * @param {string} copyData.html The html string of the clipboard.
                 * @param {Array} objects The coping floating objects, it contains picture, custom floating object, slicer, chart and shape.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the ClipboardChanging event.
                 * // Use IE to see the console log text
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ClipboardChanged, function (sender, args) {
                 *     console.log("ClipboardChanged.");
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ClipboardChanging, function (sender, args) {
                 *     console.log("ClipboardChanging");
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ClipboardPasted, function (sender, args) {
                 *     console.log("ClipboardPasted");
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ClipboardPasting, function (sender, args) {
                 *     console.log("ClipboardPasting");
                 * });
                 */
                static ClipboardChanging: string;
                /**
                 * Occurs when the user pastes from the Clipboard.
                 * @name GCTYPE.Spread.Sheets.Worksheet#ClipboardPasted
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Range} cellRange The range that was pasted.
                 * @param {GCTYPE.Spread.Sheets.ClipboardPasteOptions} pasteOption The paste option that indicates what data is pasted from the clipboard: values, formatting, or formulas.
                 * @param {Object} pasteData The data from the clipboard that will be pasted into Spread.Sheets.
                 * @param {string} pasteData.text The text string of the clipboard.
                 * @param {string} pasteData.html The html string of the clipboard.
                 * @param {string} pasteData.image The image src string of the clipboard.
                 * @param {Array} objects The pasted floating objects, it contains picture, custom floating object, slicer, chart and shape.
                 * @example
                 * //This example uses the ClipboardPasted event.
                 * // Use IE to see the console log text
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ClipboardChanged, function (sender, args) {
                 *     console.log("ClipboardChanged.");
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ClipboardChanging, function (sender, args) {
                 *     console.log("ClipboardChanging");
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ClipboardPasted, function (sender, args) {
                 *     console.log("ClipboardPasted");
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ClipboardPasting, function (sender, args) {
                 *     console.log("ClipboardPasting");
                 * });
                 */
                static ClipboardPasted: string;
                /**
                 * Occurs when the user is pasting from the Clipboard.
                 * @name GCTYPE.Spread.Sheets.Worksheet#ClipboardPasting
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Range} cellRange The range to paste.
                 * @param {GCTYPE.Spread.Sheets.ClipboardPasteOptions} pasteOption The paste option that indicates what data is pasted from the clipboard: values, formatting, or formulas.
                 * @param {Object} pasteData The data from the clipboard that will be pasted into Spread.Sheets.
                 * @param {string} pasteData.text The text string of the clipboard.
                 * @param {string} pasteData.html The html string of the clipboard.
                 * @param {string} pasteData.image The image src string of the clipboard.
                 * @param {Array} objects The pasting floating objects, it contains picture, custom floating object, slicer, chart and shape.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the ClipboardPasting event.
                 * // Use IE to see the console log text
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ClipboardChanged, function (sender, args) {
                 *     console.log("ClipboardChanged.");
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ClipboardChanging, function (sender, args) {
                 *     console.log("ClipboardChanging");
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ClipboardPasted, function (sender, args) {
                 *     console.log("ClipboardPasted");
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ClipboardPasting, function (sender, args) {
                 *     console.log("ClipboardPasting");
                 * });
                 */
                static ClipboardPasting: string;
                /**
                 * Occurs when a change is made to a column or range of columns in this sheet that may require the column or range of columns to be repainted.
                 * @name GCTYPE.Spread.Sheets.Worksheet#ColumnChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheetArea of the column.
                 * @param {string} propertyName The name of the column's property that has changed.
                 * @param {boolean} isUndo Whether this event is from a undo operation.
                 * @example
                 * //This example uses the ColumnChanged event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ColumnChanged, function (e, info) {
                 *     if(info.sheetArea === GCTYPE.Spread.Sheets.SheetArea.viewport){
                 *         alert("Index (" + info.col + ")");
                 *     }
                 * });
                 */
                static ColumnChanged: string;
                /**
                 * Occurs when before a change is made to a column or range of columns in this sheet that may require the column or range of columns to be repainted.
                 * @name GCTYPE.Spread.Sheets.Worksheet#ColumnChanging
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheetArea of the column.
                 * @param {string} propertyName The name of the column's property that has changed.
                 * @example
                 * //This example uses the ColumnChanging event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ColumnChanging, function (e, info) {
                 *     if(info.sheetArea === GCTYPE.Spread.Sheets.SheetArea.viewport){
                 *         alert("Index (" + info.col + ")");
                 *     }
                 * });
                 */
                static ColumnChanging: string;
                /**
                 * Occurs when the column width has changed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#ColumnWidthChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {Array} colList The list of columns whose widths have changed.
                 * @param {boolean} header Whether the columns are row header columns.
                 * @example
                 * //This example uses the ColumnWidthChanged event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ColumnWidthChanged, function (e, info) {
                 *         alert("Column (" + info.colList + ")");
                 * });
                 */
                static ColumnWidthChanged: string;
                /**
                 * Occurs when the column width is changing.
                 * @name GCTYPE.Spread.Sheets.Worksheet#ColumnWidthChanging
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {Array} colList The list of columns whose widths are changing.
                 * @param {boolean} header Whether the columns are row header columns.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the ColumnWidthChanging event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ColumnWidthChanging, function (e, info) {
                 *         alert("Column (" + info.colList + ")");
                 * });
                 */
                static ColumnWidthChanging: string;
                /**
                 * Occurs when any comment has changed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#CommentChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Comments.Comment} comment The comment that triggered the event.
                 * @param {string} propertyName The name of the comment's property that has changed.
                 * @example
                 * //This example uses the CommentChanged event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.CommentChanged, function (e, info) {
                 *     alert("changed");
                 * });
                 */
                static CommentChanged: string;
                /**
                 * Occurs when the user has removed the comment.
                 * @name GCTYPE.Spread.Sheets.Worksheet#CommentRemoved
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Comments.Comment} comment The comment has been removed.
                 * @example
                 * //This example uses the CommentRemoved event.
                 * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                 * comment.text("new comment!");
                 * comment.backColor("orange");
                 * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                 * activeSheet.getCell(5,5).comment(comment);
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.CommentRemoved, function (e, info) {
                 *        console.log("sheet name: " + info.sheetName);
                 * });
                 */
                static CommentRemoved: string;
                /**
                 * Occurs when the user is removing any comment.
                 * @name GCTYPE.Spread.Sheets.Worksheet#CommentRemoving
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Comments.Comment} comment The comment is being removed.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example prevents the comment from being removed.
                 * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                 * comment.text("new comment!");
                 * comment.backColor("orange");
                 * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                 * activeSheet.getCell(5,5).comment(comment);
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.CommentRemoving, function (e, info) {
                 *       info.cancel = true;
                 * });
                 */
                static CommentRemoving: string;
                /**
                 * Occurs when the user is dragging and dropping a range of cells.
                 * @name GCTYPE.Spread.Sheets.Worksheet#DragDropBlock
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} fromRow The row index of the top left cell of the source range (range being dragged).
                 * @param {number} fromCol The column index of the top left cell of the source range (range being dragged).
                 * @param {number} toRow The row index of the top left cell of the destination range (where selection is dropped).
                 * @param {number} toCol The column index of the bottom right cell of the destination range (where selection is dropped).
                 * @param {number} rowCount The row count of the cell range being dragged.
                 * @param {number} colCount The column count of the cell range being dragged.
                 * @param {boolean} copy Whether the source range is copied.
                 * @param {boolean} insert Whether the source range is inserted.
                 * @param {GCTYPE.Spread.Sheets.CopyToOptions} copyOption The CopyOption value for the drag and drop operation.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example creates log text for the DragDropBlock event.
                 * // Use IE to see the console log text
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.DragDropBlock, function (e, args) {
                 *         console.log("From Column:" + args.fromCol);
                 *         console.log("From Row:" + args.fromRow);
                 *         console.log("To Column:" + args.toCol);
                 *         console.log("To Row:" + args.toRow);
                 *     });
                 */
                static DragDropBlock: string;
                /**
                 * Occurs when the user completes dragging and dropping a range of cells.
                 * @name GCTYPE.Spread.Sheets.Worksheet#DragDropBlockCompleted
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} fromRow The row index of the top left cell of the source range (range being dragged).
                 * @param {number} fromCol The column index of the top left cell of the source range (range being dragged).
                 * @param {number} toRow The row index of the top left cell of the destination range (where selection is dropped).
                 * @param {number} toCol The column index of the bottom right cell of the destination range (where selection is dropped).
                 * @param {number} rowCount The row count of the cell range being dragged.
                 * @param {number} colCount The column count of the cell range being dragged.
                 * @param {boolean} copy Whether the source range is copied.
                 * @param {boolean} insert Whether the source range is inserted.
                 * @param {GCTYPE.Spread.Sheets.CopyToOptions} copyOption The CopyOption value for the drag and drop operation.
                 * @example
                 * //This example uses the DragDropBlockCompleted event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.DragDropBlockCompleted, function (e, args) {
                 *         alert("From Column (" + args.fromCol + ")");
                 * });
                 */
                static DragDropBlockCompleted: string;
                /**
                 * Occurs when the user is dragging to fill a range of cells.
                 * @name GCTYPE.Spread.Sheets.Worksheet#DragFillBlock
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Range} fillRange The range used for the fill operation.
                 * @param {GCTYPE.Spread.Sheets.Fill.AutoFillType} autoFillType AutoFillType value used for the fill operation.
                 * @param {GCTYPE.Spread.Sheets.Fill.FillDirection} fillDirection The direction of the fill.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the DragFillBlock event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.DragFillBlock, function (e, info) {
                 *         alert("Direction (" + info.fillDirection + ")");
                 * });
                 */
                static DragFillBlock: string;
                /**
                 * Occurs when the user completes dragging to fill a range of cells.
                 * @name GCTYPE.Spread.Sheets.Worksheet#DragFillBlockCompleted
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Range} fillRange The range used for the fill operation.
                 * @param {GCTYPE.Spread.Sheets.Fill.AutoFillType} autoFillType AutoFillType value used for the fill operation.
                 * @param {GCTYPE.Spread.Sheets.Fill.FillDirection} fillDirection The direction of the fill.
                 * @example
                 * //This example uses the DragFillBlockCompleted event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.DragFillBlockCompleted, function (e, info) {
                 *         alert("Type (" + info.autoFillType + ")");
                 * });
                 */
                static DragFillBlockCompleted: string;
                /**
                 * Occurs after user drag merge cells.
                 * @name GCTYPE.Spread.Sheets.Worksheet#DragMerged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Range} mergeRange The range that will be merged.
                 * @example
                 * //This example returns the row index.
                 * // Press Ctrl key to merge
                 * $(document).keydown(function (e) {
                 *      if (e.keyCode === 17) {
                 *         spread.options.allowUserDragMerge = true;
                 *      }
                 * });
                 * $(document).keyup(function (e) {
                 *      if (e.keyCode === 17) {
                 *         spread.options.allowUserDragMerge = false;
                 *      }
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.DragMerging, function (e, data) {
                 *      var mergeRange = data.mergeRange;
                 *      alert(mergeRange.row);
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.DragMerged, function (e, data) {
                 *      var mergeRange = data.mergeRange;
                 *      alert(mergeRange.row);
                 * });
                 */
                static DragMerged: string;
                /**
                 * Occurs before user drag merge cells.
                 * @name GCTYPE.Spread.Sheets.Worksheet#DragMerging
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Range} mergeRange The range that will be merged.
                 * @param {bool} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example returns the row index.
                 * // Press Ctrl key to merge
                 * $(document).keydown(function (e) {
                 *      if (e.keyCode === 17) {
                 *          spread.options.allowUserDragMerge = true;
                 *      }
                 * });
                 * $(document).keyup(function (e) {
                 *      if (e.keyCode === 17) {
                 *          spread.options.allowUserDragMerge = false;
                 *      }
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.DragMerging, function (e, data) {
                 *      var mergeRange = data.mergeRange;
                 *      alert(mergeRange.row);
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.DragMerged, function (e, data) {
                 *      var mergeRange = data.mergeRange;
                 *      alert(mergeRange.row);
                 * });
                 */
                static DragMerging: string;
                /**
                 * Occurs when a cell is in edit mode and the text is changed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#EditChange
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of cell.
                 * @param {number} col The column index of cell.
                 * @param {Object} editingText The value from the current editor.
                 * @example
                 * //This example creates log text for the EditChange event.
                 * // Use IE to see the console log text
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.EditChange, function (sender, args) {
                 *     console.log("Cell (" + args.row + ", " + args.col + ") data has been changed.")
                 * });
                 */
                static EditChange: string;
                /**
                 * Occurs when a cell leaves edit mode.
                 * @name GCTYPE.Spread.Sheets.Worksheet#EditEnded
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of cell.
                 * @param {number} col The column index of cell.
                 * @param {Object} editingText The value from the current editor.
                 * @example
                 * //This example creates log text for the EditStarting and EditEnded events.
                 *  // Use IE to see the console log text
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.EditStarting, function (sender, args) {
                 *     console.log("Start cell editing.");
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.EditEnded, function (sender, args) {
                 *     console.log("Finish cell editing.");
                 * });
                 */
                static EditEnded: string;
                /**
                 * Occurs when a cell is leaving edit mode.
                 * @name GCTYPE.Spread.Sheets.Worksheet#EditEnding
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of cell.
                 * @param {number} col The column index of cell.
                 * @param {Object} editor The current editor.
                 * @param {Object} editingText The value from the current editor.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the EditEnding event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.EditStarting, function (sender, args) {
                 *     console.log("Start cell editing.");
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.EditEnding, function (sender, args) {
                 *     console.log("EditEnding event.");
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.EditEnded, function (sender, args) {
                 *     console.log("EditEnded event.");
                 * });
                 */
                static EditEnding: string;
                /**
                 * Occurs when the editor's status has changed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#EditorStatusChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.EditorStatus} oldStatus The old status of the editor.
                 * @param {GCTYPE.Spread.Sheets.EditorStatus} newStatus The new status of the editor.
                 * @example
                 * //This example uses the EditorStatusChanged event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.EditorStatusChanged, function (e, info) {
                 *         alert("Column (" + info.newStatus + ")");
                 * });
                 */
                static EditorStatusChanged: string;
                /**
                 * Occurs when a cell is entering edit mode.
                 * @name GCTYPE.Spread.Sheets.Worksheet#EditStarting
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of cell.
                 * @param {number} col The column index of cell.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example creates log text for the EditStarting and EditEnded events.
                 * // Use IE to see the console log text
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.EditStarting, function (sender, args) {
                 *     console.log("Start cell editing.");
                 * });
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.EditEnded, function (sender, args) {
                 *     console.log("Finish cell editing.");
                 * });
                 */
                static EditStarting: string;
                /**
                 * Occurs when the focus enters a cell.
                 * @name GCTYPE.Spread.Sheets.Worksheet#EnterCell
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of the cell being entered.
                 * @param {number} col The column index of the cell being entered.
                 * @example
                 * //This example uses the EnterCell event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.EnterCell, function (e, info) {
                 *         alert("Cell (" + info.row + ", " + info.col +")");
                 * });
                 */
                static EnterCell: string;
                /**
                 * Occurs when any floating object has changed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#FloatingObjectsChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} floatingObject The floating object that triggered the event.
                 * @param {string} propertyName The name of the floating object's property that has changed.
                 * @example
                 * //This example uses the FloatingObjectChanged event.
                 * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                 * var btn = document.createElement('button');
                 * btn.style.width = "60px";
                 * btn.style.height = "30px";
                 * btn.innerText = "button";
                 * customFloatingObject.content(btn);
                 * activeSheet.floatingObjects.add(customFloatingObject);
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.FloatingObjectChanged, function (e, info) {
                 *        alert("changed");
                 * });
                 */
                static FloatingObjectChanged: string;
                /**
                 * Occurs when the custom floating object content is loaded.
                 * @name GCTYPE.Spread.Sheets.Worksheet#FloatingObjectLoaded
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} floatingObject The custom floating object that triggered the event.
                 * @param {HTMLElement} element The HTMLElement of the custom floating object.
                 */
                static FloatingObjectLoaded: string;
                /**
                 * Occurs when the user has removed the floating object.
                 * @name GCTYPE.Spread.Sheets.Worksheet#FloatingObjectRemoved
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} floatingObject The floating object has been removed.
                 * @example
                 * //This example uses the FloatingObjectRemoved event.
                 * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                 * var btn = document.createElement('button');
                 * btn.style.width = "60px";
                 * btn.style.height = "30px";
                 * btn.innerText = "button";
                 * customFloatingObject.content(btn);
                 * activeSheet.floatingObjects.add(customFloatingObject);
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.FloatingObjectRemoved, function (e, info) {
                 *         alert(info.sheetName);
                 * });
                 */
                static FloatingObjectRemoved: string;
                /**
                 * Occurs when the user is removing any floating object.
                 * @name GCTYPE.Spread.Sheets.Worksheet#FloatingObjectRemoving
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} floatingObject The floating object is being removed.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the FloatingObjectRemoving event.
                 * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                 * var btn = document.createElement('button');
                 * btn.style.width = "60px";
                 * btn.style.height = "30px";
                 * btn.innerText = "button";
                 * customFloatingObject.content(btn);
                 * activeSheet.floatingObjects.add(customFloatingObject);
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.FloatingObjectRemoving, function (e, info) {
                 *         info.cancel = true;
                 * });
                 */
                static FloatingObjectRemoving: string;
                /**
                 * Occurs when the selections of the floating object have changed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#FloatingObjectsSelectionChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} floatingObject The floating object that triggered the event.
                 * @example
                 * //This example uses the FloatingObjectSelectionChanged event.
                 * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                 * var btn = document.createElement('button');
                 * btn.style.width = "60px";
                 * btn.style.height = "30px";
                 * btn.innerText = "button";
                 * customFloatingObject.content(btn);
                 * activeSheet.floatingObjects.add(customFloatingObject);
                 * // Use IE to see the console log text
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.FloatingObjectSelectionChanged, function (e, info) {
                 *        console.log("sheet name: " + info.sheetName);
                 * });
                 */
                static FloatingObjectSelectionChanged: string;
                /**
                 * Occurs when an invalid operation is performed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#InvalidOperation
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.InvalidOperationType} invalidType Indicates which operation was invalid.
                 * @param {string} message The description of the invalid operation.
                 * @example
                 * //This example uses the InvalidOperation event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.InvalidOperation, function (e, info) {
                 *         alert("Message (" + info.message + ")");
                 * });
                 */
                static InvalidOperation: string;
                /**
                 * Occurs when the focus leaves a cell.
                 * @name GCTYPE.Spread.Sheets.Worksheet#LeaveCell
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of the cell being left.
                 * @param {number} col The column index of the cell being left.
                 * @param {boolean} cancel Whether the operation should be canceled.
                 * @example
                 * //This example creates log text for the LeaveCell event.
                 * // Use IE to see the console log text
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.LeaveCell, function (sender, args) {
                 *     console.log("The column index before moving: " + args.col);
                 *     console.log("The row index before moving: " + args.row);
                 * });
                 */
                static LeaveCell: string;
                /**
                 * Occurs when the left column changes.
                 * @name GCTYPE.Spread.Sheets.Worksheet#LeftColumnChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} oldLeftCol The old left column index.
                 * @param {number} newLeftCol The new left column index.
                 * @example
                 * //This example synchronizes vertical and horizontal scrolling for sheet 1 and sheet 2.
                 * var sheet1 = spread.getSheet(0),
                 * sheet2 = spread.getSheet(1);
                 * sheet1.bind(GCTYPE.Spread.Sheets.Events.TopRowChanged, function (sender, args) {
                 *     //Set the displayed top row of sheet1 to sheet2 (vertical scroll synchronization).
                 *     sheet2.showRow(args.newTopRow, GCTYPE.Spread.Sheets.VerticalPosition.top);
                 * });
                 * sheet1.bind(GCTYPE.Spread.Sheets.Events.LeftColumnChanged, function (sender, args) {
                 *     //Set the displayed left column of sheet1 to sheet2 (Horizontal scroll synchronization).
                 *     sheet2.showColumn(args.newLeftCol, GCTYPE.Spread.Sheets.HorizontalPosition.left);
                 * });
                 */
                static LeftColumnChanged: string;
                /**
                 * Occurs when the outline column check status has changed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#OutlineColumnCheckStatusChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The outline column's change row index.
                 * @param {number} col The outline column's change col index.
                 * @param {boolean} status The outline column's change status
                 * @example
                 * //Removing the sparkline causes a change.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.OutlineColumnCheckStatusChanged, function (e, info) {
                 *      console.log("status: " + info.status);
                 * });
                 */
                static OutlineColumnCheckStatusChanged: string;
                /**
                 * Occurs when any picture has changed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#PictureChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.FloatingObjects.Picture} picture The picture that triggered the event.
                 * @param {string} propertyName The name of the picture's property that has changed.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.pictures.add("f2","Event.png",2,2,6,6);
                 * activeSheet.pictures.add("f1","tsoutline.png",3,0,6,6);
                 * // Use IE to see the console log text
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.PictureChanged, function (e, info) {
                 * console.log("Sheet: " + info.sheetName);
                 * });
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.pictures.add("f2","Event.png",2,2,6,6);
                 * activeSheet.pictures.add("f1","tsoutline.png",3,0,6,6);
                 * // Use IE to see the console log text
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.PictureChanged, function (e, info) {
                 * console.log("Property: " + info.propertyName);
                 * });
                 */
                static PictureChanged: string;
                /**
                 * Occurs when the selections of the picture have changed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#PictureSelectionChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.FloatingObjects.Picture} picture The picture that triggered the event.
                 * @example
                 * //This example uses the PictureSelectionChanged event.
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var activeSheet = spread.getActiveSheet();
                 * activeSheet.pictures.add("f2","Event.png",2,2,6,6);
                 * activeSheet.pictures.add("f1","tsoutline.png",3,0,6,6);
                 * // Use IE to see the console log text
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.PictureSelectionChanged, function (e, info) {
                 * console.log("Sheet: " + info.sheetName);
                 * });
                 */
                static PictureSelectionChanged: string;
                /**
                 * After PivotTable filter/sort/collapse/fieldChanged.
                 * @name GCTYPE.Spread.Sheets.Worksheet#PivotTableChanged
                 * @event
                 * @param {string} pivotTableName The PivotTable's name.
                 * @param {string} type The specific operation name("filter" | "sort" | "collapse" | "fieldChanged" | "summarizedValueBy" | "showValueAs" | "dataPositionChanged" | "viewChanged").
                 * @param {string} [fieldName] Changed fieldName.
                 * @param {boolean} [oldValue] PivotTable changes the value of the previous attribute(collapse, summarizedValueBy, showValueAs).
                 * @param {boolean} [newValue] PivotTable changes the value of the previous attribute(collapse, summarizedValueBy, showValueAs).
                 * @param {number} [sortType] PivotTable sort changes the value of the attribute(sort).
                 * @param {Object} [filterInfo] PivotTable filter changes the value of the attribute(filter).
                 * @param {number} [clearType] PivotTable clear filter changes the value of the attribute(filter).
                 * @param {number} [oldArea] Old PivotTable Field Type(fieldChanged).
                 * @param {number} [oldIndex] Old PivotTable Field index(fieldChanged).
                 * @param {number} [newArea] New PivotTable Field Type(fieldChanged).
                 * @param {number} [newIndex] New PivotTable Field index(fieldChanged).
                 * @param {string} [viewName] Apply PivotTable Views Name(viewChanged).
                 * @example
                 * //This example.
                 * sheet.bind(GCTYPE.Spread.Sheets.Events.PivotTableChanged, function (sender, args) {
                 *     alert("pivotTableName: " + args.pivotTableName + "changeType: " + args.type);
                 * });
                 */
                static PivotTableChanged: string;
                /**
                 * Occurs when the cell range has changed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#RangeChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The range's row index.
                 * @param {number} col The range's column index.
                 * @param {number} rowCount The range's row count.
                 * @param {number} colCount The range's column count.
                 * @param {Array.<string>} tableNames A collection of table names.
                 * @param {Array.<Object>} changedCells The positions of the cells whose data has changed, each position has row and col.
                 * @param {GCTYPE.Spread.Sheets.RangeChangedAction} action The type of action that raises the RangeChanged event.
                 * @param {boolean} isUndo Whether this event is from a undo operation.
                 * @example
                 * //This example returns the sheet name and action when changing the cell range in Microsoft Internet Explorer.
                 *  activeSheet.bind(GCTYPE.Spread.Sheets.Events.RangeChanged, function (sender, args) {
                 *   console.log(args.sheetName, args.action);
                 * });
                 */
                static RangeChanged: string;
                /**
                 * Occurs when a range column has just been clear filtered.
                 * @name GCTYPE.Spread.Sheets.Worksheet#RangeFilterCleared
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} col The index of the sheet column has just been clear filtered.
                 * @example
                 * //This example uses the RangeFilterCleared event.
                 * activeSheet.getCell(0,0).text("Name");
                 * activeSheet.getCell(0,1).text("Value");
                 * activeSheet.getCell(0,2).text("T/F");
                 * activeSheet.getCell(1,0).text("AW");
                 * activeSheet.getCell(1,1).text("5");
                 * activeSheet.getCell(1,2).text("T");
                 * var cellRange =new GCTYPE.Spread.Sheets.Range(0, 0, 5, 1);
                 * var hideRowFilter =new GCTYPE.Spread.Sheets.Filter.HideRowFilter(cellRange);
                 * activeSheet.rowFilter(hideRowFilter);
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.RangeFilterCleared, function (e, info) {
                 *         alert("Col (" + info.col + ")");
                 * });
                 */
                static RangeFilterCleared: string;
                /**
                 * Occurs when a range column is about to be automatically clear filter.
                 * @name GCTYPE.Spread.Sheets.Worksheet#RangeFilterClearing
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} col The index of the sheet column to be automatically clear filter.
                 * @example
                 * //This example uses the RangeFilterClearing event.
                 * activeSheet.getCell(0,0).text("Name");
                 * activeSheet.getCell(0,1).text("Value");
                 * activeSheet.getCell(0,2).text("T/F");
                 * activeSheet.getCell(1,0).text("AW");
                 * activeSheet.getCell(1,1).text("5");
                 * activeSheet.getCell(1,2).text("T");
                 * var cellRange =new GCTYPE.Spread.Sheets.Range(0, 0, 5, 1);
                 * var hideRowFilter =new GCTYPE.Spread.Sheets.Filter.HideRowFilter(cellRange);
                 * activeSheet.rowFilter(hideRowFilter);
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.RangeFilterClearing, function (e, info) {
                 *         alert("Col (" + info.col + ")");
                 * });
                 */
                static RangeFilterClearing: string;
                /**
                 * Occurs when a column has just been automatically filtered.
                 * @name GCTYPE.Spread.Sheets.Worksheet#RangeFiltered
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} col The index of the column that was automatically filtered.
                 * @param {Array} filterValues The values by which the column was filtered.
                 * @param {Array} conditionInfo The condition rule info that which the column was filtered.
                 * @example
                 * //This example uses the RangeFiltered event.
                 * var cellrange =new GCTYPE.Spread.Sheets.Range(0, 2, 5, 1);
                 * var hideRowFilter =new GCTYPE.Spread.Sheets.Filter.HideRowFilter(cellrange);
                 * activeSheet.rowFilter(hideRowFilter);
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.RangeFiltered, function (e, info) {
                 *         alert("Col (" + info.col + ")");
                 * });
                 */
                static RangeFiltered: string;
                /**
                 * Occurs when a column is about to be automatically filtered.
                 * @name GCTYPE.Spread.Sheets.Worksheet#RangeFiltering
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} col The index of the column to be automatically filtered.
                 * @param {Array} filterValues The values by which to filter the column.
                 * @param {Object} conditionInfo The condition rule info by which to filter the column.
                 * @example
                 * //This example uses the RangeFiltering event.
                 * var cellrange =new GCTYPE.Spread.Sheets.Range(0, 2, 5, 1);
                 * var hideRowFilter =new GCTYPE.Spread.Sheets.Filter.HideRowFilter(cellrange);
                 * activeSheet.rowFilter(hideRowFilter);
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.RangeFiltering, function (e, info) {
                 *        alert("Col (" + info.col + ")");
                 * });
                 */
                static RangeFiltering: string;
                /**
                 * Occurs when the user has changed the outline state (range group) for rows or columns.
                 * @name GCTYPE.Spread.Sheets.Worksheet#RangeGroupStateChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {boolean} isRowGroup Whether the outline (range group) is a group of rows.
                 * @param {number} index The index of the RangeGroupInfo object whose state has changed.
                 * @param {number} level The level of the RangeGroupInfo object whose state has changed.
                 * @example
                 * //This example uses the RangeGroupStateChanged event.
                 * activeSheet.suspendPaint();
                 * activeSheet.setRowCount(34);
                 * activeSheet.setValue(0,0,"Western");
                 * activeSheet.setValue(0,1,"Western");
                 * activeSheet.setValue(0,2,"Western");
                 * activeSheet.setValue(1,0,"A");
                 * activeSheet.setValue(1,1,"B");
                 * activeSheet.setValue(1,2,"C");
                 * activeSheet.setValue(2,0,"A");
                 * activeSheet.setValue(2,1,"B");
                 * activeSheet.setValue(2,2,"C");
                 * activeSheet.rowOutlines.group(0,2);
                 * activeSheet.columnOutlines.group(0,1);
                 * activeSheet.resumePaint();
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.RangeGroupStateChanged, function (e, info) {
                 *         alert("Level (" + info.level + ")");
                 * });
                 */
                static RangeGroupStateChanged: string;
                /**
                 * Occurs before the user changes the outline state (range group) for rows or columns.
                 * @name GCTYPE.Spread.Sheets.Worksheet#RangeGroupStateChanging
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {boolean} isRowGroup Whether the outline (range group) is a group of rows.
                 * @param {number} index The index of the RangeGroupInfo object whose state is changing.
                 * @param {number} level The level of the RangeGroupInfo object whose state is changing.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the RangeGroupStateChanging event.
                 * activeSheet.suspendPaint();
                 * activeSheet.setRowCount(34);
                 * activeSheet.setValue(0,0,"Western");
                 * activeSheet.setValue(0,1,"Western");
                 * activeSheet.setValue(0,2,"Western");
                 * activeSheet.setValue(1,0,"A");
                 * activeSheet.setValue(1,1,"B");
                 * activeSheet.setValue(1,2,"C");
                 * activeSheet.setValue(2,0,"A");
                 * activeSheet.setValue(2,1,"B");
                 * activeSheet.setValue(2,2,"C");
                 * activeSheet.rowOutlines.group(0,2);
                 * activeSheet.columnOutlines.group(0,1);
                 * activeSheet.resumePaint();
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.RangeGroupStateChanging, function (e, info) {
                 *         alert("Level (" + info.level + ")");
                 * });
                 */
                static RangeGroupStateChanging: string;
                /**
                 * Occurs when a column has just been automatically sorted.
                 * @name GCTYPE.Spread.Sheets.Worksheet#RangeSorted
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} col The index of the column that was automatically sorted.
                 * @param {boolean} ascending Whether the automatic sort is ascending.
                 * @example
                 * //This example uses the RangeSorted event.
                 * activeSheet.setValue(0, 0, 10);
                 * activeSheet.setValue(1, 0, 100);
                 * activeSheet.setValue(2, 0, 50);
                 * activeSheet.setValue(3, 0, 40);
                 * activeSheet.setValue(4, 0, 80);
                 * activeSheet.setValue(5, 0, 1);
                 * activeSheet.setValue(6, 0, 65);
                 * activeSheet.setValue(7, 0, 20);
                 * activeSheet.setValue(8, 0, 30);
                 * activeSheet.setValue(9, 0, 35);
                 * var cellrange =new GCTYPE.Spread.Sheets.Range(0, 0, 5, 1);
                 * var hideRowFilter =new GCTYPE.Spread.Sheets.Filter.HideRowFilter(cellrange);
                 * activeSheet.rowFilter(hideRowFilter);
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.RangeSorted, function (e, info) {
                 *         alert("Col (" + info.col + ", " + info.ascending +")");
                 * });
                 */
                static RangeSorted: string;
                /**
                 * Occurs when a column is about to be automatically sorted.
                 * @name GCTYPE.Spread.Sheets.Worksheet#RangeSorting
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} col The index of the column to be automatically sorted.
                 * @param {boolean} ascending Whether the automatic sort is ascending.
                 * @param {boolean} cancel Whether the operation should be canceled.
                 * @param {GCTYPE.Spread.Sheets.Range} range The range of automatic sort.
                 * @param {GroupSort} groupSort The groupSort level to use when sorting, default will use group level if contains group and use flat level if not contains group.
                 * @param {boolean} ignoreHidden Whether to ignore the hidden values and only sort visible values.
                 * @param {Function} compareFunction The customize function to use when sorting, used when value sort. function (value1, value2) {return 0;}<br />
                 *
                 * @example
                 * //This example uses the RangeSorting event.
                 * activeSheet.setValue(0, 0, 10);
                 * activeSheet.setValue(1, 0, 100);
                 * activeSheet.setValue(2, 0, 50);
                 * activeSheet.setValue(3, 0, 40);
                 * activeSheet.setValue(4, 0, 80);
                 * activeSheet.setValue(5, 0, 1);
                 * activeSheet.setValue(6, 0, 65);
                 * activeSheet.setValue(7, 0, 20);
                 * activeSheet.setValue(8, 0, 30);
                 * activeSheet.setValue(9, 0, 35);
                 * var cellrange =new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1);
                 * var hideRowFilter =new GCTYPE.Spread.Sheets.Filter.HideRowFilter(cellrange);
                 * activeSheet.rowFilter(hideRowFilter);
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.RangeSorting, function (e, info) {
                 *         alert("Col (" + info.col + ", " + info.ascending +")");
                 *         info.groupSort = GCTYPE.Spread.Sheets.GroupSort.full; //use full level sort.
                 *         info.ignoreHidden = false; // sort with the hidden values.
                 *         info.compareFunction = (obj1, obj2)=>{return obj1.toString().localeCompare(obj2.toString())};
                 * });
                 */
                static RangeSorting: string;
                /**
                 * Occurs when a change is made to a row or range of rows in this sheet that may require the row or range of rows to be repainted.
                 * @name GCTYPE.Spread.Sheets.Worksheet#RowChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheetArea of the row.
                 * @param {string} propertyName The name of the row's property that has changed.
                 * @param {boolean} isUndo Whether this event is from a undo operation.
                 * @example
                 * //This example uses the RowChanged event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.RowChanged, function (e, info) {
                 *         alert("Row (" + info.row + ")");
                 * });
                 */
                static RowChanged: string;
                /**
                 * Occurs when before a change is made to a row or range of rows in this sheet that may require the row or range of rows to be repainted.
                 * @name GCTYPE.Spread.Sheets.Worksheet#RowChanging
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheetArea of the row.
                 * @param {string} propertyName The name of the row's property that has changed.
                 * @example
                 * //This example uses the RowChanging event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.RowChanging, function (e, info) {
                 *         alert("Row (" + info.row + ")");
                 * });
                 */
                static RowChanging: string;
                /**
                 * Occurs when the row height has changed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#RowHeightChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {Array} rowList The list of rows whose heights have changed.
                 * @param {boolean} header Whether the columns are column header columns.
                 * @example
                 * //This example uses the RowHeightChanged event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.RowHeightChanged, function (e, info) {
                 *         alert("Row List (" + info.rowList + ")");
                 * });
                 */
                static RowHeightChanged: string;
                /**
                 * Occurs when the row height is changing.
                 * @name GCTYPE.Spread.Sheets.Worksheet#RowHeightChanging
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {Array} rowList The list of rows whose heights are changing.
                 * @param {boolean} header Whether the columns are column header columns.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the RowHeightChanging event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.RowHeightChanging, function (e, info) {
                 *         alert("Row List (" + info.rowList + ")");
                 * });
                 */
                static RowHeightChanging: string;
                /**
                 * Occurs when the applied row action is operated.
                 * @name GCTYPE.Spread.Sheets.TableSheet.TableSheet#RowOperation
                 * @event
                 * @param {GCTYPE.Spread.Sheets.TableSheet.TableSheet} sheet The table sheet that triggered the event.
                 * @param {string} sheetName The table sheet's name.
                 * @param {GCTYPE.Spread.Sheets.TableSheet.ActionType} actionType The row action type.
                 * @param {number} row The row index.
                 * @example
                 * //This example uses the RowOperation event.
                 * workbook.bind(GCTYPE.Spread.Sheets.Events.RowOperation, function (e, info) {
                 *     console.log(info.sheetName, info.actionType, info.row);
                 * });
                 */
                static RowOperation: string;
                /**
                 * Occurs when the selection of cells on the sheet has changed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#SelectionChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {Array.<GCTYPE.Spread.Sheets.Range>} oldSelections The old selection ranges.
                 * @param {Array.<GCTYPE.Spread.Sheets.Range>} newSelections The new selection ranges.
                 * @example
                 * //This example uses the SelectionChanged event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.SelectionChanged, function (e, info) {
                 *         alert("Name (" + info.sheetName + ")");
                 * });
                 */
                static SelectionChanged: string;
                /**
                 * Occurs when the selection of cells on the sheet is changing.
                 * @name GCTYPE.Spread.Sheets.Worksheet#SelectionChanging
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {Array.<GCTYPE.Spread.Sheets.Range>} oldSelections The old selection ranges.
                 * @param {Array.<GCTYPE.Spread.Sheets.Range>} newSelections The new selection ranges.
                 * @example
                 * //This example uses the SelectionChanging event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.SelectionChanging, function (e, info) {
                 * //Use IE to see console
                 *         console.log("Name (" + info.sheetName + ")");
                 * });
                 */
                static SelectionChanging: string;
                /**
                 * Occurs when any shape has changed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#ShapeChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Shapes.Shape} shape The shape that triggered the event.
                 * @param {string} propertyName The name of the shape's property that has changed.
                 * @example
                 * //This example uses the ShapeChanged event.
                 * var shape1 = activeSheet.shapes.add("shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.rectangle, 20, 20, 200, 200);
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ShapeChanged, function (e, info) {
                 *        alert("changed");
                 * });
                 */
                static ShapeChanged: string;
                /**
                 * Occurs when the user has removed the shape.
                 * @name GCTYPE.Spread.Sheets.Worksheet#ShapeRemoved
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Shapes.Shape} shape The shape has been removed.
                 * @example
                 * //This example uses the ShapeRemoved event.
                 * var shape = activeSheet.shapes.add("myShape", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.diamond, 0, 90, 200, 200);
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ShapeRemoved, function (e, info) {
                 *         alert(info.shape.name());
                 * });
                 */
                static ShapeRemoved: string;
                /**
                 * Occurs when the user is removing any shape.
                 * @name GCTYPE.Spread.Sheets.Worksheet#ShapeRemoving
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Shapes.Shape} shape The shape is being removed.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the ShapeRemoving event.
                 * var shape = sheet.shapes.add("myShape", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.diamond, 0, 90, 200, 200);
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ShapeRemoving, function (e, info) {
                 *         info.cancel = true;// the shape will not remove
                 * });
                 */
                static ShapeRemoving: string;
                /**
                 * Occurs when the selections of the shape have changed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#ShapeSelectionChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Shapes.Shape} shape The shape that triggered the event.
                 * @example
                 * //This example uses the ShapeSelectionChanged event.
                 * var shape = sheet.shapes.add("myShape", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.diamond, 0, 90, 200, 200);
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ShapeSelectionChanged, function (e, info) {
                 *        console.log("event info: " + info);
                 * });
                 */
                static ShapeSelectionChanged: string;
                /**
                 * After sheet changed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#SheetChanged
                 * @event
                 * @param {string} sheetName The sheet's name.
                 * @param {string} propertyName The specific operation name.
                 * @param {number} sheetIndex Change the sheet position.
                 * @param {boolean} oldValue: Sheet changes the value of the previous attribute(isVisible, isSelected...).
                 * @param {boolean} newValue: Sheet changes the value of the attribute(isVisible, isSelected...).
                 * @example
                 * //This example.
                 * spread.bind(GCTYPE.Spread.Sheets.Events.SheetChanged, function (sender, args) {
                 *     var sheet = args.sheet;
                 * });
                 */
                static SheetChanged: string;
                /**
                 * Before sheet changed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#SheetChanging
                 * @event
                 * @param {string} sheetName The sheet's name.
                 * @param {string} propertyName The specific operation name .
                 * @param {number} sheetIndex Change the sheet position.
                 * @param {boolean} oldValue: Sheet changes the value of the previous attribute(isVisible, isSelected...).
                 * @param {boolean} newValue: Sheet changes the value of the attribute(isVisible, isSelected...).
                 * @param {boolean} cancel Cancel the current operation.
                 * @example
                 * //This example.
                 * spread.bind(GCTYPE.Spread.Sheets.Events.SheetChanging, function (sender, args) {
                 *     var sheetIndex = args.sheetIndex;
                 *     args.cancel = true;
                 * });
                 */
                static SheetChanging: string;
                /**
                 * Occurs after the user drags and moves the sheet.
                 * @name GCTYPE.Spread.Sheets.Worksheet#SheetMoved
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} oldIndex The previous sheet index.
                 * @param {number} newIndex The new sheet index.
                 * @example
                 * //This example uses the SheetMoved event.
                 * window.onload = function(){
                 *      var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 *      var activeSheet = spread.getActiveSheet();
                 *      spread.bind(GCTYPE.Spread.Sheets.Events.SheetMoving, function (e, data) {
                 *          alert(data.sheetName + '\n' +  'oldIndex: ' + data.oldIndex + '\n' +  'newIndex: ' + data.newIndex + '\n' +  'cancel: ' + data.cancel);
                 *      });
                 *      spread.bind(GCTYPE.Spread.Sheets.Events.SheetMoved, function (e, data) {
                 *          alert(data.sheetName + '\n' +  'oldIndex: ' + data.oldIndex + '\n' +  'newIndex: ' + data.newIndex);
                 *      });
                 * }
                 */
                static SheetMoved: string;
                /**
                 * Occurs before the user drags and moves the sheet.
                 * @name GCTYPE.Spread.Sheets.Worksheet#SheetMoving
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} oldIndex The old sheet index.
                 * @param {number} newIndex A value that indicates the index will be moved to.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the SheetMoving event.
                 * window.onload = function(){
                 *      var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 *      var activeSheet = spread.getActiveSheet();
                 *      spread.bind(GCTYPE.Spread.Sheets.Events.SheetMoving, function (e, data) {
                 *          alert(data.sheetName + '\n' +  'oldIndex: ' + data.oldIndex + '\n' +  'newIndex: ' + data.newIndex + '\n' +  'cancel: ' + data.cancel);
                 *      });
                 *      spread.bind(GCTYPE.Spread.Sheets.Events.SheetMoved, function (e, data) {
                 *          alert(data.sheetName + '\n' +  'oldIndex: ' + data.oldIndex + '\n' +  'newIndex: ' + data.newIndex);
                 *      });
                 * }
                 */
                static SheetMoving: string;
                /**
                 * Occurs when the user has changed the sheet name.
                 * @name GCTYPE.Spread.Sheets.Worksheet#SheetNameChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} oldValue The sheet's old name.
                 * @param {string} newValue The sheet's new name.
                 * @example
                 * //This example uses the SheetNameChanged event.
                 * // Use IE to see the console log text
                 * spread.bind(GCTYPE.Spread.Sheets.Events.SheetNameChanging, function (sender, args) {
                 *    console.log(args.oldValue);
                 * });
                 * spread.bind(GCTYPE.Spread.Sheets.Events.SheetNameChanged, function (sender, args) {
                 *    console.log(args.newValue);
                 * });
                 */
                static SheetNameChanged: string;
                /**
                 * Occurs when the user is changing the sheet name.
                 * @name GCTYPE.Spread.Sheets.Worksheet#SheetNameChanging
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} oldValue The sheet's old name.
                 * @param {string} newValue The sheet's new name.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the SheetNameChanging event.
                 * // Use IE to see the console log text
                 * spread.bind(GCTYPE.Spread.Sheets.Events.SheetNameChanging, function (sender, args) {
                 *    console.log(args.oldValue);
                 * });
                 * spread.bind(GCTYPE.Spread.Sheets.Events.SheetNameChanged, function (sender, args) {
                 *    console.log(args.newValue);
                 * });
                 */
                static SheetNameChanging: string;
                /**
                 * Occurs when the user clicks the sheet tab.
                 * @name GCTYPE.Spread.Sheets.Worksheet#SheetTabClick
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} sheetTabIndex The index of the sheet tab that the user clicked.
                 * @example
                 * //This example uses the SheetTabClick event.
                 * spread.bind(GCTYPE.Spread.Sheets.Events.SheetTabClick, function (e, info) {
                 *         alert("Index (" + info.sheetTabIndex + ")");
                 * });
                 */
                static SheetTabClick: string;
                /**
                 * Occurs when the user double-clicks the sheet tab.
                 * @name GCTYPE.Spread.Sheets.Worksheet#SheetTabDoubleClick
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} sheetTabIndex The index of the sheet tab that the user double-clicked.
                 * @example
                 * //This example uses the SheetTabDoubleClick event.
                 * spread.bind(GCTYPE.Spread.Sheets.Events.SheetTabDoubleClick, function (e, info) {
                 *         alert("Index (" + info.sheetTabIndex + ")");
                 * });
                 */
                static SheetTabDoubleClick: string;
                /**
                 * Occurs when any slicer has changed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#SlicerChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Slicers.Slicer} slicer The slicer that triggered the event.
                 * @param {string} propertyName The name of the slicer's property that has changed.
                 * @example
                 * //This example uses the SlicerChanged event.
                 * //create a table
                 * datas = [
                 *     ["1", "NewYork", "1968/6/8", "80", "180"],
                 *     ["4", "NewYork", "1972/7/3", "72", "168"],
                 *     ["4", "NewYork", "1964/3/2", "71", "179"],
                 *     ["5", "Washington", "1972/8/8","80", "171"],
                 *     ["6", "Washington", "1986/2/2", "89", "161"],
                 *     ["7", "Washington", "2012/2/15", "71", "240"]];
                 * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                 * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                 * table.setColumnName(0, dataColumns[0]);
                 * table.setColumnName(1, dataColumns[1]);
                 * table.setColumnName(2, dataColumns[2]);
                 * table.setColumnName(3, dataColumns[3]);
                 * table.setColumnName(4, dataColumns[4]);
                 * //add a slicer to the sheet and return the slicer instance.
                 * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                 * //change the slicer properties.
                 * slicer.width(200);
                 * slicer.height(200);
                 * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                 * slicer.style(GCTYPE.Spread.Sheets.Slicers.SlicerStyles.dark4());
                 * // Use IE to see the console log text
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.SlicerChanged, function (e, info) {
                 * console.log("name: " + info.propertyName);
                 * });
                 */
                static SlicerChanged: string;
                /**
                 * Occurs when the sparkline has changed.
                 * @name GCTYPE.Spread.Sheets.Worksheet#SparklineChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Sparklines.Sparkline} sparkline The sparkline whose property has changed.
                 * @example
                 * //Removing the sparkline causes a change.
                 * var data = new GCTYPE.Spread.Sheets.Range(1, 0, 8, 1);
                 * var setting = new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting();
                 * setting.options.showMarkers = true;
                 * setting.options.lineWeight = 3;
                 * setting.options.displayXAxis = true;
                 * setting.options.showFirst = true;
                 * setting.options.showLast = true;
                 * setting.options.showLow = true;
                 * setting.options.showHigh = true;
                 * setting.options.showNegative = true;
                 * setting.options.seriesColor = "Text 2 1";
                 * setting.options.firstMarkerColor = "Text 2 3";
                 * setting.options.negativeColor = "Accent 2 1";
                 * setting.options.markersColor = "Accent 3 1";
                 * setting.options.lowMarkerColor = "Accent 4 1";
                 * setting.options.highMarkerColor = "Accent 6 1";
                 * setting.options.lastMarkerColor = "Accent 6 6";
                 * setting.options.axisColor = "Text 1 1";
                 * activeSheet.addSpan(13, 0, 4, 3, null);
                 * activeSheet.setSparkline(13, 0, data, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 * // Use IE to see the console log text
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.SparklineChanged, function (e, info) {
                 *      console.log("name: " + info.sheetName);
                 * });
                 * $("#button1").click(function () {
                 *      activeSheet.removeSparkline(13, 0);
                 * });
                 */
                static SparklineChanged: string;
                /**
                 * Occurs when the user insert/delete columns in table.
                 * @name GCTYPE.Spread.Sheets.Worksheet#TableColumnsChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {Table} table The table which is insert/delete rows.
                 * @param {string} propertyName The operation name which trigger event.
                 * @param {number} col The index of the starting column to insert/delete based on table index.
                 * @param {number} count The number of columns to insert/delete.
                 * @param {boolean} isAfter Whether insert columns before the specified column index or after. By default is false, insert before.
                 * @example
                 * //This example uses the TableColumnsChanged event.
                 * window.onload = function(){
                 *      var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                 *      var activeSheet = spread.getActiveSheet();
                 *      spread.bind(GCTYPE.Spread.Sheets.Events.TableColumnsChanged, function (e, data) {});
                 * }
                 */
                static TableColumnsChanged: string;
                /**
                 * Occurs when a table column has just been clear filter.
                 * @name GCTYPE.Spread.Sheets.Worksheet#TableFilterCleared
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Tables.Table} table The table column to be automatically filtered.
                 * @param {number} tableCol The index of the table column has just been clear filter.
                 * @example
                 * //This example uses the TableFilterCleared event.
                 * activeSheet.tables.add("Table1", 0, 0, 3, 3, GCTYPE.Spread.Sheets.Tables.TableTheme.dark1);
                 * activeSheet.getCell(0,0).text("Name");
                 * activeSheet.getCell(0,1).text("Value");
                 * activeSheet.getCell(0,2).text("T/F");
                 * activeSheet.getCell(1,0).text("AW");
                 * activeSheet.getCell(1,1).text("5");
                 * activeSheet.getCell(1,2).text("T");
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.TableFilterCleared, function (e, info) {
                 *        alert("Sheet (" + info.sheetName + ")");
                 * });
                 */
                static TableFilterCleared: string;
                /**
                 * Occurs when a table column is about to be automatically clear filter.
                 * @name GCTYPE.Spread.Sheets.Worksheet#TableFilterCleared
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Tables.Table} table The table column to be automatically filtered.
                 * @param {number} tableCol The index of the table column to be automatically clear filter.
                 * @example
                 * //This example uses the TableFilterClearing event.
                 * activeSheet.tables.add("Table1", 0, 0, 3, 3, GCTYPE.Spread.Sheets.Tables.TableTheme.dark1);
                 * activeSheet.getCell(0,0).text("Name");
                 * activeSheet.getCell(0,1).text("Value");
                 * activeSheet.getCell(0,2).text("T/F");
                 * activeSheet.getCell(1,0).text("AW");
                 * activeSheet.getCell(1,1).text("5");
                 * activeSheet.getCell(1,2).text("T");
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.TableFilterClearing, function (e, info) {
                 *        alert("Sheet (" + info.sheetName + ")");
                 * });
                 */
                static TableFilterClearing: string;
                /**
                 * Occurs when a table column has just been automatically filtered.
                 * @name GCTYPE.Spread.Sheets.Worksheet#TableFiltered
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Tables.Table} table The table column to be automatically filtered.
                 * @param {number} col The index of the table column to be automatically filtered.
                 * @param {Array} filterValues The values by which to filter the column.
                 * @param {Object} conditionInfo The condition rule info by which to filter the column.
                 * @example
                 * //This example uses the TableFiltered event.
                 * activeSheet.tables.add("Table1", 0, 0, 3, 3, GCTYPE.Spread.Sheets.Tables.TableTheme.dark1);
                 * activeSheet.getCell(0,0).text("Name");
                 * activeSheet.getCell(0,1).text("Value");
                 * activeSheet.getCell(0,2).text("T/F");
                 * activeSheet.getCell(1,0).text("AW");
                 * activeSheet.getCell(1,1).text("5");
                 * activeSheet.getCell(1,2).text("T");
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.TableFiltered, function (e, info) {
                 *        alert("Sheet (" + info.sheetName + ")");
                 * });
                 */
                static TableFiltered: string;
                /**
                 * Occurs when a table column is about to be automatically filtered.
                 * @name GCTYPE.Spread.Sheets.Worksheet#TableFiltering
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {GCTYPE.Spread.Sheets.Tables.Table} table The table column to be automatically filtered.
                 * @param {number} col The index of the table column to be automatically filtered.
                 * @param {Array} filterValues The values by which to filter the column.
                 * @param {Object} conditionInfo The condition rule info by which to filter the column.
                 * @example
                 * //This example uses the TableFiltering event.
                 * activeSheet.tables.add("Table1", 0, 0, 3, 3, GCTYPE.Spread.Sheets.Tables.TableTheme.dark1);
                 * activeSheet.getCell(0,0).text("Name");
                 * activeSheet.getCell(0,1).text("Value");
                 * activeSheet.getCell(0,2).text("T/F");
                 * activeSheet.getCell(1,0).text("AW");
                 * activeSheet.getCell(1,1).text("5");
                 * activeSheet.getCell(1,2).text("T");
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.TableFiltering, function (e, info) {
                 *        alert("Sheet (" + info.sheetName + ")");
                 * });
                 */
                static TableFiltering: string;
                /**
                 * Occurs after the user resized table.
                 * @name GCTYPE.Spread.Sheets.Worksheet#TableResized
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {Table} table The table which is resized.
                 * @param {GCTYPE.Spread.Sheets.Range} oldRange The table range before resize.
                 * @param {GCTYPE.Spread.Sheets.Range} newRange The table range after resize.
                 */
                static TableResized: string;
                /**
                 * Occurs when the user resizing table by resize handler.
                 * @name GCTYPE.Spread.Sheets.Worksheet#TableResizing
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {Table} table The table which is resizing.
                 * @param {GCTYPE.Spread.Sheets.Range} oldRange The table range before resize.
                 * @param {GCTYPE.Spread.Sheets.Range} newRange The table range after resize.
                 * @example
                 * //This example uses the TableResizing and TableResized event.
                 * window.onload = function(){
                 *      var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                 *      var activeSheet = spread.getActiveSheet();
                 *      spread.bind(GCTYPE.Spread.Sheets.Events.TableResizing, function (e, data) {});
                 *      spread.bind(GCTYPE.Spread.Sheets.Events.TableResized, function (e, data) {});
                 * }
                 */
                static TableResizing: string;
                /**
                 * Occurs when the user insert/delete rows in table.
                 * @name GCTYPE.Spread.Sheets.Worksheet#TableRowsChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {Table} table The table which is insert/delete rows.
                 * @param {string} propertyName The operation name which trigger event.
                 * @param {number} row The index of the starting row to insert/delete based on table index.
                 * @param {number} count The number of rows to insert/delete.
                 * @param {boolean} isAfter Whether insert rows before the specified row index or after. By default is false, insert before.
                 * @param {Array.<Object>} deletedItem The deleted rows collection in binding. The every item in array specifies deleted data item.
                 * @example
                 * //This example uses the TableRowsChanged event.
                 * window.onload = function(){
                 *      var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                 *      var activeSheet = spread.getActiveSheet();
                 *      spread.bind(GCTYPE.Spread.Sheets.Events.TableRowsChanged, function (e, data) {});
                 * }
                 */
                static TableRowsChanged: string;
                /**
                 * Occurs when the top row changes.
                 * @name GCTYPE.Spread.Sheets.Worksheet#TopRowChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} oldTopRow The old top row index.
                 * @param {number} newTopRow The new top row index.
                 * @example
                 * //This example synchronizes vertical and horizontal scrolling for sheet 1 and sheet 2.
                 * var sheet1 = spread.getSheet(0),
                 * sheet2 = spread.getSheet(1);
                 * sheet1.bind(GCTYPE.Spread.Sheets.Events.TopRowChanged, function (sender, args) {
                 *     //Set the displayed top row of sheet1 to sheet2 (vertical scroll synchronization).
                 *     sheet2.showRow(args.newTopRow, GCTYPE.Spread.Sheets.VerticalPosition.top);
                 * });
                 * sheet1.bind(GCTYPE.Spread.Sheets.Events.LeftColumnChanged, function (sender, args) {
                 *     //Set the displayed left column of sheet1 to sheet2 (Horizontal scroll synchronization).
                 *     sheet2.showColumn(args.newLeftCol, GCTYPE.Spread.Sheets.HorizontalPosition.left);
                 * });
                 */
                static TopRowChanged: string;
                /**
                 * Occurs before the touch toolbar pops up.
                 * @name GCTYPE.Spread.Sheets.Worksheet#TouchToolStripOpening
                 * @event
                 * @param {number} x The <i>x</i>-coordinate of the horizontal position.
                 * @param {number} y The <i>y</i>-coordinate of the vertical position.
                 * @param {boolean} handled If <c>true</c>, the touch toolbar is prevented from popping up; otherwise, the toolbar is displayed at the default position.
                 * @example
                 * //This example uses the TouchToolStripOpening event.
                 *  activeSheet.bind(GCTYPE.Spread.Sheets.Events.TouchToolStripOpening, function (e, info) {
                 *         alert(info.x);
                 * });
                 */
                static TouchToolStripOpening: string;
                /**
                 * Occurs when the user types a formula.
                 * @name GCTYPE.Spread.Sheets.Worksheet#UserFormulaEntered
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of the cell in which the user entered a formula.
                 * @param {number} col The column index of the cell in which the user entered a formula.
                 * @param {string} formula The formula that the user entered.
                 * @param {boolean} isCircularReference The entered formula is circular reference.
                 * @example
                 * //This example uses the UserFormulaEntered event.
                 *  activeSheet.bind(GCTYPE.Spread.Sheets.Events.UserFormulaEntered, function (e, info) {
                 *         alert("Formula (" + info.formula + ")");
                 * });
                 */
                static UserFormulaEntered: string;
                /**
                 * Occurs when the applied cell value is invalid.
                 * @name GCTYPE.Spread.Sheets.Worksheet#ValidationError
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The cell's row index.
                 * @param {number} col The cell's column index.
                 * @param {GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} validator The data validator that caused the error.
                 * @param {GCTYPE.Spread.Sheets.DataValidation.DataValidationResult} validationResult The policy that the user can set to determine how to process the error.
                 * @example
                 * //This example uses the ValidationError event.
                 * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.cellValueCondition);
                 * nCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.equalsTo);
                 * nCondition.expected(0);
                 * //When the option is false, the validation fails and the red alert is displayed.
                 * //When the option is true, the blank cell is treated as zero and the validation is successful.
                 * nCondition.treatNullValueAsZero(false);
                 * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition)
                 * validator.ignoreBlank(false);
                 * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.wholeNumber)
                 * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                 * spread.options.highlightInvalidData = true;
                 * activeSheet.setValue(0, 0, null);
                 * //Type different values in cell (0,0). This event fires if the user types an invalid value.
                 * activeSheet.bind("ValidationError", vError);
                 * function vError(sender, args) {
                 *     alert("error");
                 * }
                 */
                static ValidationError: string;
                /**
                 * Occurs when the value in the subeditor changes.
                 * @name GCTYPE.Spread.Sheets.Worksheet#ValueChanged
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} row The row index of the cell.
                 * @param {number} col The column index of the cell.
                 * @param {Object} oldValue The old value of the cell.
                 * @param {Object} newValue The new value of the cell.
                 * @example
                 * //This example uses the ValueChanged event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ValueChanged, function (e, info) {
                 *         alert("Value (" + info.newValue + ")");
                 * });
                 */
                static ValueChanged: string;
                /**
                 * Occurs after the user zooms.
                 * @name GCTYPE.Spread.Sheets.Worksheet#ViewZoomed
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} newZoomFactor The new zoom factor.
                 * @param {number} oldZoomFactor The old zoom factor.
                 * @example
                 * //This example uses the ViewZoomed event.
                 * spread.options.allowUserZoom = true;
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ViewZoomed, function (e, info) {
                 *      alert("Zoom (" + info.newZoomFactor + ")");
                 * });
                 */
                static ViewZoomed: string;
                /**
                 * Occurs when the user zooms.
                 * @name GCTYPE.Spread.Sheets.Worksheet#ViewZooming
                 * @event
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet that triggered the event.
                 * @param {string} sheetName The sheet's name.
                 * @param {number} newZoomFactor The new zoom factor, user could make some change to intervene the real zoom action.
                 * @param {number} oldZoomFactor The old zoom factor.
                 * @param {boolean} cancel A value that indicates whether the operation should be canceled.
                 * @example
                 * //This example uses the ViewZooming event, to limit zooming max factor.
                 * spread.options.allowUserZoom = true;
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ViewZooming, function (e, info) {
                 *      if (info.newZoomFactor >= 2) {
                 *          info.newZoomFactor = 2;
                 *      }
                 * });
                 */
                static ViewZooming: string;
            }

            export class LineBorder{
                /**
                 * Represents the line border for a border side.
                 * @class
                 * @param {string} [color] Indicates the border color and uses a format such as color name (for example, "red") or "#RGB", "#RRGGBB", "rgb(R,B,B)", "rgba(R,G,B,A)".
                 * @param {GCTYPE.Spread.Sheets.LineStyle} [style] Indicates the border line style.
                 * @example
                 * //This example creates a border.
                 * var border = new GCTYPE.Spread.Sheets.LineBorder
                 * border.color = "#7FFFD4";
                 * border.style = GCTYPE.Spread.Sheets.LineStyle.double;
                 * var cell = activeSheet.getCell(1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * cell.borderLeft(border);
                 */
                constructor(color?: string,  style?: GCTYPE.Spread.Sheets.LineStyle);
                /**
                 * Indicates the color of the border line. Use a known color name or HEX style color value. The default value is black.
                 * @example
                 * //This example sets the color property.
                 * var border = new GCTYPE.Spread.Sheets.LineBorder
                 * border.color = "#7FFFD4";
                 * border.style = GCTYPE.Spread.Sheets.LineStyle.double;
                 * var cell = activeSheet.getCell(1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * cell.borderLeft(border);
                 */
                color: string;
                /**
                 * Indicates the line style of the border line. The default value is empty.
                 * @example
                 * //This example sets the style property.
                 * var border = new GCTYPE.Spread.Sheets.LineBorder
                 * border.color = "#7FFFD4";
                 * border.style = GCTYPE.Spread.Sheets.LineStyle.double;
                 * var cell = activeSheet.getCell(1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * cell.borderLeft(border);
                 */
                style: GCTYPE.Spread.Sheets.LineStyle;
            }

            export class NameInfo{
                /**
                 * Represents a custom named expression that can be used by formulas.
                 * @class
                 * @param {string} name The custom expression name.
                 * @param {GCTYPE.Spread.CalcEngine.Expression} expr The custom named expression.
                 * @param {number} row The base row of the expression.
                 * @param {number} column The base column of the expression.
                 * @param {string} [comment] The custom expression comment.
                 */
                constructor(name: string,  expr: GCTYPE.Spread.CalcEngine.Expression,  row: number,  column: number,  comment?: string);
                /**
                 * Gets the base column of the custom named expression.
                 * @returns {number} The base column.
                 */
                getColumn(): number;
                /**
                 * Gets the comment of the current NameInfo object.
                 * @returns {string} The name of the current NameInfo object.
                 */
                getComment(): string;
                /**
                 * Gets the expression.
                 * @returns {GCTYPE.Spread.CalcEngine.Expression} The expression.
                 */
                getExpression(): GCTYPE.Spread.CalcEngine.Expression;
                /**
                 * Gets the name of the current NameInfo object.
                 * @returns {string} The name of the current NameInfo object.
                 */
                getName(): string;
                /**
                 * Gets the base row of the custom named expression.
                 * @returns {number} The base row.
                 */
                getRow(): number;
            }

            export class PivotTableManager{
                /**
                 * Represents a pivot table manager which can manage all pivot tables in a sheet.
                 * @class
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The worksheet.
                 */
                constructor(sheet: GCTYPE.Spread.Sheets.Worksheet);
                /**
                 * @description Add a pivot table to current worksheet.
                 * @param {string} name Indicates the pivot table name, it should be unique in the whole workbook.
                 * @param {string} sourceData Indicates the sourceData is using for pivot table. It supports two types: a table name or the formula which references a range absolutely.
                 * @param {number} row Indicates the pivot table start row position.
                 * @param {number} col Indicates the pivot table start col position.
                 * @param {GCTYPE.Spread.Pivot.PivotTableLayoutType} layout Indicates the pivot table layout.
                 * @param {GCTYPE.Spread.Pivot.PivotTableTheme} theme Indicates the pivot table theme style.
                 * @param {Object} options Indicates the options of pivot table.
                 * @param {boolean} [options.allowMultipleFiltersPerField] Indicates whether use multiple filter in one field.
                 * @param {boolean} [options.insertBlankLineAfterEachItem] Indicates whether insert a blank row at end of each item.
                 * @param {GCTYPE.Spread.Pivot.GrandTotalPosition} [options.grandTotalPosition] Indicates whether show grandtotal in row, column or both.
                 * @param {GCTYPE.Spread.Pivot.SubtotalsPosition} [options.subTotalsPosition] Indicates show subtotal top or bottom or not show.
                 * @param {GCTYPE.Spread.Pivot.DisplayFields} [options.displayFieldsInPageFilterArea] Indicates the field display in page area show first over then down or first down then over.
                 * @param {number} [options.reportFilterFieldsPerColumn] Indicates the number of report filer field per column.
                 * @param {boolean} [options.bandRows] Indicates show band row or not.
                 * @param {boolean} [options.bandColumns] Indicates show band column or not.
                 * @param {boolean} [options.showRowHeader] Indicates show row header style or not.
                 * @param {boolean} [options.showColumnHeader] Indicates show column header style or not.
                 * @param {boolean} [options.showDrill] Indicates show expand/collapse button or not.
                 * @param {boolean} [options.showMissing] Indicates whether the missingCaption option is effected.
                 * @param {boolean} [options.missingCaption] Indicates what value should be shown when the actual value is empty
                 * @param {boolean} [options.fillDownLabels] Indicates show repeat label items or not.
                 * @param {boolean} [options.rowLabelIndent] Indicates the indent of the title of each level.
                 * @param {boolean} [options.printDrill] Print expand/collapse buttons when displayed on PivotTable.
                 * @param {boolean} [options.itemPrintTitles] Repeat row labels on each PivotTable.
                 * @param {boolean} [options.fieldPrintTitles] Set Print titles.
                 * @param {boolean} [options.showFilter] Indicates show filter button or not.
                 * @param {boolean} [options.showToolTip] Indicates show tooltip or not.
                 * @param {boolean} [options.mergeItem] Indicates wether merge and center the cells with labels.
                 * @returns {GCTYPE.Spread.Pivot.PivotTable} The new pivot table instance.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme);
                 */
                add(name: string,  sourceData: string | any[][],  row: number,  col: number,  layout?: GCTYPE.Spread.Pivot.PivotTableLayoutType,  theme?: GCTYPE.Spread.Pivot.PivotTableTheme,  options?: GCTYPE.Spread.Pivot.IPivotTableOption): GCTYPE.Spread.Pivot.PivotTable;
                /**
                 * @description Get all pivot table in current worksheet.
                 * @return {GCTYPE.Spread.Pivot.PivotTable[]} return all pivot table in current worksheet.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var pivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme, options);
                 * var pivotTables = pivotTableManager.all();
                 * console.log(pivotTables);
                 */
                all(): GCTYPE.Spread.Pivot.PivotTable[];
                /**
                 * @description Get pivot table by cell position.
                 * @param {number} r Indicates cell row index.
                 * @param {number} c Indicates cell column index.
                 * @returns {GCTYPE.Spread.Pivot.PivotTable} return the pivot table instance.
                 */
                findPivotTable(r: number,  c: number): GCTYPE.Spread.Pivot.PivotTable;
                /**
                 * @description Get pivot table by name.
                 * @param {string} name Indicates pivot table name.
                 * @returns {GCTYPE.Spread.Pivot.PivotTable} return the pivot table instance.
                 */
                get(name: string): GCTYPE.Spread.Pivot.PivotTable;
                /**
                 * @description get pivot areas by specified sheet range.
                 * @param {GCTYPE.Spread.Sheets.Range} range Indicates the sheet range.
                 * @returns {GCTYPE.Spread.Pivot.IPivotAreasCollection} all pivot areas contains in range.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * var myPivotTable = sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme);
                 * myPivotTable.add("Buyer", "Buyer", GCTYPE.Spread.Pivot.PivotTableFieldType.rowField);
                 * myPivotTable.add("Type", "Type", GCTYPE.Spread.Pivot.PivotTableFieldType.columnField)
                 * myPivotTable.add("Amount", "Sum of Amount", GCTYPE.Spread.Pivot.PivotTableFieldType.valueField, GCTYPE.Pivot.SubtotalType.sum);
                 * var pivotAreas = sheet.pivotTables.getRangePivotAreas(new GCTYPE.Spread.Sheets.Range(3, 2, 2, 2))[myPivotTable.name()];
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = 'red';
                 * myPivotTable.setStyle(pivotAreas[0], style);
                 */
                getRangePivotAreas(range: GCTYPE.Spread.Sheets.Range): GCTYPE.Spread.Pivot.IPivotAreasCollection;
                /**
                 * @description Remove a pivot table from worksheet.
                 * @param {string} name Indicates the pivot table name.
                 * @returns {void}
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 * var sourceSheet = spread.getSheet(0);
                 * var sheet = spread.getSheet(1);
                 * var sourceData = [["Date","Buyer","Type","Amount"],
                 *                   ["01-Jan","Mom","Fuel",74],
                 *                   ["15-Jan","Mom","Food",235],
                 *                   ["17-Jan","Dad","Sports",20],
                 *                   ["21-Jan","Kelly","Books",125]];
                 * sourceSheet.setArray(0, 0, sourceData );
                 * sourceSheet.tables.add('sourceData', 0, 0, 5, 4);
                 * var layout = GCTYPE.Spread.Pivot.PivotTableLayoutType.compact;
                 * var theme = GCTYPE.Spread.Pivot.PivotTableThemes.medium2;
                 * sheet.pivotTables.add("pivotTable_1", 'sourceData', 1, 1, layout, theme);
                 * sheet.pivotTables.remove("pivotTable_1");
                 */
                remove(name: string): any;
            }

            export class Point{
                /**
                 * Represents an <i>x</i>- and <i>y</i>-coordinate pair in two-dimensional space.
                 * @class
                 * @param {number} x The <i>x</i>-coordinate.
                 * @param {number} y The <i>y</i>-coordinate.
                 * @example
                 * //This example creates a floating object.
                 * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1");
                 * customFloatingObject.x(10);
                 * customFloatingObject.y(10);
                 * customFloatingObject.width(60);
                 * customFloatingObject.height(64);
                 * var btn = document.createElement('button');
                 * btn.style.width = "60px";
                 * btn.style.height = "30px";
                 * btn.innerText = "button";
                 * customFloatingObject.content(btn);
                 * activeSheet.floatingObjects.add(customFloatingObject);
                 */
                constructor(x: number,  y: number);
                /**
                 * Clones a new point from the current point.
                 * @returns {GCTYPE.Spread.Sheets.Point} The cloned object.
                 */
                clone(): GCTYPE.Spread.Sheets.Point;
            }

            export class Range{
                /**
                 * Represents a range, which is described by the row index, column index, row count, and column count.
                 * @class
                 * @param {number} r The row index.
                 * @param {number} c The column index.
                 * @param {number} rc The row count.
                 * @param {number} cc The column count.
                 * @example
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * var rule = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                 * rule.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                 * rule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,5,1)]);
                 * rule.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between);
                 * rule.style(style);
                 * rule.value1(2);
                 * rule.value2(100);
                 * activeSheet.conditionalFormats.addRule(rule);
                 * activeSheet.setValue(0,0,1,3);
                 * activeSheet.setValue(1,0,45,3);
                 */
                constructor(r: number,  c: number,  rc:number,  cc:number);
                /**
                 * The column index.
                 * @example
                 * var cellrange = new GCTYPE.Spread.Sheets.Range();
                 * cellrange.col = 0;
                 * cellrange.row = 1;
                 * cellrange.colCount = 1;
                 * cellrange.rowCount = 8;
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 * var setting = new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting();
                 * setting.options.showMarkers = true;
                 * activeSheet.setSparkline(13, 0, cellrange, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 */
                col: number;
                /**
                 * The column count.
                 * @example
                 * var cellrange = new GCTYPE.Spread.Sheets.Range();
                 * cellrange.col = 0;
                 * cellrange.row = 1;
                 * cellrange.colCount = 1;
                 * cellrange.rowCount = 8;
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 * var setting = new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting();
                 * setting.options.showMarkers = true;
                 * activeSheet.setSparkline(13, 0, cellrange, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 */
                colCount: number;
                /**
                 * The row index.
                 * @example
                 * var cellrange = new GCTYPE.Spread.Sheets.Range();
                 * cellrange.col = 0;
                 * cellrange.row = 1;
                 * cellrange.colCount = 1;
                 * cellrange.rowCount = 8;
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 * var setting = new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting();
                 * setting.options.showMarkers = true;
                 * activeSheet.setSparkline(13, 0, cellrange, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 */
                row: number;
                /**
                 * The row count.
                 * @example
                 * var cellrange = new GCTYPE.Spread.Sheets.Range();
                 * cellrange.col = 0;
                 * cellrange.row = 1;
                 * cellrange.colCount = 1;
                 * cellrange.rowCount = 8;
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 * var setting = new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting();
                 * setting.options.showMarkers = true;
                 * activeSheet.setSparkline(13, 0, cellrange, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 */
                rowCount: number;
                /**
                 * Gets whether the current range contains the specified cell.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {number} rowCount The row count.
                 * @param {number} colCount The column count.
                 * @returns {boolean} <c>true</c> if the range contains the cell; otherwise, <c>false</c>.
                 */
                contains(row: number,  col: number,  rowCount: number,  colCount: number): boolean;
                /**
                 * Gets whether the current range contains the specified range.
                 * @param {GCTYPE.Spread.Sheets.Range} range The cell range.
                 * @returns {boolean} <c>true</c> if the current range contains the specified cell range; otherwise, <c>false</c>.
                 */
                containsRange(range: GCTYPE.Spread.Sheets.Range): boolean;
                /**
                 * Gets whether the current range is equal to the specified range.
                 * @param {GCTYPE.Spread.Sheets.Range} range The range to compare.
                 * @returns {boolean} <c>true</c> if the current range is equal to the specified range; otherwise, <c>false</c>.
                 */
                equals(range: GCTYPE.Spread.Sheets.Range): boolean;
                /**
                 * Gets the intersection of two cell ranges.
                 * @param {GCTYPE.Spread.Sheets.Range} range The cell range.
                 * @param {number} maxRowCount The maximum row count.
                 * @param {number} maxColumnCount The maximum column count.
                 * @returns {GCTYPE.Spread.Sheets.Range} Returns null if there is no intersection, or the cell range of the intersection.
                 */
                getIntersect(range: GCTYPE.Spread.Sheets.Range,  maxRowCount: number,  maxColumnCount: number): GCTYPE.Spread.Sheets.Range;
                /**
                 * Gets whether the current range intersects with the one specified by the row and column index and the row and column count.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {number} rowCount The row count.
                 * @param {number} colCount The column count.
                 * @returns {boolean} <c>true</c> if the specified range intersects with the current range; otherwise <c>false</c>.
                 */
                intersect(row: number,  col: number,  rowCount: number,  colCount: number): boolean;
                /**
                 * Offsets the location of the range by the specified coordinates.
                 * @param {number} x The offset along the <i>x</i>-axis.
                 * @param {number} y The offset along the <i>y</i>-axis.
                 * @returns {GCTYPE.Spread.Sheets.Range} The new location.
                 */
                offset(x: number,  y: number): GCTYPE.Spread.Sheets.Range;
                /**
                 * Joins this range with the specified range as a union.
                 * @param {GCTYPE.Spread.Sheets.Range} range The target range.
                 * @returns {GCTYPE.Spread.Sheets.Range} Returns the union of the ranges.
                 */
                union(range: GCTYPE.Spread.Sheets.Range): GCTYPE.Spread.Sheets.Range;
            }

            export class Rect{
                /**
                 * Represents a rectangle with a special location, and its width and height in two-dimensional space.
                 * @class
                 * @param {number} x The <i>x</i>-coordinate of the top-left corner of the rectangle.
                 * @param {number} y The <i>y</i>-coordinate of the top-left corner of the rectangle.
                 * @param {number} w The width of the rectangle.
                 * @param {number} h The height of the rectangle.
                 */
                constructor(x: number,  y: number,  w: number,  h: number);
                /**
                 * The width of the rectangle.
                 */
                height: number;
                /**
                 * The height of the rectangle.
                 */
                width: number;
                /**
                 * The <i>x</i>-coordinate of the top-left corner of the rectangle.
                 */
                x: number;
                /**
                 * The <i>y</i>-coordinate of the top-left corner of the rectangle.
                 */
                y: number;
                /**
                 * Indicates whether the rectangle contains the specified <i>x</i>-coordinate and <i>y</i>-coordinate.
                 * @param {number} x The <i>x</i>-coordinate of the point to check.
                 * @param {number} y The <i>y</i>-coordinate of the point to check.
                 * @returns {boolean} <c>true</c> if (x, y) is contained by the rectangle; otherwise, <c>false</c>.
                 */
                contains(x: number,  y: number): boolean;
                /**
                 * Gets the rectangle that intersects with the current rectangle.
                 * @param {GCTYPE.Spread.Sheets.Rect} rect The rectangle.
                 * @returns {GCTYPE.Spread.Sheets.Rect} The intersecting rectangle. If the two rectangles do not intersect, returns null.
                 */
                getIntersectRect(x: number,  y: number,  width: number,  height: number): GCTYPE.Spread.Sheets.Rect;
                /**
                 * Indicates whether the specified rectangle intersects with the current rectangle.
                 * @param {number} x The <i>x</i>-coordinate of the top-left corner of the rectangle.
                 * @param {number} y The <i>y</i>-coordinate of the top-left corner of the rectangle.
                 * @param {number} w The width of the rectangle.
                 * @param {number} h The height of the rectangle.
                 * @returns {boolean} <c>true</c> if the specified rectangle intersects with the current rectangle; otherwise, <c>false</c>.
                 */
                intersect(x: number,  y: number,  width: number,  height: number): boolean;
                /**
                 * Indicates whether the specified rectangle intersects with the current rectangle.
                 * @param {GCTYPE.Spread.Sheets.Rect} rect The specified rectangle.
                 * @returns {boolean} <c>true</c> if the specified rectangle intersects with the current rectangle; otherwise, <c>false</c>.
                 */
                intersectRect(rect: GCTYPE.Spread.Sheets.Rect): boolean;
            }

            export class Style{
                /**
                 * Represents the style for a cell, row, and column.
                 * @class
                 * @param {string | GCTYPE.Spread.Sheets.IPatternFill | GCTYPE.Spread.Sheets.IGradientFill | GCTYPE.Spread.Sheets.IGradientPathFill} backColor The background color.
                 * @param {string} foreColor The foreground color.
                 * @param {GCTYPE.Spread.Sheets.HorizontalAlign} hAlign The horizontal alignment.
                 * @param {GCTYPE.Spread.Sheets.VerticalAlign} vAlign The vertical alignment.
                 * @param {string} font The font.
                 * @param {string} themeFont The font theme.
                 * @param {string|GCTYPE.Spread.Formatter.GeneralFormatter} formatter The formatting object.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} borderLeft The left border.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} borderTop The top border.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} borderRight The right border.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} borderBottom The bottom border.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} diagonalDown The diagonal with LeftTop to bottomRight.
                 * @param {GCTYPE.Spread.Sheets.LineBorder} diagonalUp The diagonal with topRight to bottomLeft.
                 * @param {boolean} locked Whether the cell, row, or column is locked.
                 * @param {number} textIndent The text indent amount.
                 * @param {boolean} wordWrap Whether words wrap within the cell or cells.
                 * @param {boolean} shrinkToFit Whether content shrinks to fit the cell or cells.
                 * @param {string} backgroundImage The background image to display.
                 * @param {GCTYPE.Spread.Sheets.CellTypes.Base} cellType The cell type.
                 * @param {GCTYPE.Spread.Sheets.ImageLayout} backgroundImageLayout The layout for the background image.
                 * @param {boolean} tabStop Whether the user can set focus to the cell using the Tab key.
                 * @param {GCTYPE.Spread.Sheets.TextDecorationType} textDecoration Specifies the decoration added to text.
                 * @param {GCTYPE.Spread.Sheets.ImeMode} imeMode Specifies the input method editor mode.
                 * @param {string} name Specifies the name.
                 * @param {string} parentName Specifies the name of the parent style.
                 * @param {string} watermark Specifies the watermark content.
                 * @param {string} cellPadding Specifies the cell padding.
                 * @param {Object} labelOptions Specifies the cell label options.
                 * @param {GCTYPE.Spread.Sheets.LabelAlignment} [labelOptions.alignment] The cell label position.
                 * @param {GCTYPE.Spread.Sheets.LabelVisibility} [labelOptions.visibility] The cell label visibility.
                 * @param {string} [labelOptions.font] The cell label font.
                 * @param {string} [labelOptions.foreColor] The cell label forecolor.
                 * @param {string} [labelOptions.margin] The cell label margin.
                 * @param {boolean} isVerticalText Whether to set the cell's text vertical.
                 * @param {number} textOrientation he cell text rotation angle.
                 * @example
                 * //This example uses a style with rules.
                 * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.foreColor = "black";
                 * var cell = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                 * cell.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                 * cell.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                 * cell.value1(5);
                 * cell.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                 * cell.style(style);
                 * activeSheet.conditionalFormats.addRule(cell);
                 * var style1 = new GCTYPE.Spread.Sheets.Style();
                 * style1.foreColor = "red";
                 * var top = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                 * top.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                 * top.type(GCTYPE.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                 * top.rank(3);
                 * top.style(style1);
                 * top.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                 * top.stopIfTrue(true);
                 * activeSheet.conditionalFormats.addRule(top);
                 * @example
                 * //This example creates and sets parameters for the style.
                 * sheet.setValue(0,0, 1,3);
                 * sheet.setValue(1,0, 50,3);
                 * sheet.setValue(2,0, 100,3);
                 * sheet.setValue(3,0, 2,3);
                 * sheet.setValue(4,0, 60,3);
                 * sheet.setValue(5,0, 90,3);
                 * sheet.setValue(6,0, 3,3);
                 * sheet.setValue(7,0, 40,3);
                 * sheet.setValue(8,0, 70,3);
                 * sheet.setValue(9,0, 5,3);
                 * sheet.setValue(10,0, 35,3);
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom =  new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * sheet.conditionalFormats.addAverageRule(GCTYPE.Spread.Sheets.ConditionalFormatting.AverageConditionType.above, style, [new GCTYPE.Spread.Sheets.Range(0, 0, 10, 3)]);
                 */
                constructor(backColor?: string | GCTYPE.Spread.Sheets.IPatternFill | GCTYPE.Spread.Sheets.IGradientFill | GCTYPE.Spread.Sheets.IGradientPathFill,  foreColor?: string,  hAlign?: GCTYPE.Spread.Sheets.HorizontalAlign,  vAlign?: GCTYPE.Spread.Sheets.VerticalAlign,  font?: string,  themeFont?: string,  formatter?: string | GCTYPE.Spread.Formatter.GeneralFormatter,  borderLeft?: GCTYPE.Spread.Sheets.LineBorder,  borderTop?: GCTYPE.Spread.Sheets.LineBorder,  borderRight?: GCTYPE.Spread.Sheets.LineBorder,  borderBottom?: GCTYPE.Spread.Sheets.LineBorder,  locked?: boolean,  textIndent?: number,  wordWrap?: boolean,  shrinkToFit?: boolean,  backgroundImage?: string,  cellType?: GCTYPE.Spread.Sheets.CellTypes.Base,  backgroundImageLayout?: GCTYPE.Spread.Sheets.ImageLayout,  tabStop?: boolean,  textDecoration?: GCTYPE.Spread.Sheets.TextDecorationType,  imeMode?: GCTYPE.Spread.Sheets.ImeMode,  name?: string,  parentName?: string,  watermark?: string,  cellPadding?: string,  labelOptions?: GCTYPE.Spread.Sheets.ILabelOptions,  diagonalDown?: GCTYPE.Spread.Sheets.LineBorder,  diagonalUp?: GCTYPE.Spread.Sheets.LineBorder,  isVerticalText?: boolean,  textOrientation?: number);
                /**
                 * Indicates the background color.
                 * @type {string}
                 * @example
                 * //This example sets the style backColor property.
                 * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.foreColor = "black";
                 * var cell = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                 * cell.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                 * cell.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                 * cell.value1(5);
                 * cell.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                 * cell.style(style);
                 * activeSheet.conditionalFormats.addRule(cell);
                 * var style1 = new GCTYPE.Spread.Sheets.Style();
                 * style1.foreColor = "red";
                 * var top = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                 * top.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                 * top.type(GCTYPE.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                 * top.rank(3);
                 * top.style(style1);
                 * top.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                 * top.stopIfTrue(true);
                 * activeSheet.conditionalFormats.addRule(top);
                 */
                backColor: string | undefined | GCTYPE.Spread.Sheets.IPatternFill | GCTYPE.Spread.Sheets.IGradientFill | GCTYPE.Spread.Sheets.IGradientPathFill;
                /**
                 * Indicates the background image.
                 * @type {string}
                 * @example
                 * //This example sets the backgroundImage property.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "lightgreen";
                 * style.backgroundImage = "./css/images/quarter1.png";
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                backgroundImage: string | undefined;
                /**
                 * Indicates the background image layout.
                 * @type {GCTYPE.Spread.Sheets.ImageLayout}
                 * @example
                 * //This example sets the backgroundImageLayout property.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "lightgreen";
                 * style.backgroundImage = "./css/images/quarter1.png";
                 * style.backgroundImageLayout  = GCTYPE.Spread.Sheets.ImageLayout.center;
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                backgroundImageLayout: GCTYPE.Spread.Sheets.ImageLayout | undefined;
                /**
                 * Indicates the bottom border line.
                 * @type {GCTYPE.Spread.Sheets.LineBorder}
                 * @example
                 * //This example creates a border.
                 * var cellType = new GCTYPE.Spread.Sheets.CellTypes.Button();
                 * cellType.buttonBackColor("#FFFF00");
                 * cellType.text("this is a button");
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.cellType = cellType
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                borderBottom: GCTYPE.Spread.Sheets.LineBorder | undefined;
                /**
                 * Indicates the left border line.
                 * @type {GCTYPE.Spread.Sheets.LineBorder}
                 * @example
                 * //This example creates a border.
                 * var cellType = new GCTYPE.Spread.Sheets.CellTypes.Button();
                 * cellType.buttonBackColor("#FFFF00");
                 * cellType.text("this is a button");
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.cellType = cellType
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                borderLeft: GCTYPE.Spread.Sheets.LineBorder | undefined;
                /**
                 * Indicates the right border line.
                 * @type {GCTYPE.Spread.Sheets.LineBorder}
                 * @example
                 * //This example creates a border.
                 * var cellType = new GCTYPE.Spread.Sheets.CellTypes.Button();
                 * cellType.buttonBackColor("#FFFF00");
                 * cellType.text("this is a button");
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.cellType = cellType
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                borderRight: GCTYPE.Spread.Sheets.LineBorder | undefined;
                /**
                 * Indicates the top border line.
                 * @type {GCTYPE.Spread.Sheets.LineBorder}
                 * @example
                 * //This example creates a border.
                 * var cellType = new GCTYPE.Spread.Sheets.CellTypes.Button();
                 * cellType.buttonBackColor("#FFFF00");
                 * cellType.text("this is a button");
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.cellType = cellType
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                borderTop: GCTYPE.Spread.Sheets.LineBorder | undefined;
                /**
                 * Indicates the cellButtons of cell.
                 * @type {Object[]}
                 * @property {string} [caption] - Specific the text of the button to display
                 * @property {GCTYPE.Spread.Sheets.CaptionAlignment} [captionAlign] - Specific the position of image and caption.
                 * @property {GCTYPE.Spread.Sheets.ButtonPosition} [position] - Specific the button's position in cell
                 * @property {boolean} [enabled] - Specific whether the cell button responds to user actions, default value is true.
                 * @property {boolean} [useButtonStyle] - Specific whether the cellButton is a button style, default value is false.
                 * @property {number} [width] - Specific the button's width. If it is set to null or undefined, the button width is auto fit based on the caption and image size.
                 * @property {GCTYPE.Spread.Sheets.ButtonVisibility} [visibility] - Specific the button can be visible always, onSelected, onEditing, default value is always.
                 * @property {string | function} [command] - When click button, allow user to execute a spread command or user can execute a callback.
                 * @property {GCTYPE.Spread.Sheets.ButtonImageType} [imageType] - Specific the button's type (the type of image to display in the button), default value is custom. Provide some predefined type for cellButton, custom allow to specific icon.
                 * @property {string} [imageSrc] - When imageType is custom, can specific a image (base64) by imageSrc.
                 * @property {Object} [imageSize] - Specific the image's size, default value is 16px.
                 * @property {number} [imageSize.width] - Specific the image's width, default value is 16, unit is px.
                 * @property {number} [imageSize.height] - Specific the image's height, default value is 16, unit is px.
                 * @property {string} [hoverBackColor] - Specific the hover backColor of cell button when the button is visible and enable.
                 * @property {string} [buttonBackColor] - Specific the backColor of cell button when the button is enable.
                 * @example
                 * buttonConfig1 = {
                 *     caption: "left",
                 *     enabled: true,
                 *     buttonBackColor: "#174EA6",
                 *     visibility:GCTYPE.Spread.Sheets.ButtonVisibility.always,
                 * };
                 * buttonConfig2 = {
                 *     caption: "left",
                 *     enabled: true,
                 *     hoverBackColor: "#3390FF",
                 *     visibility:GCTYPE.Spread.Sheets.ButtonVisibility.onSelected,
                 * };
                 * buttonConfig3 = {
                 *     caption: "Cut",
                 *     imageType: GCTYPE.Spread.Sheets.ButtonImageType.custom,
                 *     useButtonStyle: true,
                 *     imageSrc:"data:image/svg+xml;base64,PD94bWwgdmVyc2lvb...", //This is not a complete base64 string
                 * };
                 * //create style
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.cellButtons=[
                 *      buttonConfig1,
                 *      buttonConfig2,
                 *      buttonConfig3
                 * ];
                 * sheet.setStyle(0, 0, style);
                 */
                cellButtons: GCTYPE.Spread.Sheets.ICellButton[] | undefined;
                /**
                 * Indicates the cell padding.
                 * @type {string}
                 * @example
                 * //This example sets the cell padding for the watermark.
                 * var type = new GCTYPE.Spread.Sheets.Style();
                 * type.watermark = "User name";
                 * type.cellPadding = "20";
                 * type.labelOptions = {alignment:GCTYPE.Spread.Sheets.LabelAlignment.topLeft, visibility: GCTYPE.Spread.Sheets.LabelVisibility.visible};
                 * activeSheet.setStyle(0, 1, type);
                 * activeSheet.getRange(0, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).height(60);
                 * activeSheet.getRange(-1, 1, -1, 1).width(150);
                 * var combo = new GCTYPE.Spread.Sheets.CellTypes.ComboBox();
                 * combo.items([{ text: "Oranges", value: "11k" }, { text: "Apples", value: "15k" }, { text: "Grape", value: "100k" }]);
                 * combo.editorValueType(GCTYPE.Spread.Sheets.CellTypes.EditorValueType.text);
                 * activeSheet.setCellType(2, 1, combo, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(2, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).watermark("ComboBox Cell Type").cellPadding('10 10 20 10');
                 * activeSheet.getCell(2, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).labelOptions({alignment: GCTYPE.Spread.Sheets.LabelAlignment.bottomCenter, foreColor: 'yellowgreen', font: 'bold 15px Arial'});
                 * activeSheet.getRange(2, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).height(60);
                 */
                cellPadding: string | undefined;
                /**
                 * Indicates the cell type.
                 * @type {GCTYPE.Spread.Sheets.CellTypes.Base}
                 * @example
                 * //This example creates a style and applies it to a cell.
                 * var cellType = new GCTYPE.Spread.Sheets.CellTypes.Button();
                 * cellType.buttonBackColor("#FFFF00");
                 * cellType.text("this is a button");
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.cellType = cellType
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                cellType: GCTYPE.Spread.Sheets.CellTypes.Base | undefined;
                /**
                 * Indicates the diagonalDown border line.
                 * @type {GCTYPE.Spread.Sheets.LineBorder}
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).diagonalDown(new GCTYPE.Spread.Sheets.LineBorder("blue", GCTYPE.Spread.Sheets.LineStyle.mediumDashed));
                 */
                diagonalDown: GCTYPE.Spread.Sheets.LineBorder | undefined;
                /**
                 * Indicates the diagonalUp border line.
                 * @type {GCTYPE.Spread.Sheets.LineBorder}
                 * @example
                 * activeSheet.getRange(-1, 3, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).diagonalUp(new GCTYPE.Spread.Sheets.LineBorder("blue", GCTYPE.Spread.Sheets.LineStyle.mediumDashed));
                 */
                diagonalUp: GCTYPE.Spread.Sheets.LineBorder | undefined;
                /**
                 * Indicates the dropdown type of cell.
                 * @type {Object[]}
                 * @example
                 * leftButtonConfig1 = {
                 *     caption: "left",
                 *     enabled: true,
                 *     isLeft: true,
                 *     visibility:GCTYPE.Spread.Sheets.ButtonVisibility.always,
                 *     command: "opendropdown"
                 * }
                 * //create style
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.cellButtons=[
                 *      leftButtonConfig1
                 * ];
                 * style.dropDowns= [{ type: "colorPicker" }];
                 * sheet.setStyle(0, 0, style);
                 */
                dropDowns: GCTYPE.Spread.Sheets.IDropdown[] | undefined;
                /**
                 * Indicates the font.
                 * @type {string}
                 * @example
                 * //This example sets the font property.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.font = "8pt Arial";
                 * style.hAlign = GCTYPE.Spread.Sheets.HorizontalAlign.center;
                 * style.vAlign = GCTYPE.Spread.Sheets.VerticalAlign.center;
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(1,1).value("B2");
                 */
                font: string | undefined;
                /**
                 * Indicates the foreground color.
                 * @type {string}
                 * @example
                 * //This example sets the foreColor property.
                 * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.foreColor = "black";
                 * var cell = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                 * cell.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                 * cell.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                 * cell.value1(5);
                 * cell.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                 * cell.style(style);
                 * activeSheet.conditionalFormats.addRule(cell);
                 * var style1 = new GCTYPE.Spread.Sheets.Style();
                 * style1.foreColor = "red";
                 * var top = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                 * top.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                 * top.type(GCTYPE.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                 * top.rank(3);
                 * top.style(style1);
                 * top.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                 * top.stopIfTrue(true);
                 * activeSheet.conditionalFormats.addRule(top);
                 */
                foreColor: string | undefined;
                /**
                 * Indicates the formatter.
                 * @type {string|GCTYPE.Spread.Formatter.GeneralFormatter}
                 * @example
                 * //This example uses the formatter property.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.formatter = "0.000%";
                 * style.themeFont = "Body";
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(1,1).value("11");
                 */
                formatter: string | GCTYPE.Spread.Formatter.GeneralFormatter | undefined;
                /**
                 * Indicates the horizontal alignment.
                 * @type {GCTYPE.Spread.Sheets.HorizontalAlign}
                 * @example
                 * //This example sets the hAlign property.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.font = "8pt Arial";
                 * style.hAlign = GCTYPE.Spread.Sheets.HorizontalAlign.center;
                 * style.vAlign = GCTYPE.Spread.Sheets.VerticalAlign.center;
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(1,1).value("B2");
                 */
                hAlign: GCTYPE.Spread.Sheets.HorizontalAlign | undefined;
                /**
                 * Indicates the Input Method Editor (IME) mode.
                 * @type {GCTYPE.Spread.Sheets.ImeMode}
                 * @example
                 * //This example sets the IME mode.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.imeMode = GCTYPE.Spread.Sheets.ImeMode.auto;
                 * activeSheet.setStyle(0, 0, style);
                 */
                imeMode: GCTYPE.Spread.Sheets.ImeMode | undefined;
                /**
                 * Indicates whether to set the text vertical.
                 * @type {boolean}
                 * @example
                 * //This example uses the rotate property.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.isVerticalText = true;
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                isVerticalText: boolean | undefined;
                /**
                 * Indicates the cell label options.
                 * @property {GCTYPE.Spread.Sheets.LabelAlignment} [alignment] - The cell label position.
                 * @property {GCTYPE.Spread.Sheets.LabelVisibility} [visibility] - The cell label visibility.
                 * @property {string} [font] - The cell label font.
                 * @property {string} [foreColor] - The cell label forecolor.
                 * @property {string} [margin] - The cell label margin.
                 * @type {Object}
                 * @example
                 * //This example sets label options for the watermark.
                 * var type = new GCTYPE.Spread.Sheets.Style();
                 * type.watermark = "User name";
                 * type.cellPadding = "20";
                 * type.labelOptions = {alignment:GCTYPE.Spread.Sheets.LabelAlignment.topLeft, visibility: GCTYPE.Spread.Sheets.LabelVisibility.visible};
                 * activeSheet.setStyle(0, 1, type);
                 * activeSheet.getRange(0, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).height(60);
                 * activeSheet.getRange(-1, 1, -1, 1).width(150);
                 * var combo = new GCTYPE.Spread.Sheets.CellTypes.ComboBox();
                 * combo.items([{ text: "Oranges", value: "11k" }, { text: "Apples", value: "15k" }, { text: "Grape", value: "100k" }]);
                 * combo.editorValueType(GCTYPE.Spread.Sheets.CellTypes.EditorValueType.text);
                 * activeSheet.setCellType(2, 1, combo, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(2, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).watermark("ComboBox Cell Type").cellPadding('10 10 20 10');
                 * activeSheet.getCell(2, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).labelOptions({alignment: GCTYPE.Spread.Sheets.LabelAlignment.bottomCenter, foreColor: 'yellowgreen', font: 'bold 15px Arial'});
                 * activeSheet.getRange(2, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).height(60);
                 */
                labelOptions: GCTYPE.Spread.Sheets.ILabelOptions | undefined;
                /**
                 * Indicates whether a cell is marked as locked from editing.
                 * @type {boolean}
                 * @example
                 * //This example unlocks a single cell.
                 * activeSheet.options.isProtected = true;
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.locked = false;
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                locked: boolean | undefined;
                /**
                 * Indicates the name.
                 * @type {string}
                 * @example
                 * //This example sets the style name.
                 * var namedStyle = new GCTYPE.Spread.Sheets.Style();
                 * namedStyle.name = "style1";
                 * namedStyle.backColor = "green";
                 * activeSheet.addNamedStyle(namedStyle);
                 * activeSheet.setStyleName(1, 1, "style1"); // cell(1,1)'s backColor is green.
                 * var namedStyle1 = new GCTYPE.Spread.Sheets.Style();
                 * namedStyle1.name = "style2";
                 * namedStyle1.parentName = "style1";
                 * namedStyle1.foreColor = "red";    // the namedStyle's foreColor is red.
                 * activeSheet.addNamedStyle(namedStyle1);
                 * activeSheet.setStyleName(2, 1, "style2");
                 */
                name: string | undefined;
                /**
                 * Indicates the name of the parent style.
                 * @type {string}
                 * @example
                 * //This example sets the parent name.
                 * var namedStyle = new GCTYPE.Spread.Sheets.Style();
                 * namedStyle.name = "style1";
                 * namedStyle.backColor = "green";
                 * activeSheet.addNamedStyle(namedStyle);
                 * activeSheet.setStyleName(1, 1, "style1"); // cell(1,1)'s backColor is green.
                 * var namedStyle1 = new GCTYPE.Spread.Sheets.Style();
                 * namedStyle1.name = "style2";
                 * namedStyle1.parentName = "style1";
                 * namedStyle1.foreColor = "red";    // the namedStyle's foreColor is red.
                 * activeSheet.addNamedStyle(namedStyle1);
                 * activeSheet.setStyleName(2, 1, "style2");
                 */
                parentName: string | undefined;
                /**
                 * Controls whether the Text out of bounds shows ellipsis.
                 * @type {boolean}
                 * @example
                 * //This example sets the showEllipsis property.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.showEllipsis = true;
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(1,1).text("TestTestTestTest");
                 */
                showEllipsis: boolean | undefined;
                /**
                 * Indicates whether to shrink to fit.
                 * @type {boolean}
                 * @example
                 * //This example sets the shrinkToFit property.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.shrinkToFit = true;
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(1,1).text("Shrink To Fit");
                 */
                shrinkToFit: boolean | undefined;
                /**
                 * Indicates whether the user can set focus to the cell using the Tab key.
                 * @type {boolean}
                 * @example
                 * //This example sets the tabStop property.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.tabStop = false;
                 * style.backColor = "lightgreen";
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                tabStop: boolean | undefined;
                /**
                 * Indicates the decoration added to text.
                 * @type {GCTYPE.Spread.Sheets.TextDecorationType}
                 * @example
                 * //This example uses the textDecoration property.
                 * activeSheet.getCell(0, 0).textDecoration(GCTYPE.Spread.Sheets.TextDecorationType.underline);
                 * activeSheet.getRange(1, -1, 1, -1).textDecoration(GCTYPE.Spread.Sheets.TextDecorationType.overline | GCTYPE.Spread.Sheets.TextDecorationType.underline);
                 * activeSheet.getRange(-1, 1, -1, 1).textDecoration(GCTYPE.Spread.Sheets.TextDecorationType.overline | GCTYPE.Spread.Sheets.TextDecorationType.lineThrough | GCTYPE.Spread.Sheets.TextDecorationType.underline);
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.textDecoration = GCTYPE.Spread.Sheets.TextDecorationType.overline | GCTYPE.Spread.Sheets.TextDecorationType.underline;
                 * activeSheet.setStyle(1, 1, style, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(0, 0).value("Test");
                 * activeSheet.getCell(1, 0).value("Test");
                 * activeSheet.getCell(0, 1).value("Test");
                 */
                textDecoration: GCTYPE.Spread.Sheets.TextDecorationType | undefined;
                /**
                 * Indicates the number of units of indentation for text in a cell, an integer value, where an increment of 1 represents 8 pixels.
                 * @type {number}
                 * @example
                 * //This example sets the textIndent property.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.textIndent = 3;
                 * // Enter multiple lines with Alt+Enter
                 * style.wordWrap = true;
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(1,1).text("Test");
                 */
                textIndent: number | undefined;
                /**
                 * Indicates the text rotation angle of cell.
                 * @type {number}
                 * @example
                 * //This example sets the textOrientation property.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.textOrientation = 66;
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(1,1).text("TestTestTestTest");
                 */
                textOrientation: number | undefined;
                /**
                 * Indicates the font theme.
                 * @type {string}
                 * @example
                 * //This example uses the themeFont property.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.formatter = "0.000%";
                 * style.themeFont = "Body";
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(1,1).value("11");
                 */
                themeFont: string | undefined;
                /**
                 * Indicates the vertical alignment.
                 * @type {GCTYPE.Spread.Sheets.VerticalAlign}
                 * @example
                 * //This example sets the vAlign property.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.font = "8pt Arial";
                 * style.hAlign = GCTYPE.Spread.Sheets.HorizontalAlign.center;
                 * style.vAlign = GCTYPE.Spread.Sheets.VerticalAlign.center;
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(1,1).value("B2");
                 */
                vAlign: GCTYPE.Spread.Sheets.VerticalAlign | undefined;
                /**
                 * Indicates the watermark content.
                 * @type {string}
                 * @example
                 * //The following examples add watermarks to cells, columns, and rows.
                 * var type = new GCTYPE.Spread.Sheets.Style();
                 * type.watermark = "User name";
                 * sheet.setStyle(0, 1, type);
                 * var type = new GCTYPE.Spread.Sheets.Style();
                 * type.watermark = "Password";
                 * sheet.setStyle(1, 1, type);
                 * @example
                 * var type = new GCTYPE.Spread.Sheets.Style();
                 * type.watermark = "The watermark.";
                 * activeSheet.setStyle(-1, 1, type);
                 * activeSheet.setStyle(1, -1, type);
                 * activeSheet.setStyle(2, 2, type);
                 */
                watermark: string | undefined;
                /**
                 * Indicates whether to wrap text.
                 * @type {boolean}
                 * @example
                 * //This example sets the wordWrap property.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.textIndent = 3;
                 * // Enter multiple lines with Alt+Enter
                 * style.wordWrap = true;
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.getCell(1,1).text("Test");
                 */
                wordWrap: boolean | undefined;
                /**
                 * Clones the current style.
                 * @returns {GCTYPE.Spread.Sheets.Style} The cloned style.
                 */
                clone(): GCTYPE.Spread.Sheets.Style;
            }

            export class Theme{
                /**
                 * Represents a color scheme.
                 * @class
                 * @param {string} name The name of the theme.
                 * @param {GCTYPE.Spread.Sheets.ColorScheme} colorScheme The base colors of the theme color.
                 * @param {string} headerFont The name of the heading font.
                 * @param {string} bodyFont The name of the body font.
                 * @example
                 * //This example creates a new SpreadTheme object.
                 * sheet.getCell(0, 0).backColor("accent 1");
                 * sheet.getCell(1, 0).backColor("accent 6");
                 * $("#btn").click(function () {
                 *     var custom = new GCTYPE.Spread.Sheets.Theme("Custom");
                 *     custom.colors().accent1("red");
                 *     custom.colors().accent6("green");
                 *     sheet.currentTheme(custom);
                 * })
                 */
                constructor(name: string,  colorScheme: ColorScheme,  headerFont: string,  bodyFont: string);
                /**
                 * Gets or sets the body font of the theme.
                 * @param {string} value The body font.
                 * @returns {string|GCTYPE.Spread.Sheets.Theme} If no value is set, returns the body font; otherwise, returns the theme.
                 */
                bodyFont(value?: string): any;
                /**
                 * Gets or sets the base colors of the theme.
                 * @param {GCTYPE.Spread.Sheets.ColorScheme} value The base colors of the theme.
                 * @returns {GCTYPE.Spread.Sheets.ColorScheme|GCTYPE.Spread.Sheets.Theme} If no value is set, returns the base colors of the theme; otherwise, returns the theme.
                 */
                colors(value?: GCTYPE.Spread.Sheets.ColorScheme): any;
                /**
                 * Gets or sets the heading font of the theme.
                 * @param {string} value The heading font.
                 * @returns {string|GCTYPE.Spread.Sheets.Theme} If no value is set, returns the heading font; otherwise, returns the theme.
                 */
                headerFont(value?: string): any;
                /**
                 * Gets or sets the name of the theme.
                 * @param {string} value The theme name.
                 * @returns {string|GCTYPE.Spread.Sheets.Theme} If no value is set, returns the theme name; otherwise, returns the theme.
                 */
                name(value?: string): any;
            }

            export class ThemeColors{
                /**
                 * Represents the theme color of built-in themes.
                 * @class
                 * @example
                 * //This example creates a custom theme.
                 * var custom = new GCTYPE.Spread.Sheets.Theme("CustomTheme");
                 * custom.colors().accent1("red");
                 * custom.colors().accent6("green");
                 * custom.colors().textColor1("orange");
                 * activeSheet.currentTheme(custom);
                 * activeSheet.getCell(0, 0).backColor("accent 1");
                 * activeSheet.getCell(1, 0).backColor("accent 1 30");
                 */
                constructor();
                /**
                 * The theme color of the Apex theme.
                 * @example
                 * //This example uses the Apex theme.
                 * activeSheet.currentTheme("Apex");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Apex: ColorScheme;
                /**
                 * The theme color of the Aspect theme.
                 * @example
                 * //This example uses the Aspect theme.
                 * activeSheet.currentTheme("Aspect");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Aspect: ColorScheme;
                /**
                 * The theme color of the Civic theme.
                 * @example
                 * //This example uses the Civic theme.
                 * activeSheet.currentTheme("Civic");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Civic: ColorScheme;
                /**
                 * The theme color of the Concourse theme.
                 * @example
                 * //This example uses the Concourse theme.
                 * activeSheet.currentTheme("Concourse");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Concourse: ColorScheme;
                /**
                 * The theme color of the Default theme.
                 * @example
                 * //This example sets the Default theme.
                 * activeSheet.currentTheme("Default");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Default: ColorScheme;
                /**
                 * The theme color of the Equity theme.
                 * @example
                 * //This example sets the Equity theme.
                 * activeSheet.currentTheme("Equity");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Equity: ColorScheme;
                /**
                 * The theme color of the Flow theme.
                 * @example
                 * //This example sets the Flow theme.
                 * activeSheet.currentTheme("Flow");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Flow: ColorScheme;
                /**
                 * The theme color of the Foundry theme.
                 * @example
                 * //This example sets the Foundry theme.
                 * activeSheet.currentTheme("Foundry");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Foundry: ColorScheme;
                /**
                 * The theme color of the Median theme.
                 * @example
                 * //This example sets the Median theme.
                 * activeSheet.currentTheme("Median");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Median: ColorScheme;
                /**
                 * The theme color of the Metro theme.
                 * @example
                 * //This example sets the Metro theme.
                 * activeSheet.currentTheme("Metro");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Metro: ColorScheme;
                /**
                 * The theme color of the Module theme.
                 * @example
                 * //This example sets the Module theme.
                 * activeSheet.currentTheme("Module");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Module: ColorScheme;
                /**
                 * The theme color of the Office theme.
                 * @example
                 * //This example sets the Office theme.
                 * activeSheet.currentTheme("Office");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Office: ColorScheme;
                /**
                 * The theme color of the Office 2007 theme.
                 * @example
                 * //This example uses the Office2007 theme.
                 * activeSheet.currentTheme("Office2007");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Office2007: ColorScheme;
                /**
                 * The theme color of the Opulent theme.
                 * @example
                 * //This example sets the Opulent theme.
                 * activeSheet.currentTheme("Opulent");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Opulent: ColorScheme;
                /**
                 * The theme color of the Oriel theme.
                 * @example
                 * //This example sets the Oriel theme.
                 * activeSheet.currentTheme("Oriel");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Oriel: ColorScheme;
                /**
                 * The theme color of the Origin theme.
                 * @example
                 * //This example sets the Origin theme.
                 * activeSheet.currentTheme("Origin");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Origin: ColorScheme;
                /**
                 * The theme color of the Paper theme.
                 * @example
                 * //This example sets the Paper theme.
                 * activeSheet.currentTheme("Paper");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Paper: ColorScheme;
                /**
                 * The theme color of the Solstice theme.
                 * @example
                 * //This example sets the Solstice theme.
                 * activeSheet.currentTheme("Solstice");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Solstice: ColorScheme;
                /**
                 * The theme color of the Technic theme.
                 * @example
                 * //This example sets the Technic theme.
                 * activeSheet.currentTheme("Technic");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Technic: ColorScheme;
                /**
                 * The theme color of the Trek theme.
                 * @example
                 * //This example sets the Trek theme.
                 * activeSheet.currentTheme("Trek");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Trek: ColorScheme;
                /**
                 * The theme color of the Urban theme.
                 * @example
                 * //This example sets the Urban theme.
                 * activeSheet.currentTheme("Urban");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Urban: ColorScheme;
                /**
                 * The theme color of the Verve theme.
                 * @example
                 * //This example sets the Verve theme.
                 * activeSheet.currentTheme("Verve");
                 * activeSheet.resumePaint();
                 * activeSheet.repaint();
                 */
                Verve: ColorScheme;
            }

            export class Themes{
                /**
                 * Represents all built-in themes.
                 * @class
                 */
                constructor();
                /**
                 * Indicates the Apex theme.
                 */
                Apex: Theme;
                /**
                 * Indicates the Aspect theme.
                 */
                Aspect: Theme;
                /**
                 * Indicates the Civic theme.
                 */
                Civic: Theme;
                /**
                 * Indicates the Concourse theme.
                 */
                Concourse: Theme;
                /**
                 * Indicates the Default theme.
                 */
                Default: Theme;
                /**
                 * Indicates the Equity theme.
                 */
                Equity: Theme;
                /**
                 * Indicates the Flow theme.
                 */
                Flow: Theme;
                /**
                 * Indicates the Foundry theme.
                 */
                Foundry: Theme;
                /**
                 * Indicates the Median theme.
                 */
                Median: Theme;
                /**
                 * Indicates the Metro theme.
                 */
                Metro: Theme;
                /**
                 * Indicates the Module theme.
                 */
                Module: Theme;
                /**
                 * Indicates the Office theme.
                 */
                Office: Theme;
                /**
                 * Indicates the Office 2007 theme.
                 */
                Office2007: Theme;
                /**
                 * Indicates the Opulent theme.
                 */
                Opulent: Theme;
                /**
                 * Indicates the Oriel theme.
                 */
                Oriel: Theme;
                /**
                 * Indicates the Origin theme.
                 */
                Origin: Theme;
                /**
                 * Indicates the Paper theme.
                 */
                Paper: Theme;
                /**
                 * Indicates the Solstice theme.
                 */
                Solstice: Theme;
                /**
                 * Indicates the Technic theme.
                 */
                Technic: Theme;
                /**
                 * Indicates the Trek theme.
                 */
                Trek: Theme;
                /**
                 * Indicates the Urban theme.
                 */
                Urban: Theme;
                /**
                 * Indicates the Verve theme.
                 */
                Verve: Theme;
            }

            export class Workbook{
                /**
                 * Represents a spreadsheet with the specified hosted DOM element or DOM id and options setting.
                 * @class
                 * @param {HTMLElement | string} host - The host DOM element or id.
                 * @param {Object} [options] - The initialization options.<br />
                 * @param {number} [options.sheetCount] - The number of sheets.<br />
                 * @param {string} [options.font] - The tab strip font.<br />
                 * @param {boolean} [options.allowUserDragMerge] - Whether to allow the user to drag merge cells.<br />
                 * @param {boolean} [options.allowUserDragDrop] - Whether to allow the user to drag and drop range data.<br />
                 * @param {boolean} [options.allowUserDragFill] - Whether to allow the user to drag fill a range.<br />
                 * @param {boolean} [options.allowUserZoom] - Whether to zoom the display by scrolling the mouse wheel while pressing the Ctrl key.<br />
                 * @param {boolean} [options.allowUserResize] - Whether to allow the user to resize columns and rows.<br />
                 * @param {boolean} [options.allowUndo] - Whether to allow the user to undo edits.<br />
                 * @param {boolean} [options.allowSheetReorder] - Whether the user can reorder the sheets in the Spread component.<br />
                 * @param {boolean} [options.allowContextMenu] -  Whether to allow the user to open the built-in context menu.<br />
                 * @param {boolean} [options.allowUserDeselect] -  Whether to allow the user to can use deselect in selection.<br />
                 * @param {GCTYPE.Spread.Sheets.Fill.AutoFillType} [options.defaultDragFillType] - The default fill type.<br />
                 * @param {boolean} [options.showDragFillSmartTag] - Whether to display the drag fill dialog.<br />
                 * @param {boolean} [options.showHorizontalScrollbar] - Whether to display the horizontal scroll bar.<br />
                 * @param {boolean} [options.showVerticalScrollbar] - Whether to display the vertical scroll bar.<br />
                 * @param {boolean} [options.scrollbarShowMax] - Whether the displayed scroll bars are based on the entire number of columns and rows in the sheet.<br />
                 * @param {boolean} [options.scrollbarMaxAlign] - Whether the scroll bar aligns with the last row and column of the active sheet.<br />
                 * @param {boolean} [options.tabStripVisible] - Whether to display the sheet tab strip.<br />
                 * @param {number} [options.tabStripRatio] - The width of the tab strip expressed as a percentage of the overall horizontal scroll bar width.<br />
                 * @param {boolean} [options.tabEditable] - Whether to allow the user to edit the sheet tab strip.<br />
                 * @param {boolean} [options.newTabVisible] - Whether the spreadsheet displays the special tab to let users insert new sheets.<br />
                 * @param {boolean} [options.tabNavigationVisible] - Whether to display the sheet tab navigation.<br />
                 * @param {boolean} [options.cutCopyIndicatorVisible] - Whether to display an indicator when copying or cutting the selected item.<br />
                 * @param {string} [options.cutCopyIndicatorBorderColor] - The border color for the indicator displayed when the user cuts or copies the selection.<br />
                 * @param {string} [options.backColor] - A color string used to represent the background color of the Spread component, such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.<br />
                 * @param {string} [options.backgroundImage] - The background image of the Spread component.<br />
                 * @param {GCTYPE.Spread.Sheets.ImageLayout} [options.backgroundImageLayout] - The background image layout for the Spread component.<br />
                 * @param {string} [options.grayAreaBackColor] - A color string used to represent the background color of the gray area , such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.<br />
                 * @param {GCTYPE.Spread.Sheets.ShowResizeTip} [options.showResizeTip] - How to display the resize tip.<br />
                 * @param {boolean} [options.showDragDropTip] -Whether to display the drag-drop tip.<br />
                 * @param {boolean} [options.showDragFillTip] - Whether to display the drag-fill tip.<br />
                 * @param {GCTYPE.Spread.Sheets.ShowScrollTip} [options.showScrollTip] - How to display the scroll tip.<br />
                 * @param {boolean} [options.scrollIgnoreHidden] - Whether the scroll bar ignores hidden rows or columns.<br />
                 * @param {boolean} [options.highlightInvalidData] - Whether to highlight invalid data.<br />
                 * @param {boolean} [options.useTouchLayout] - Whether to use touch layout to present the Spread component.<br />
                 * @param {boolean} [options.hideSelection] - Whether to display the selection highlighting when the Spread component does not have focus.<br />
                 * @param {GCTYPE.Spread.Sheets.ResizeZeroIndicator} [options.resizeZeroIndicator] - The drawing policy when the row or column is resized to zero.<br />
                 * @param {boolean} [options.allowUserEditFormula] - Whether the user can edit formulas in a cell in the spreadsheet.<br />
                 * @param {boolean} [options.enableFormulaTextbox] - Whether to enable the formula text box in the spreadsheet.<br />
                 * @param {GCTYPE.Spread.Sheets.AutoFitType} [options.autoFitType] - Whether content will be formatted to fit in cells or in cells and headers.<br />
                 * @param {GCTYPE.Spread.Sheets.ReferenceStyle} [options.referenceStyle] - the style for cell and range references in cell formulas on this sheet.
                 * @param {boolean} [options.calcOnDemand] - Whether to calculate formulas only when they are demanded.
                 * @param {boolean} [options.allowCopyPasteExcelStyle] - Whether the user can copy style from Spread Sheets then paste to Excel, or copy style from Excel then paste to Spread Sheets.
                 * @param {boolean} [options.allowExtendPasteRange] - Whether extend paste range if the paste range is not enough for pasting.
                 * @param {GCTYPE.Spread.Sheets.CopyPasteHeaderOptions} [options.copyPasteHeaderOptions] - Which headers are included when data is copied to or pasted.
                 * @param {boolean} [options.scrollByPixel] - Whether to enable the precision scrolling by pixel.
                 * @param {number} [options.scrollPixel] - Decides scrolling by that number of pixels at a time when scrollByPixel is true. The final scrolling pixels are the result of scrolling delta multiply scrollPixel. For example, the scrolling delta is 3, and the scrollPixel is 5, the final scrolling pixels are 15.
                 * @param {boolean} [options.enableAccessibility] - Whether to enable the accessibility support in the spreadsheet.
                 * @param {boolean} [options.allowAutoCreateHyperlink] - Whether to enable auto creating hyperlink in the spreadsheet.
                 * @param {GCTYPE.Spread.Sheets.ResizeMode} [options.columnResizeMode] - Specifies the way to resize column.
                 * @param {GCTYPE.Spread.Sheets.ResizeMode} [options.rowResizeMode] - Specifies the way to resize row.
                 * @param {Array} [options.customList] - The list for user to customize drag fill, prioritize matching this list in each fill. Each array item is type of string array.
                 * @param {GCTYPE.Spread.Sheets.ScrollbarAppearance} [options.scrollbarAppearance] - The scrollbar appearance, contains skin and mobile two enums. Default is skin.
                 * @param {boolean} [options.pasteSkipInvisibleRange] - Whether paste skip invisible range. Default is false.
                 * @example
                 * var workbook = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"), {sheetCount:3, font:"12pt Arial"});
                 * var workbook = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"), {sheetCount:3, newTabVisible:false});
                 * var workbook = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"), { sheetCount: 3, tabEditable: false });
                 * var workbook = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"), {sheetCount:3, tabStripVisible:false});
                 * var workbook = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"), {sheetCount:3, allowUserResize:false});
                 * var workbook = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"), { sheetCount: 3, allowUserZoom: false});
                 */
                constructor(host?: HTMLElement | string,  options?: GCTYPE.Spread.Sheets.IWorkBookDefaultOptions);
                /**
                 * ContextMenu for the spread.
                 * @type {GCTYPE.Spread.Sheets.ContextMenu.ContextMenu}
                 * @example
                 * //This example shows how to get contextMenu's menuData.
                 * var menuData = spread.contextMenu.menuData;
                 */
                contextMenu: GCTYPE.Spread.Sheets.ContextMenu.ContextMenu;
                /**
                 * Represents the name of the Spread control.
                 * @type {string}
                 * @example
                 * spread.name = "Spread1";
                 */
                name: string;
                /**
                 * Represents the options of the Spread control.
                 * @type {Object}
                 * @property {boolean} allowUserDragMerge - Whether to allow the user to drag merge cells.<br />
                 * @property {boolean} allowUserDragDrop - Whether to allow the user to drag and drop range data.<br />
                 * @property {boolean} allowUserDragFill - Whether to allow the user to drag fill a range.<br />
                 * @property {boolean} allowUserZoom - Whether to zoom the display by scrolling the mouse wheel while pressing the Ctrl key.<br />
                 * @property {boolean} allowUserResize - Whether to allow the user to resize columns and rows.<br />
                 * @property {boolean} allowUndo - Whether to allow the user to undo edits.<br />
                 * @property {boolean} allowSheetReorder - Whether the user can reorder the sheets in the Spread component.<br />
                 * @property {boolean} allowContextMenu - Whether to allow the user to open the built-in context menu. <br />
                 * @property {boolean} allowUserDeselect -  Whether to allow the user to can use deselect in selection.<br />
                 * @property {GCTYPE.Spread.Sheets.Fill.AutoFillType} defaultDragFillType - The default fill type.<br />
                 * @property {boolean} showDragFillSmartTag - Whether to display the drag fill dialog.<br />
                 * @property {boolean} showHorizontalScrollbar - Whether to display the horizontal scroll bar.<br />
                 * @property {boolean} showVerticalScrollbar - Whether to display the vertical scroll bar.<br />
                 * @property {boolean} scrollbarShowMax - Whether the displayed scroll bars are based on the entire number of columns and rows in the sheet.<br />
                 * @property {boolean} scrollbarMaxAlign - Whether the scroll bar aligns with the last row and column of the active sheet.<br />
                 * @property {boolean} tabStripVisible - Whether to display the sheet tab strip.<br />
                 * @property {number} tabStripRatio - The width of the tab strip expressed as a percentage of the overall horizontal scroll bar width.<br />
                 * @property {number} tabStripWidth - The width of the tab strip when it is at the left or right position. The default and mimimum is 80.<br />
                 * @property {boolean} tabEditable - Whether to allow the user to edit the sheet tab strip.<br />
                 * @property {GCTYPE.Spread.Sheets.TabStripPosition} tabStripPosition - The position of tab strip. The default is bottom.<br />
                 * @property {boolean} newTabVisible - Whether the spreadsheet displays the special tab to let users insert new sheets.<br />
                 * @property {boolean} tabNavigationVisible - Whether to display the sheet tab navigation.<br />
                 * @property {boolean} cutCopyIndicatorVisible - Whether to display an indicator when copying or cutting the selected item.<br />
                 * @property {string} cutCopyIndicatorBorderColor - The border color for the indicator displayed when the user cuts or copies the selection.<br />
                 * @property {string} backColor - A color string used to represent the background color of the Spread component, such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.<br />
                 * @property {string} backgroundImage - The background image of the Spread component.<br />
                 * @property {GCTYPE.Spread.Sheets.ImageLayout} backgroundImageLayout - The background image layout for the Spread component.<br />
                 * @property {string} grayAreaBackColor - A color string used to represent the background color of the gray area , such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.<br />
                 * @property {GCTYPE.Spread.Sheets.ShowResizeTip} showResizeTip - How to display the resize tip.<br />
                 * @property {boolean} showDragDropTip -Whether to display the drag-drop tip.<br />
                 * @property {boolean} showDragFillTip - Whether to display the drag-fill tip.<br />
                 * @property {GCTYPE.Spread.Sheets.ShowScrollTip} showScrollTip - How to display the scroll tip.<br />
                 * @property {boolean} scrollIgnoreHidden - Whether the scroll bar ignores hidden rows or columns.<br />
                 * @property {boolean} highlightInvalidData - Whether to highlight invalid data.<br />
                 * @property {boolean} useTouchLayout - Whether to use touch layout to present the Spread component.<br />
                 * @property {boolean} hideSelection - Whether to display the selection highlighting when the Spread component does not have focus.<br />
                 * @property {GCTYPE.Spread.Sheets.ResizeZeroIndicator} resizeZeroIndicator - The drawing policy when the row or column is resized to zero.<br />
                 * @property {boolean} allowUserEditFormula - Whether the user can edit formulas in a cell in the spreadsheet.<br />
                 * @property {boolean} enableFormulaTextbox - Whether to enable the formula text box in the spreadsheet.<br />
                 * @property {GCTYPE.Spread.Sheets.AutoFitType} autoFitType - Whether content will be formatted to fit in cells or in cells and headers.<br />
                 * @property {GCTYPE.Spread.Sheets.ReferenceStyle} referenceStyle - the style for cell and range references in cell formulas on this sheet.
                 * @property {boolean} allowDynamicArray - Whether to enable dynamic array.
                 * @property {boolean} iterativeCalculation - Whether to enable the iterative calculation.
                 * @property {number} iterativeCalculationMaximumIterations - The Maximum Iterations when iterative calculation.
                 * @property {number} iterativeCalculationMaximumChange - The Maximum Change when iterative calculation.
                 * @property {boolean} calcOnDemand - Whether to calculate formulas only when they are demanded.
                 * @property {boolean} allowCopyPasteExcelStyle - Whether the user can copy style from Spread Sheets then paste to Excel, or copy style from Excel then paste to Spread Sheets.
                 * @property {boolean} allowExtendPasteRange - Whether extend paste range if the paste range is not enough for pasting.
                 * @property {GCTYPE.Spread.Sheets.CopyPasteHeaderOptions} copyPasteHeaderOptions - Which headers are included when data is copied to or pasted.
                 * @property {boolean} scrollByPixel - Whether to enable the precision scrolling by pixel.
                 * @property {number} scrollPixel - Decides scrolling by that number of pixels at a time when scrollByPixel is true. The final scrolling pixels are the result of scrolling delta multiply scrollPixel. For example, the scrolling delta is 3, and the scrollPixel is 5, the final scrolling pixels are 15.
                 * @property {boolean} enableAccessibility - Whether to enable the accessibility support in the spreadsheet.
                 * @property {boolean} allowAutoCreateHyperlink - Whether to enable auto creating hyperlink in the spreadsheet.
                 * @property {GCTYPE.Spread.Sheets.ResizeMode} columnResizeMode - Specifies the way to resize column.
                 * @property {GCTYPE.Spread.Sheets.ResizeMode} rowResizeMode - Specifies the way to resize row.
                 * @property {Array} customList - The list for user to customize drag fill, prioritize matching this list in each fill. Each array item is type of string array.
                 * @property {GCTYPE.Spread.Sheets.ScrollbarAppearance} scrollbarAppearance - The scrollbar appearance, contains skin and mobile two enums. Default is skin.
                 * @property {boolean} pasteSkipInvisibleRange - Whether paste skip invisible range. Default is false.
                 * @example
                 * // var workbook = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:5,showHorizontalScrollbar:false});
                 * var workbook = new GCTYPE.Spread.Sheets.Workbook("ss",{sheetCount:5,showHorizontalScrollbar:false});
                 * workbook.options.allowUserDragDrop = false;
                 * workbook.options.allowUserZoom = false;
                 */
                options: IWorkbookOptions;
                /**
                 * Represents the sheet collection.
                 * @type {Array.<GCTYPE.Spread.Sheets.Worksheet>}
                 */
                sheets: GCTYPE.Spread.Sheets.Worksheet[];
                /**
                 * Represents the touch toolstrip.
                 * @type {GCTYPE.Spread.Sheets.Touch.TouchToolStrip}
                 */
                touchToolStrip: GCTYPE.Spread.Sheets.Touch.TouchToolStrip;
                /**
                 * Adds a custom function.
                 * @param {GCTYPE.Spread.CalcEngine.Functions.Function} fn The function to add.
                 */
                addCustomFunction(fn: GCTYPE.Spread.CalcEngine.Functions.Function): void;
                /**
                 * Adds a custom name.
                 * @param {string} name The custom name.
                 * @param {string} formula The formula.
                 * @param {number} baseRow The row index.
                 * @param {number} baseCol The column index.
                 * @param {string} comment The custom comment.
                 */
                addCustomName(name: string,  formula: string,  baseRow: number,  baseCol: number,  comment: string): void;
                /**
                 * Adds a style to the Workbook named styles collection.
                 * @param {GCTYPE.Spread.Sheets.Style} style The style to be added.
                 */
                addNamedStyle(style: GCTYPE.Spread.Sheets.Style): void;
                /**
                 * Inserts a sheet at the specific index.
                 * @param {number} index The index at which to add a sheet.
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The sheet to be added.
                 * @example
                 * //This example adds a sheet to the spreadsheet.
                 * spread.addSheet(0,new GCTYPE.Spread.Sheets.Worksheet("custom"));
                 */
                addSheet(index: number,  sheet?: GCTYPE.Spread.Sheets.Worksheet): void;
                /**
                 * Inserts a sheet tab at the specific index.
                 * @param {number} index The index at which to add a sheet tab.
                 * @param {string} name The name of sheet tab to be added.
                 * @param {GCTYPE.Spread.Sheets.SheetType} type The type of sheet tab to be added.
                 * @returns {Object} The added sheet tab.
                 */
                addSheetTab(index: number,  name: string,  type: GCTYPE.Spread.Sheets.SheetType): any;
                /**
                 * Adds a SparklineEx to the SparklineEx collection.
                 * @param {GCTYPE.Spread.Sheets.Sparklines.SparklineEx} sparklineEx The SparklineEx to be added.
                 */
                addSparklineEx(sparklineEx: GCTYPE.Spread.Sheets.Sparklines.SparklineEx): void;
                /**
                 * Binds an event to the Workbook.
                 * @param {string} type The event type.
                 * @param {Object} data Specifies additional data to pass along to the function.
                 * @param {Function} fn Specifies the function to run when the event occurs.
                 * @example
                 * //This example binds events to functions.
                 * sheet.setActiveCell(5,5);
                 * alert(sheet.getActiveColumnIndex());
                 * alert(sheet.getActiveRowIndex());
                 * spread.bind(GCTYPE.Spread.Sheets.Events.EnterCell, function (event, data) {
                 *     alert(data.col);
                 *     alert(data.row);
                 *   });
                 * spread.bind(GCTYPE.Spread.Sheets.Events.LeaveCell, function (event, data) {
                 *     alert(data.col);
                 *     alert(data.row);
                 *   });
                 */
                bind(type: string,  data?: any,  fn?: Function): void;
                /**
                 * Change sheet index and reorder sheets.
                 * @param {string} sheetName The sheet name.
                 * @param {number} targetIndex The target index.
                 * @example
                 * //This example show how to change sheet index.
                 * var spread = GCTYPE.Spread.Sheets.findControl(ss);
                 * spread.changeSheetIndex("Sheet1", 3);
                 */
                changeSheetIndex(sheetName: string,  targetIndex: number): boolean;
                /**
                 * Clears all custom functions.
                 */
                clearCustomFunctions(): void;
                /**
                 * Clears custom names.
                 */
                clearCustomNames(): void;
                /**
                 * Clears all sheets in the control.
                 * @example
                 * //This example uses the clearSheets method.
                 * spread.clearSheets();
                 */
                clearSheets(): void;
                /**
                 * Clears all sheet tabs in the control.
                 */
                clearSheetTabs(): void;
                /**
                 * Gets the command manager.
                 * @returns {GCTYPE.Spread.Commands.CommandManager} The command manager.
                 * @example
                 * //This example executes a command that performs a specified action.
                 * spread.options.allowUndo = true;
                 * spread.commandManager().execute({cmd: "outlineRow", sheetName: "Sheet1", index: 3, count: 5});
                 */
                commandManager(): GCTYPE.Spread.Commands.CommandManager;
                /**
                 * Gets the data manager.
                 * @returns {GCTYPE.Data.DataManager} Returns the data manager.
                 */
                dataManager(): GCTYPE.Data.DataManager;
                /**
                 * Destroys the workbook and all sheets it contains.
                 * @example
                 * //This example destroys the workbook instance.
                 * spread.destroy();
                 */
                destroy(): void;
                /**
                 * Makes the Workbook component get focus or lose focus.
                 * @param {boolean} focusIn <c>false</c> makes the Workbook component lose the focus; otherwise, get focus.
                 * @example
                 * //This example sets focus to the Spread control.
                 * $("#button1").click(function () {
                 * spread.focus(true);
                 *    });
                 */
                focus(focusIn?: boolean): void;
                /**
                 * Loads the object state from the specified JSON string.
                 * @param {Object} workbookData The spreadsheet data from deserialization.
                 * @param {Object} [deserializationOptions] - The deserialization options.
                 * @param {boolean} [deserializationOptions.ignoreStyle] - Whether to ignore the style when converting json to the workbook.
                 * @param {boolean} [deserializationOptions.ignoreFormula] - Whether to ignore the formula when converting json to the workbook.
                 * @param {boolean} [deserializationOptions.frozenColumnsAsRowHeaders] - Whether to treat the frozen columns as row headers when converting json to the workbook.
                 * @param {boolean} [deserializationOptions.frozenRowsAsColumnHeaders] - Whether to treat the frozen rows as column headers when converting json to the workbook.
                 * @param {boolean} [deserializationOptions.doNotRecalculateAfterLoad] - Whether to prevent recalculation after loading the json data.
                 * @param {boolean | object} [deserializationOptions.incrementalLoading] - Whether to use the incremental loading or the callbacks of incremental loading when converting json to the workbook.
                 * @param {function} [deserializationOptions.incrementalLoading.loading] - The callback when of the incremental loading progress.
                 * @param {function} [deserializationOptions.incrementalLoading.loaded] - The callback when of the incremental loading finished.
                 * @example
                 * //This example uses the fromJSON method.
                 * activeSheet.getCell(0,0).value(123);
                 * var jsonStr = null;
                 * //export
                 * jsonStr = JSON.stringify(spread.toJSON(false));
                 * //import
                 * spread.fromJSON(JSON.parse(jsonStr));
                 * alert(jsonStr);
                 */
                fromJSON(workbookData: Object,  deserializationOptions?: Object): void;
                /**
                 * Gets the active sheet.
                 * @returns {GCTYPE.Spread.Sheets.Worksheet} The active sheet instance.
                 */
                getActiveSheet(): GCTYPE.Spread.Sheets.Worksheet;
                /**
                 * Gets the active sheet index of the control.
                 * @returns {number} The active sheet index.
                 * @example
                 * //This example uses the getActiveSheetIndex method.
                 * var index = spread.getActiveSheetIndex();
                 * alert(index);
                 */
                getActiveSheetIndex(): number;
                /**
                 * Gets the active sheet tab.
                 * @returns {Object} The active sheet tab instance.
                 */
                getActiveSheetTab(): any;
                /**
                 * Gets the active sheet tab index of the control.
                 * @returns {number} The active sheet tab index.
                 */
                getActiveSheetTabIndex(): number;
                /**
                 *  Gets the all the Circular Reference cell information in the workbook.
                 * @returns {Array.<Object>} Returns circular reference cell information object array
                 * cellsInfo.row {number} Indicates the cellRange row index.
                 * cellsInfo.col {number} Indicates the cellRange col index.
                 * cellsInfo.rowCount {number} Indicates the cellRange row count.
                 * cellsInfo.colCount {number} Indicates the cellRange col count.
                 * cellsInfo.sheetName {string} Indicates the workSheet name.
                 * @example
                 * spread.getCircularReference();
                 */
                getCircularReference(): GCTYPE.Spread.Sheets.ICellsInfo[];
                /**
                 * Gets a custom function.
                 * @param {string} name The custom function name.
                 * @returns {GCTYPE.Spread.CalcEngine.Functions.Function} The custom function.
                 */
                getCustomFunction(name: string): void;
                /**
                 * Gets the specified custom name information.
                 * @param {string} name The custom name.
                 * @returns {GCTYPE.Spread.Sheets.NameInfo} The information for the specified custom name.
                 */
                getCustomName(name: string): GCTYPE.Spread.Sheets.NameInfo;
                /**
                 * Gets all custom name information.
                 * @returns {Array.<GCTYPE.Spread.Sheets.NameInfo>} The type GCTYPE.Spread.Sheets.NameInfo stored in an array.
                 */
                getCustomNames(): GCTYPE.Spread.Sheets.NameInfo[];
                /**
                 * Gets the host element of the current Workbook instance.
                 * @returns {HTMLElement} host The host element of the current Workbook instance.
                 */
                getHost(): HTMLElement;
                /**
                 * Gets a style from the Workbook named styles collection which has the specified name.
                 * @param {string} name The name of the style to return.
                 * @returns {GCTYPE.Spread.Sheets.Style} Returns the specified named style.
                 */
                getNamedStyle(name: string): GCTYPE.Spread.Sheets.Style;
                /**
                 * Gets named styles from the Workbook.
                 * @returns {Array.<GCTYPE.Spread.Sheets.Style>} The GCTYPE.Spread.Sheets.Style array of named styles.
                 */
                getNamedStyles(): GCTYPE.Spread.Sheets.Style[];
                /**
                 * Gets the specified sheet.
                 * @param {number} index The index of the sheet to return.
                 * @returns {GCTYPE.Spread.Sheets.Worksheet} The specified sheet.
                 * @example
                 * //This example gets the sheet and sets the cell forecolor.
                 * var sheet1 = spread.getSheet(1);
                 * sheet1.getCell(0,0).value("A1").foreColor("red");
                 */
                getSheet(index: number): GCTYPE.Spread.Sheets.Worksheet;
                /**
                 * Gets the number of sheets.
                 * @returns {number} The number of sheets.
                 * @example
                 * //This example uses the getSheetCount method.
                 * var index = spread.getSheetCount();
                 * alert(index);
                 */
                getSheetCount(): number;
                /**
                 * Gets the sheet with the specified name.
                 * @param {string} name The sheet name.
                 * @returns {GCTYPE.Spread.Sheets.Worksheet} The sheet with the specified name.
                 * @example
                 * //This example gets the sheet and sets the cell forecolor.
                 * var sheet1 = spread.getSheetFromName("Sheet2");
                 * sheet1.getCell(0,0).value("A1").foreColor("red");
                 */
                getSheetFromName(name: string): GCTYPE.Spread.Sheets.Worksheet;
                /**
                 * Gets the sheet index with the specified name.
                 * @param {string} name The sheet name.
                 * @returns {number} The sheet index.
                 * @example
                 * //This example uses the getSheetIndex method.
                 * var sheet1 = spread.getSheetIndex("Sheet2");
                 * alert(sheet1);
                 */
                getSheetIndex(name: string): number;
                /**
                 * Gets the specified sheet tab by index or name.
                 * @param {number | string} indexOrName The index or name of the sheet tab to return.
                 * @returns {Object} The specified sheet tab.
                 */
                getSheetTab(indexOrName: number | string): any;
                /**
                 * Gets the number of sheet tabs.
                 * @returns {number} The number of sheet tabs.
                 */
                getSheetTabCount(): number;
                /**
                 * Gets the sheet tab index with the specified name.
                 * @param {string} name The sheet tab name.
                 * @returns {number} The sheet tab index.
                 */
                getSheetTabIndex(name: string): number;
                /**
                 * Performs a hit test.
                 * @param {number} x The <i>x</i>-coordinate, x relative to spread horizontal axis.
                 * @param {number} y The <i>y</i>-coordinate, y relative to spread vertical axis.
                 * @returns {Object} The hit test information. If selecting the worksheet, the worksheet information is returned. The information contains x, y, and worksheetHitInfo;
                 * If selecting the sheetsTabStrip, the sheetsTabStrip information is returned. This information contains x, y, and tabStripHitInfo;
                 * If selecting the horizontalScrollbar, the horizontalScrollbar information is returned. This information contains x, y, and horizontalScrollBarHitInfo;
                 * If selecting the verticalScrollbar, the verticalScrollbar information is returned. This information contains x, y, and verticalScrollBarHitInfo;
                 * If selecting the footerCorner, the footerCorner information is returned. This information contains x, y, and footerCornerHitInfo.
                 * @example
                 * //This example uses the hitTest method.
                 *       window.onload = function(){
                 *           var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                 *           var activeSheet = spread.getActiveSheet();
                 *           $("#ss").click(function (e) {
                 *               //Acquire cell index from mouse-clicked point of regular cells which are neither fixed rows/columns nor row/column headers.
                 *               var offset = $("#ss").offset();
                 *               var x = e.pageX - offset.left;
                 *               var y = e.pageY - offset.top;
                 *               var target = spread.hitTest(x, y);
                 *               if(target.worksheetHitInfo) {
                 *                   if(target.worksheetHitInfo.hitTestType === 0) {
                 *                       str = 'corner';
                 *                   } else if (target.worksheetHitInfo.hitTestType === 1) {
                 *                       str = 'colHeader';
                 *                   } else if (target.worksheetHitInfo.hitTestType === 2) {
                 *                       str = 'rowHeader';
                 *                   } else {
                 *                       str = 'viewport';
                 *                   }
                 *               } else if(target.tabStripHitInfo) {
                 *                   if(target.tabStripHitInfo.navButton){
                 *                       str = target.tabStripHitInfo.navButton;
                 *                   } else if(target.tabStripHitInfo.sheetTab) {
                 *                       str = target.tabStripHitInfo.sheetTab.sheetName;
                 *                   } else if(target.tabStripHitInfo.resize === true) {
                 *                       str = "resize";
                 *                   } else {
                 *                       str = "blank";
                 *                   }
                 *               } else if(target.horizontalScrollBarHitInfo) {
                 *                   str = target.horizontalScrollBarHitInfo.element;
                 *               } else if(target.verticalScrollBarHitInfo) {
                 *                   str = target.verticalScrollBarHitInfo.element;
                 *               } else if(target.footerCornerHitInfo) {
                 *                   str = target.footerCornerHitInfo.element;
                 *               }
                 *         alert(str);
                 * });
                 * }
                 */
                hitTest(x: number,  y: number): IWorkbookHitTestInformation;
                /**
                 * Updates the control layout information.
                 * @example
                 * //This example updates the layout.
                 * spread.invalidateLayout();
                 * spread.repaint();
                 */
                invalidateLayout(): void;
                /**
                 * Get if spread paint is suspended.
                 */
                isPaintSuspended(): boolean;
                /**
                 * Gets or sets the next control used by GCTYPE.Spread.Sheets.Actions.selectNextControl and GCTYPE.Spread.Sheets.Actions.moveToNextCellThenControl.
                 * @param {HTMLElement} value The next control. The control must have a focus method.
                 * @returns {HTMLElement|GCTYPE.Spread.Sheets.Workbook} If no value is set, returns the next control; otherwise, returns the spreadsheet.
                 */
                nextControl(value?: HTMLElement): any;
                /**
                 *Get a page info for a sheet
                 * @param {number} sheetIndex The sheet index.
                 * @returns {Object | Array} return a page info for a sheet, If the sheet index is ignored return all sheet's page info in an array
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                 * spread.suspendPaint();
                 * var sheet = spread.getActiveSheet();
                 * for(var i=0;i<20;i++){
                 *    for(var j=0;j<20;j++){
                 *        sheet.setValue(i,j,"Row"+i+"_Column"+j);
                 *    }
                 * }
                 * var pageInfos =  spread.pageInfo(0);
                 * console.table(pageInfos.pages);
                 */
                pageInfo(sheetIndex?: number): any;
                /**
                 * Gets or sets the previous control used by GCTYPE.Spread.Sheets.Actions.selectPreviousControl and GCTYPE.Spread.Sheets.Actions.moveToPreviousCellThenControl.
                 * @param {HTMLElement} value The previous control. The control must have a focus method.
                 * @returns {HTMLElement|GCTYPE.Spread.Sheets.Workbook} If no value is set, returns the previous control; otherwise, returns the spreadsheet.
                 */
                previousControl(value?: HTMLElement): any;
                /**
                 *Prints the specified sheet.
                 *@param {number} sheetIndex The sheet index. If the sheet index is ignored, prints all visible sheets.
                 */
                print(sheetIndex?: number): void;
                /**
                 * Manually refreshes the layout and rendering of the Workbook object.
                 * @example
                 * //This example uses the refresh method.
                 * spread.refresh();
                 */
                refresh(): void;
                /**
                 * Removes a custom function.
                 * @param {string} name The custom function name.
                 */
                removeCustomFunction(name: string): void;
                /**
                 * Removes the specified custom name.
                 * @param {string} name The custom name.
                 * @example
                 * //This example uses the removeCustomName method.
                 * activeSheet.setValue(0, 0, 1);
                 * activeSheet.setValue(0, 1, 2);
                 * activeSheet.setValue(0, 2, 3);
                 * spread.addCustomName("customName1","=12", 0, 0);
                 * activeSheet.setFormula(1, 0, "customName1");
                 * //spread.removeCustomName("customName1");
                 */
                removeCustomName(name: string): void;
                /**
                 * Removes a style from the Workbook named styles collection which has the specified name.
                 * @param {string} name The name of the style to remove.
                 * @example
                 * var namedStyle = new GCTYPE.Spread.Sheets.Style();
                 * namedStyle.name = "style1";
                 * namedStyle.backColor = "green";
                 * spread.addNamedStyle(namedStyle);
                 * activeSheet.setStyleName(1, 1, "style1"); // cell(1,1)'s backColor is  green.
                 * activeSheet.setStyleName(2, 1, "style1");
                 * var style = spread.getNamedStyle("style1");
                 * style.foreColor = "red";    // the namedStyle's foreColor is red.
                 * activeSheet.repaint(); // the foreColor of the cell(1,1) and cell(2,1) is red.
                 * activeSheet.getCell(1,1).value("test");
                 * $("#button1").click(function () {
                 *      spread.removeNamedStyle("style1");
                 * });
                 */
                removeNamedStyle(name: string): void;
                /**
                 * Removes the specified sheet.
                 * @param {number} index The index of the sheet to remove.
                 * @example
                 * //This example removes a sheet from the spreadsheet.
                 * spread.setSheetCount(5);
                 * spread.removeSheet(0);
                 */
                removeSheet(index: number): void;
                /**
                 * Removes the specified sheet tab by index or name.
                 * @param {number | string} indexOrName The index or name of the sheet tab to remove.
                 */
                removeSheetTab(indexOrName: number | string): void;
                /**
                 * Removes a SparklineEx from the SparklineEx collection.
                 * @param {string} name The name of the SparklineEx to remove.
                 */
                removeSparklineEx(name: string): void;
                /**
                 * Repaints the Workbook control.
                 * @example
                 * //This example updates the layout.
                 * spread.invalidateLayout();
                 * spread.repaint();
                 */
                repaint(): void;
                /**
                 * Resumes the calculation service.
                 * @param {boolean} recalcAll Specifies whether to recalculate all formulas.
                 * @example
                 * //This example uses the resumeCalcService method.
                 * spread.suspendCalcService(false);
                 * activeSheet.setValue(0,0,1);
                 * activeSheet.setValue(0,1,2);
                 * activeSheet.setValue(0,2,10);
                 * activeSheet.getCell(1,1).formula("=SUM(A1:C1)");
                 * spread.resumeCalcService(true);
                 */
                resumeCalcService(recalcAll?: boolean): void;
                /**
                 * Resumes the event.
                 * @example
                 * //This example suspends and resumes the event.
                 *  activeSheet.bind(GCTYPE.Spread.Sheets.Events.CellChanged, function (sender, args) {
                 *     if (args.propertyName === "value") {
                 *         alert(activeSheet.getValue(args.row, args.col));
                 *     }
                 * });
                 * spread.suspendEvent();
                 * activeSheet.setValue(0, 0, "111");
                 * spread.resumeEvent();
                 * activeSheet.setValue(1, 1, "222");
                 */
                resumeEvent(): void;
                /**
                 * Resumes the paint of active sheet and tab strip.
                 */
                resumePaint(): void;
                /**
                 *Exports the specified sheet to PDF.
                 *@param {function} successCallback Call this function after successfully export. function (blob) {}.
                 *@param {function} errorCallback Call this function if an error occurs. The exception parameter object structure { errorCode: GCTYPE.Spread.Sheets.PDF.ErrorCode, errorMessage: string}.
                 *@param {Object} [options] The options for export PDF.
                 *@param {string} [options.creator] The name of the application (for example, Adobe FrameMaker\xae) that created the original document from which it was converted.
                 *@param {string} [options.title] The document\u2019s title.
                 *@param {string} [options.author] The name of the person who created the document.
                 *@param {string} [options.keywords] Keywords associated with the document.
                 *@param {string} [options.subject] The subject of the document.
                 *@param {number} sheetIndex The sheet index. If the sheet index is ignored, exports all visible sheets.
                 */
                savePDF(successCallback: Function,  errorCallback: Function,  options?: Object,  sheetIndex?: number): void;
                /**
                 * Searches the text in the cells in the specified sheet for the specified string with the specified criteria.
                 * @param {GCTYPE.Spread.Sheets.Search.SearchCondition} searchCondition The search conditions.
                 * @returns {GCTYPE.Spread.Sheets.Search.SearchResult} The search result.
                 * @example
                 * //This example searches the active sheet using the specified search condition.
                 * activeSheet.getCell(2,3).value("testSearch");
                 * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                 * searchCondition.searchString = "testSearch";
                 * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                 * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                 * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.ignoreCase| GCTYPE.Spread.Sheets.Search.SearchFlags.useWildCards;
                 * var searchresult= spread.search(searchCondition);
                 * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" +
                 * searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundSheetIndex+"]";
                 * alert(str);
                 */
                search(searchCondition: GCTYPE.Spread.Sheets.Search.SearchCondition): GCTYPE.Spread.Sheets.Search.SearchResult;
                /**
                 * Sets the active sheet by name.
                 * @param {string} name The name of the sheet to make the active sheet.
                 * @example
                 * //This example sets the active sheet.
                 * spread.setSheetCount(3);
                 * spread.setActiveSheet("Sheet2");
                 */
                setActiveSheet(name: string): void;
                /**
                 * Sets the active sheet index for the control.
                 * @param {number} value The active sheet index.
                 * @example
                 * //This example uses the setActiveSheetIndex method.
                 * spread.setActiveSheetIndex(1);
                 */
                setActiveSheetIndex(value: number): void;
                /**
                 * Sets the active sheet tab by index or name.
                 * @param {number | string} indexOrName The index or name of the sheet tab to make the active sheet tab.
                 */
                setActiveSheetTab(indexOrName: number | string): void;
                /**
                 * Sets the number of sheets.
                 * @param {number} count The number of sheets.
                 * @example
                 * spread.setSheetCount(5);
                 */
                setSheetCount(count: number): void;
                /**
                 * Gets or sets the index of the first sheet to display in the spreadsheet.
                 * @param {number} value The index of the first sheet to display in the spreadsheet.
                 * @returns {number|GCTYPE.Spread.Sheets.Workbook} If no value is set, returns the index of the first sheet displayed in the spreadsheet; otherwise, returns the spreadsheet.
                 */
                startSheetIndex(value?: number): any;
                /**
                 * Suspends the calculation service.
                 * @param {boolean} ignoreDirty Specifies whether to invalidate the dependency cells.
                 * @example
                 * //This example uses the suspendCalcService method.
                 * spread.suspendCalcService(false);
                 * activeSheet.setValue(0,0,1);
                 * activeSheet.setValue(0,1,2);
                 * activeSheet.setValue(0,2,10);
                 * activeSheet.getCell(1,1).formula("=SUM(A1:C1)");
                 * spread.resumeCalcService(true);
                 */
                suspendCalcService(ignoreDirty?: boolean): void;
                /**
                 * Suspends the event.
                 * @example
                 * //This example suspends and resumes the event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.CellChanged, function (sender, args) {
                 *     if (args.propertyName === "value") {
                 *         alert(activeSheet.getValue(args.row, args.col));
                 *     }
                 * });
                 * spread.suspendEvent();
                 * activeSheet.setValue(0, 0, "111");
                 * spread.resumeEvent();
                 * activeSheet.setValue(1, 1, "222");
                 */
                suspendEvent(): void;
                /**
                 * Suspends the paint of active sheet and tab strip.
                 */
                suspendPaint(): void;
                /**
                 * Saves the object state to a JSON string.
                 * @param {Object} serializationOption - The serialization options.
                 * @param {boolean} [serializationOption.includeBindingSource] - Whether to include the binding source when converting the workbook to json.
                 * @param {boolean} [serializationOption.ignoreStyle] - Whether to ignore the style when converting the workbook to json.
                 * @param {boolean} [serializationOption.ignoreFormula] - Whether to ignore the formula when converting the workbook to json.
                 * @param {boolean} [serializationOption.saveAsView] - Whether to ignore the format string when converting the workbook to json.
                 * @param {boolean} [serializationOption.rowHeadersAsFrozenColumns] - Whether to treat the row headers as frozen columns when converting the workbook to json.
                 * @param {boolean} [serializationOption.columnHeadersAsFrozenRows] - Whether to treat the column headers as frozen rows when converting the workbook to json.
                 * @param {boolean} [serializationOption.includeAutoMergedCells] - Whether to include the automatically merged cells when converting the workbook to json.
                 * @returns {Object} The spreadsheet data.
                 * @example
                 * activeSheet.getCell(0,0).value(123);
                 * var jsonStr = null;
                 * //export
                 * jsonStr = JSON.stringify(spread.toJSON(false));
                 * //import
                 * spread.fromJSON(JSON.parse(jsonStr));
                 * alert(jsonStr);
                 */
                toJSON(serializationOption?: Object): Object;
                /**
                 * Removes the binding of an event to Workbook.
                 * @param {string} type The event type.
                 * @param {Function} fn Specifies the function to run when the event occurs.
                 * @example
                 * //This example removes the event binding.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.CellChanged, function (sender, args) {
                 *     if (args.propertyName === "value") {
                 *         alert(activeSheet.getValue(args.row, args.col));
                 *     }
                 * });
                 * activeSheet.setValue(0, 0, "111");
                 * spread.unbind(GCTYPE.Spread.Sheets.Events.CellChanged);
                 * //spread.unbindAll(); //cancel monitoring of all events.
                 * activeSheet.setValue(1, 0, "222");
                 * activeSheet.setValue(2, 0, "333");
                 * activeSheet.setValue(3, 0, "444");
                 */
                unbind(type: string,  fn?: Function): void;
                /**
                 * Removes the binding of all events to Workbook.
                 * @example
                 * //This example removes the event binding. Uncomment the unbindAll method to remove all event binding.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.CellChanged, function (sender, args) {
                 *     if (args.propertyName === "value") {
                 *         alert(activeSheet.getValue(args.row, args.col));
                 *     }
                 * });
                 * activeSheet.setValue(0, 0, "111");
                 * spread.unbind(GCTYPE.Spread.Sheets.Events.CellChanged);
                 * //spread.unbindAll(); //cancel monitoring of all events.
                 * activeSheet.setValue(1, 0, "222");
                 * activeSheet.setValue(2, 0, "333");
                 * activeSheet.setValue(3, 0, "444");
                 */
                unbindAll(): void;
                /**
                 * Gets the undo manager.
                 * @returns {GCTYPE.Spread.Commands.UndoManager} The undo manager.
                 */
                undoManager(): GCTYPE.Spread.Commands.UndoManager;
            }

            export class Worksheet{
                /**
                 * Represents a worksheet.
                 * @class
                 * @param {string} name The name of the Worksheet.
                 */
                constructor(name: string);
                /**
                 * Indicates whether to generate columns automatically while binding data context.
                 * @type {boolean}
                 * @example
                 * //This example sets a data source for the sheet.
                 *  var test = [
                 *        { "Series0": 2, "Series1": 1 },
                 *        { "Series0": 4, "Series1": 2 },
                 *        { "Series0": 3, "Series1": 4 }
                 *             ];
                 * activeSheet.autoGenerateColumns = true;
                 * activeSheet.setDataSource(test, true);
                 */
                autoGenerateColumns: boolean;
                /** The cellState manager.
                 * @type {GCTYPE.Spread.Sheets.CellState.CellStateManager}
                 */
                cellStates: GCTYPE.Spread.Sheets.CellState.CellStateManager;
                /**
                 * Chart manager for the sheet.
                 * @type {GCTYPE.Spread.Sheets.Charts.ChartCollection}
                 * @example
                 * //This example shows how to add a chart.
                 * var dataRange = "A1:D4";
                 * var chart = activeSheet.charts.add('Chart1', GCTYPE.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 400, dataRange);
                 */
                charts: GCTYPE.Spread.Sheets.Charts.ChartCollection;
                /**
                 * Indicates the column range group.
                 * @type {GCTYPE.Spread.Sheets.Outlines.Outline}
                 */
                columnOutlines: GCTYPE.Spread.Sheets.Outlines.Outline;
                /**
                 * Comment manager for the sheet.
                 * @type {GCTYPE.Spread.Sheets.Comments.CommentManager}
                 */
                comments: GCTYPE.Spread.Sheets.Comments.CommentManager;
                /**
                 * Conditional format manager for the sheet.
                 * @type {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionalFormats}
                 * @example
                 * //This example creates a rule.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * var rule = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                 * rule.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                 * rule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,5,1)]);
                 * rule.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between);
                 * rule.style(style);
                 * rule.value1(2);
                 * rule.value2(100);
                 * activeSheet.conditionalFormats.addRule(rule);
                 * activeSheet.setValue(0,0,1,3);
                 * activeSheet.setValue(1,0,45,3);
                 * var ruletest = activeSheet.conditionalFormats.getRules();
                 * alert(ruletest[0].style().backColor);
                 */
                conditionalFormats: ConditionalFormatting.ConditionalFormats;
                /**
                 * Indicates the default row height and column width of the sheet.
                 * @type {Object}
                 * @example
                 * //This example sets the default row height and column width.
                 * activeSheet.suspendPaint();
                 * activeSheet.defaults.rowHeight = 40;
                 * activeSheet.defaults.colWidth = 30;
                 * activeSheet.resumePaint();
                 */
                defaults: GCTYPE.Spread.Sheets.ISheetDefaultOption;
                /**
                 * FloatingObject manager for the sheet.
                 * @type {GCTYPE.Spread.Sheets.FloatingObjects.FloatingObjectCollection}
                 * @example
                 * //This example creates a floating object.
                 * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                 * var btn = document.createElement('button');
                 * btn.style.width = "60px";
                 * btn.style.height = "30px";
                 * btn.innerText = "button";
                 * customFloatingObject.content(btn);
                 * activeSheet.floatingObjects.add(customFloatingObject);
                 */
                floatingObjects: GCTYPE.Spread.Sheets.FloatingObjects.FloatingObjectCollection;
                /**
                 * Indicates the options of the sheet.
                 * @type {Object}
                 * @property {boolean} allowCellOverflow - Indicates whether data can overflow into adjacent empty cells.
                 * @property {boolean} showFormulas - Indicates whether display the formulas string not the formula result.
                 * @property {string} sheetTabColor - A color string used to represent the sheet tab color, such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.
                 * @property {string} frozenlineColor - A color string used to represent the frozen line color, such as "red", "#FFFF00", "rgb(255,0,0)", "Accent 5", and so on.
                 * @property {GCTYPE.Spread.Sheets.ClipboardPasteOptions} clipBoardOptions - The clipboard option.
                 * @property {Object} gridline - The grid line's options.
                 * @property {string} gridline.color - The grid line color
                 * @property {boolean} gridline.showVerticalGridline - Whether to show the vertical grid line.
                 * @property {boolean} gridline.showHorizontalGridline - Whether to show the horizontal grid line.
                 * @property {boolean} rowHeaderVisible - Indicates whether the row header is visible.
                 * @property {boolean} colHeaderVisible - Indicates whether the column header is visible.
                 * @property {GCTYPE.Spread.Sheets.HeaderAutoText} rowHeaderAutoText - Indicates whether the row header displays letters or numbers or is blank.
                 * @property {GCTYPE.Spread.Sheets.HeaderAutoText} colHeaderAutoText - Indicates whether the column header displays letters or numbers or is blank.
                 * @property {number} rowHeaderAutoTextIndex - Specifies which row header column displays the automatic text when there are multiple row header columns.
                 * @property {number} colHeaderAutoTextIndex - Specifies which column header row displays the automatic text when there are multiple column header rows.
                 * @property {boolean} isProtected - Indicates whether cells on this sheet that are marked as protected cannot be edited.
                 * @property {Object} protectionOptions - A value that indicates the elements that you want users to be able to change.
                 * @property {boolean} [protectionOptions.allowSelectLockedCells] - True or undefined if the user can select locked cells.
                 * @property {boolean} [protectionOptions.allowSelectUnlockedCells] - True or undefined if the user can select unlocked cells.
                 * @property {boolean} [protectionOptions.allowSort] - True if the user can sort ranges.
                 * @property {boolean} [protectionOptions.allowFilter] - True if the user can filter ranges.
                 * @property {boolean} [protectionOptions.allowEditObjects] - True if the user can edit floating objects.
                 * @property {boolean} [protectionOptions.allowResizeRows] - True if the user can resize rows.
                 * @property {boolean} [protectionOptions.allowResizeColumns] - True if the user can resize columns.
                 * @property {boolean} [protectionOptions.allowDragInsertRows] - True if the user can drag to insert rows.
                 * @property {boolean} [protectionOptions.allowDragInsertColumns] - True if the user can drag to insert columns.
                 * @property {boolean} [protectionOptions.allowInsertRows] - True if the user can insert rows.
                 * @property {boolean} [protectionOptions.allowInsertColumns] - True if the user can insert columns.
                 * @property {boolean} [protectionOptions.allowDeleteRows] - True if the user can delete rows.
                 * @property {boolean} [protectionOptions.allowDeleteColumns] - True if the user can delete columns.
                 * @property {boolean} [protectionOptions.allowOutlineColumns] - True if the user can expand or collapse the column groups.
                 * @property {boolean} [protectionOptions.allowOutlineRows] - True if the user can expand or collapse the row groups.
                 * @property {string} selectionBackColor - The selection's background color for the sheet.
                 * @property {string} selectionBorderColor -  The selection's border color for the sheet.
                 * @property {Object} sheetAreaOffset - The sheetAreaOffset's options.
                 * @property {number} sheetAreaOffset.left - The offset left of sheet from host.
                 * @property {number} sheetAreaOffset.top - The offset top of sheet from host.
                 * @example
                 * sheet.setRowCount(2,GCTYPE.Spread.Sheets.SheetArea.colHeader);
                 * sheet.setColumnCount(2,GCTYPE.Spread.Sheets.SheetArea.rowHeader);
                 * sheet.setValue(0, 2,"Column",GCTYPE.Spread.Sheets.SheetArea.colHeader);
                 * sheet.options.colHeaderAutoTextIndex = 1;
                 * sheet.options.colHeaderAutoText = GCTYPE.Spread.Sheets.HeaderAutoText.numbers;
                 */
                options: GCTYPE.Spread.Sheets.IWorksheetOptions;
                /**
                 * Gets the outline column for the sheet.
                 * @returns {GCTYPE.Spread.Sheets.OutlineColumn.OutlineColumn}
                 */
                outlineColumn: GCTYPE.Spread.Sheets.OutlineColumn.OutlineColumn;
                /**
                 * Picture manager for the sheet.
                 * @type {GCTYPE.Spread.Sheets.FloatingObjects.FloatingObjectCollection}
                 * @example
                 * //This example adds a picture.
                 * activeSheet.pictures.add("f2","Event.png",2,2,10,10);
                 * var picture = activeSheet.pictures.get("f2");
                 * picture.pictureStretch(GCTYPE.Spread.Sheets.ImageLayout.center);
                 * picture.backColor("Blue");
                 * picture.borderWidth(2);
                 * picture.borderColor("Red");
                 * picture.borderStyle("dotted");
                 * picture.borderRadius(5);
                 */
                pictures: GCTYPE.Spread.Sheets.FloatingObjects.FloatingObjectCollection;
                /** The pivot table manager.
                 * @type {GCTYPE.Spread.Sheets.PivotTableManager}
                 * @example
                 * //This example creates a pivot table.
                 * var pivotTableManager = sheet.pivotTables;
                 * var sourceData = [["Date","Buyer","Type","Amount"],["01-Jan","Mom","Fuel",74],["15-Jan","Mom","Food",235],["17-Jan","Dad","Sports",20],["21-Jan","Kelly","Books",125],["02-Feb","Mom","Food",235],["20-Feb","Kelly","Music",20],["25-Feb","Kelly","Tickets",125]];
                 * var options = {showRowHeader: true, showColumnHeader: true};
                 * var myPivotTable = pivotTableManager.add("pivotTable_1", sourceData , 1, 1, GCTYPE.Spread.Pivot.PivotTableLayoutType.tabular, GCTYPE.Spread.Pivot.PivotTableThemes.medium2, option);
                 */
                pivotTables: GCTYPE.Spread.Sheets.PivotTableManager;
                /**
                 * Indicates the row range group.
                 * @type {GCTYPE.Spread.Sheets.Outlines.Outline}
                 */
                rowOutlines: GCTYPE.Spread.Sheets.Outlines.Outline;
                /**
                 * Shape manager for the sheet.
                 * @type {GCTYPE.Spread.Sheets.Shapes.ShapeCollection}
                 * @example
                 * //This example shows how to add a shape.
                 * var shape = activeSheet.shapes.add("shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                 */
                shapes: GCTYPE.Spread.Sheets.Shapes.ShapeCollection;
                /** The slicer manager.
                 * @type {GCTYPE.Spread.Sheets.Slicers.SlicerCollection}
                 * @example
                 * //This example adds a slicer.
                 * //create a table
                 * datas = [
                 *     ["1", "NewYork", "1968/6/8", "80", "180"],
                 *     ["4", "NewYork", "1972/7/3", "72", "168"],
                 *     ["4", "NewYork", "1964/3/2", "71", "179"],
                 *     ["5", "Washington", "1972/8/8","80", "171"],
                 *     ["6", "Washington", "1986/2/2", "89", "161"],
                 *     ["7", "Washington", "2012/2/15", "71", "240"]];
                 * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                 * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                 * table.setColumnName(0, dataColumns[0]);
                 * table.setColumnName(1, dataColumns[1]);
                 * table.setColumnName(2, dataColumns[2]);
                 * table.setColumnName(3, dataColumns[3]);
                 * table.setColumnName(4, dataColumns[4]);
                 * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.light4();
                 * //add a slicer to the sheet and return the slicer instance.
                 * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Height");
                 *  //change the slicer properties.
                 * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                 * slicer.disableResizingAndMoving(true);
                 * slicer.style(style1);
                 */
                slicers: GCTYPE.Spread.Sheets.Slicers.SlicerCollection;
                /** The table manager.
                 * @type {GCTYPE.Spread.Sheets.Tables.TableManager}
                 * @example
                 * //This example creates a table.
                 * activeSheet.tables.add("Table1", 0, 0, 3, 3, GCTYPE.Spread.Sheets.Tables.TableThemes.dark1);
                 * activeSheet.getCell(0,0).text("Name");
                 * activeSheet.getCell(0,1).text("Value");
                 * activeSheet.getCell(0,2).text("T/F");
                 * activeSheet.getCell(1,0).text("AW");
                 * activeSheet.getCell(1,1).text("5");
                 * activeSheet.getCell(1,2).text("T");
                 */
                tables: GCTYPE.Spread.Sheets.Tables.TableManager;
                /**
                 * Adds the column or columns to the data model at the specified index.
                 * @param {number} col Column index at which to add the new columns.
                 * @param {number} count The number of columns to add.
                 * @example
                 * //This example adds columns.
                 * sheet.setValue(0, 0, "value");
                 * sheet.addRows(0, 2);
                 * sheet.addColumns(0, 2);
                 * sheet.setRowHeight(0, 50.0,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * sheet.setColumnWidth(0, 150.0,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * sheet.getRange(0, -1, 1, -1,GCTYPE.Spread.Sheets.SheetArea.viewport).backColor("Gray");
                 * sheet.getRange(-1, 0, -1, 1,GCTYPE.Spread.Sheets.SheetArea.viewport).backColor ("Brown");
                 */
                addColumns(col: number,  count: number): void;
                /**
                 * Adds a custom function.
                 * @param {GCTYPE.Spread.CalcEngine.Functions.Function} fn The function to add.
                 */
                addCustomFunction(fn: GCTYPE.Spread.CalcEngine.Functions.Function): void;
                /**
                 * Adds a custom name.
                 * @param {string} name The custom name.
                 * @param {string} formula The formula.
                 * @param {number} baseRow The row index.
                 * @param {number} baseCol The column index.
                 * @param {string} comment The comment.
                 * @example
                 * //This example creates custom names.
                 * sheet.setValue(0, 0, 1);
                 * sheet.setValue(0, 1, 2);
                 * sheet.setValue(0, 2, 3);
                 * sheet.addCustomName("customName1","=12", 0, 0);
                 * sheet.addCustomName("customName2","Average(20,45)", 0, 0);
                 * sheet.addCustomName("customName3", "=$A$1:$C$1", 0, 0);
                 * sheet.setFormula(1, 0, "customName1");
                 * sheet.setFormula(1, 1, "customName2");
                 * sheet.setFormula(1, 2, "sum(customName3)");
                 */
                addCustomName(name: string,  formula: string,  baseRow: number,  baseCol: number,  comment: string): void;
                /**
                 * Adds a style to the Worksheet named styles collection.
                 * @param {GCTYPE.Spread.Sheets.Style} style The style to be added.
                 * @example
                 * var namedStyle = new GCTYPE.Spread.Sheets.Style();
                 * namedStyle.name = "style1";
                 * namedStyle.backColor = "green";
                 * activeSheet.addNamedStyle(namedStyle);
                 * activeSheet.setStyleName(1, 1, "style1"); // cell(1,1)'s backColor is  green.
                 * activeSheet.setStyleName(2, 1, "style1");
                 * var style = activeSheet.getNamedStyle("style1");
                 * style.foreColor = "red";    // the namedStyle's foreColor is red.
                 * activeSheet.repaint(); // the foreColor of the cell(1,1) and cell(2,1) is red.
                 * activeSheet.getCell(1,1).value("test");
                 * $("#button1").click(function () {
                 * activeSheet.removeNamedStyle("style1");
                 *     });
                 */
                addNamedStyle(style: GCTYPE.Spread.Sheets.Style): void;
                /**
                 * Adds rows in this worksheet.
                 * @param {number} row The index of the starting row.
                 * @param {number} count The number of rows to add.
                 * @example
                 * //This example adds rows.
                 * sheet.setValue(0, 0, "value");
                 * sheet.addRows(0, 2);
                 * sheet.addColumns(0, 2);
                 * sheet.setRowHeight(0, 50.0,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * sheet.setColumnWidth(0, 150.0,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * sheet.getRange(0, -1, 1, -1,GCTYPE.Spread.Sheets.SheetArea.viewport).backColor("Gray");
                 * sheet.getRange(-1, 0, -1, 1,GCTYPE.Spread.Sheets.SheetArea.viewport).backColor ("Brown");
                 */
                addRows(row: number,  count: number): void;
                /**
                 * Adds a cell or cells to the selection.
                 * @param {number} row The row index of the first cell to add.
                 * @param {number} column The column index of the first cell to add.
                 * @param {number} rowCount The number of rows to add.
                 * @param {number} columnCount The number of columns to add.
                 * @example
                 * //This example adds a selection and uses the selection in a rule.
                 * sheet.setValue(0,0, 1,3);
                 * sheet.setValue(1,0, 50,3);
                 * sheet.setValue(2,0, 100,3);
                 * sheet.setValue(3,0, 2,3);
                 * sheet.setValue(4,0, 60,3);
                 * sheet.setValue(5,0, 90,3);
                 * sheet.setValue(6,0, 3,3);
                 * sheet.setValue(7,0, 40,3);
                 * sheet.setValue(8,0, 70,3);
                 * sheet.setValue(9,0, 5,3);
                 * sheet.setValue(10,0, 35,3);
                 * sheet.addSelection(0,0,11,1);
                 * sheet.conditionalFormats.add3ScaleRule(1, 10, "red", 0, 50, "blue",2, 100, "yellow", sheet.getSelections());
                 */
                addSelection(row: number,  column: number,  rowCount: number,  columnCount: number): void;
                /**
                 * Adds a span of cells to this sheet in the specified sheet area.
                 * @param {number} row The row index of the cell at which to start the span.
                 * @param {number} column The column index of the cell at which to start the span.
                 * @param {number} rowCount The number of rows to span.
                 * @param {number} colCount The number of columns to span.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @example
                 * //This example creates cell spans.
                 * sheet.setRowCount(4,1);
                 * sheet.setColumnCount(4,2);
                 * sheet.addSpan(0,0,3,3,GCTYPE.Spread.Sheets.SheetArea.colHeader);
                 * sheet.addSpan(0,0,3,3,GCTYPE.Spread.Sheets.SheetArea.rowHeader);
                 * sheet.addSpan(0,0,3,3,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                addSpan(row: number,  col: number,  rowCount: number,  colCount: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Automatically fits the viewport column.
                 * @param {number} column The column index.
                 * @example
                 * //This example sets the column width based on the text.
                 * activeSheet.setValue(0, 1, "testing");
                 * activeSheet.autoFitColumn(1);
                 */
                autoFitColumn(column: number): void;
                /**
                 * Automatically fits the viewport row.
                 * @param {number} row The row index.
                 * @example
                 * //This example sets the row height based on the text.
                 * activeSheet.setValue(0, 1, "testing\r\nmultiple\r\nlines");
                 * activeSheet.getCell(0,1).wordWrap(true);
                 * activeSheet.autoFitRow(0);
                 */
                autoFitRow(row: number): void;
                /**
                 * Applies auto merge for a range.
                 * @param {GCTYPE.Spread.Sheets.Range} range The auto merge range.
                 * @param {GCTYPE.Spread.Sheets.AutoMerge.AutoMergeDirection} direction The auto merge direction. If this parameter is not provided, it defaults to <b>column</b>. Specially, if the direction is <b>none</b>, the auto merge for the range will be canceled.
                 * @param {GCTYPE.Spread.Sheets.AutoMerge.AutoMergeMode} mode The auto merge mode. If this parameter is not provided, it defaults to <b>free</b>.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheet area of the auto merge range. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @param {GCTYPE.Spread.Sheets.AutoMerge.SelectionMode} selectionMode The auto merge selection mode. If this parameter is not provided, it defaults to <b>source</b>.
                 * @returns {Array} If no parameter is provided, returns all auto merge range infos of current worksheet. Each range info contains range, direction, mode, sheetArea, selection mode.
                 * @example
                 * var range = new GCTYPE.Spread.Sheets.Range(-1, 0, -1, 1);
                 * sheet.autoMerge(range);
                 */
                autoMerge(range: GCTYPE.Spread.Sheets.Range,  direction?: GCTYPE.Spread.Sheets.AutoMerge.AutoMergeDirection,  mode?: GCTYPE.Spread.Sheets.AutoMerge.AutoMergeMode,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea,  selectionMode?: GCTYPE.Spread.Sheets.AutoMerge.SelectionMode): GCTYPE.Spread.Sheets.AutoMerge.IRangeInfo[];
                /**
                 * Binds an event to the sheet.
                 * @param {string} type The event type.
                 * @param {Object} data Optional. Specifies additional data to pass along to the function.
                 * @param {Function} fn Specifies the function to run when the event occurs.
                 * @example
                 * //This example binds events.
                 * sheet.bind(GCTYPE.Spread.Sheets.Events.LeftColumnChanged,function(event,data)
                 *   {
                 *     var str = "----------------------------------------\n";
                 *     var title = "Event [LeftColumnChanged ] Fired";
                 *     str = str.substr(0, 4) + title + str.substr(4 + title.length);
                 *     if (typeof data == "object") {
                 *         for (var key in data) {
                 *             str += key + " : " + data[key] + "\n";
                 *           }
                 *       } else {
                 *         str += data + "\n";
                 *       }
                 *       alert(str);
                 *   });
                 * sheet.bind(GCTYPE.Spread.Sheets.Events.TopRowChanged,function(event,data)
                 *   {
                 *         var str = "----------------------------------------\n";
                 *         var title = "Event [TopRowChanged] Fired";
                 *         str = str.substr(0, 4) + title + str.substr(4 + title.length);
                 *         if (typeof data == "object") {
                 *             for (var key in data) {
                 *                 str += key + " : " + data[key] + "\n";
                 *             }
                 *         } else {
                 *             str += data + "\n";
                 *         }
                 *         alert(str);
                 *     });
                 */
                bind(type: string,  data?: any,  fn?: Function): void;
                /**
                 * Binds the column using the specified data field.
                 * @param {number} index The column index.
                 * @param {string|Object} column Column information with data field. If its type is string, it is regarded as name.
                 * @example
                 * var test = [
                 * {"Series0":2,"Series1":1},
                 * {"Series0":4,"Series1":2},
                 * {"Series0":3,"Series1":4}
                 * ];
                 * sheet.setDataSource(test);
                 * sheet.bindColumn(1,"Series0");
                 * sheet.bindColumn(0,"Series1");
                 */
                bindColumn(index: number,  column: string | GCTYPE.Spread.Sheets.IColumn): void;
                /**
                 * Binds the columns using the specified data fields.
                 * @param {Array} columns The array of column information with data fields. If an item's type is string, the item is regarded as name.
                 * @example
                 * var datasource = [
                 *                  { name: "Alice", age: 27, birthday: "1985/08/31", position: "Beijing", isMarried: false},
                 *                  { name: "Aimee", age: 28, birthday: "1984/07/31", position: "Xi'An", isMarried: true},
                 *                  { name: "Charles", age: 29, birthday: "1983/03/31", position: "ShangHai", isMarried: true},
                 *             ];
                 * var colInfos = [
                 *                 { name: "name", displayName: "Name", size: 70, pageBread: false},
                 *                 { name: "age", displayName: "Age", size: 40, resizable: false },
                 *                 { name: "birthday", displayName: "Birthday", formatter: "d/M/yy", size: 120 },
                 *                 { name: "position", displayName: "Position", size: 50, visible: true, value: function (item){
                 *			             return 'China ' + item['position'];
                 *		           }},
                 *                 { name: "isMarried", displayName: "IsMarried", size: 50, visible: true, cellType: new GCTYPE.Spread.Sheets.CellTypes.CheckBox()}
                 *             ];
                 * activeSheet.autoGenerateColumns = true;
                 * activeSheet.setDataSource(datasource);
                 * activeSheet.bindColumns(colInfos);
                 */
                bindColumns(columns: GCTYPE.Spread.Sheets.IColumn[]): void;
                /**
                 * Clears the specified area.
                 * @param {number} row The start row index.
                 * @param {number} column The start column index.
                 * @param {number} rowCount The number of rows to clear.
                 * @param {number} columnCount The number of columns to clear.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} area The area to clear.
                 * @param {GCTYPE.Spread.Sheets.StorageType} storageType The clear type.
                 * @example
                 * //This example clears the data from the specified range.
                 * activeSheet.getCell(0,0).value("A1");
                 * activeSheet.clear(0,0,3,3,GCTYPE.Spread.Sheets.SheetArea.viewport,GCTYPE.Spread.Sheets.StorageType.data);
                 */
                clear(row: number,  column: number,  rowCount: number,  colCount: number,  area: GCTYPE.Spread.Sheets.SheetArea,  storageType: GCTYPE.Spread.Sheets.StorageType): void;
                /**
                 * Clears all custom functions.
                 * @example
                 * //This example clears the custom functions from the active sheet.
                 * activeSheet.clearCustomFunctions();
                 */
                clearCustomFunctions(): void;
                /**
                 * Clears custom names.
                 * @example
                 * //This example creates custom names and then clears them.
                 * activeSheet.setValue(0, 0, 1);
                 * activeSheet.setValue(0, 1, 2);
                 * activeSheet.setValue(0, 2, 3);
                 * activeSheet.addCustomName("customName1","=12", 0, 0);
                 * activeSheet.addCustomName("customName2","Average(20,45)", 0, 0);
                 * activeSheet.addCustomName("customName3", "=$A$1:$C$1", 0, 0);
                 * activeSheet.setFormula(1, 0, "customName1");
                 * activeSheet.setFormula(1, 1, "customName2");
                 * activeSheet.setFormula(1, 2, "sum(customName3)");
                 * activeSheet.clearCustomNames();
                 */
                clearCustomNames(): void;
                /**
                 * Clears the dirty, insert, and delete status from the current worksheet.
                 * @param {Object} [clearChangeInfo] - The clear change info.
                 * @param {number} [clearChangeInfo.row] - The row index of clearing range.
                 * @param {number} [clearChangeInfo.col] - The col index of clearing range.
                 * @param {number} [clearChangeInfo.rowCount] - The row count of clearing range.
                 * @param {number} [clearChangeInfo.colCount] - The col count of clearing range.
                 * @param {GCTYPE.Spread.Sheets.ClearPendingChangeType} [clearChangeInfo.clearType] - The type of clearing pending change, contains dirty/insert/delete, default is dirty.
                 * @example
                 * sheet.clearPendingChanges({clearType: 1, row: 0, rowCount: 3, col: 0, colCount: 4});
                 * sheet.clearPendingChanges({clearType: 2, row: 0, rowCount: 3, col: -1});
                 * sheet.clearPendingChanges({clearType: 4, row: 0, rowCount: 10, col: -1});
                 */
                clearPendingChanges(clearChangeInfo?: GCTYPE.Spread.Sheets.IClearChangeInfo): void;
                /**
                 * Clears the selection.
                 * @example
                 * //This example clears the selection.
                 * sheet.addSelection(4, 0, 2, 2);
                 * sheet.clearSelection();
                 */
                clearSelection(): void;
                /**
                 * Copies data from one range to another.
                 * @param {number} fromRow The source row.
                 * @param {number} fromColumn The source column.
                 * @param {number} toRow The target row.
                 * @param {number} toColumn The target column.
                 * @param {number} rowCount The row count.
                 * @param {number} columnCount The column count.
                 * @param {GCTYPE.Spread.Sheets.CopyToOptions} option The copy option.
                 * @example
                 * //This example copies data to the specified location.
                 * activeSheet.getCell(0,0).value("1");
                 * activeSheet.copyTo(0,0,1,1,2,2,GCTYPE.Spread.Sheets.CopyToOptions.value);
                 */
                copyTo(fromRow: number,  fromColumn: number,  toRow: number,  toColumn: number,  rowCount: number,  columnCount: number,  option: GCTYPE.Spread.Sheets.CopyToOptions): void;
                /**
                 * Gets or sets the current theme for the sheet.
                 * @param {string|GCTYPE.Spread.Common.Theme} value The theme name or the theme.
                 * @returns {GCTYPE.Spread.Sheets.Theme|GCTYPE.Spread.Sheets.Worksheet} If no value is set, returns the current theme; otherwise, returns the worksheet.
                 * @example
                 * //This example sets a theme.
                 * sheet.currentTheme("Civic");
                 */
                currentTheme(value?: string | GCTYPE.Spread.Sheets.Theme): any;
                /**
                 * Deletes the columns in this sheet at the specified index.
                 * @param {number} col The index of the first column to delete.
                 * @param {number} count The number of columns to delete.
                 * @example
                 * activeSheet.getCell(0,0).value("A1");
                 * activeSheet.getCell(0,4).value("Test")
                 * activeSheet.deleteColumns(0,2);
                 * activeSheet.deleteRows(3,1);
                 */
                deleteColumns(col: number,  count: number): void;
                /**
                 * Deletes the rows in this worksheet at the specified index.
                 * @param {number} row The index of the first row to delete.
                 * @param {number} count The number of rows to delete.
                 * @example
                 * activeSheet.getCell(0,0).value("A1");
                 * activeSheet.getCell(0,4).value("Test")
                 * activeSheet.deleteColumns(0,2);
                 * activeSheet.deleteRows(3,1);
                 */
                deleteRows(row: number,  count: number): void;
                /**
                 * Returns the editor's status.
                 * @returns {GCTYPE.Spread.Sheets.EditorStatus} The editor status.
                 */
                editorStatus(): GCTYPE.Spread.Sheets.EditorStatus;
                /**
                 * Stops editing the active cell.
                 * @param {boolean} ignoreValueChange If set to <c>true</c>, does not apply the edited text to the cell.
                 * @returns {boolean} <c>true</c> when able to stop cell editing successfully; otherwise, <c>false</c>.
                 * @example
                 * //This example removes the text "123" when typing in a cell.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.EditChange, function (sender,args) {
                 *                 if (args.editingText === "123") {
                 *                     activeSheet.endEdit(true);
                 *                }
                 *             });
                 */
                endEdit(ignoreValueChange?: boolean): boolean;
                /**
                 * Fills the specified range automatically.
                 * @param {GCTYPE.Spread.Sheets.Range} startRange The fill start range.
                 * @param {GCTYPE.Spread.Sheets.Range} wholeRange The entire range to fill.
                 * @param {Object} options The range fill information.
                 * @param {GCTYPE.Spread.Sheets.Fill.FillType} [options.fillType] - Specifies how to fill the specified range.
                 *      GCTYPE.Spread.Sheets.Fill.FillType.direction:<br />
                 *              Fills the specified range in the specified direction.<br />
                 *      GCTYPE.Spread.Sheets.Fill.FillType.linear:<br />
                 *              Fills the specified range using a linear trend when the source value type is number.<br />
                 *              The next value is generated by the step and stop values.<br />
                 *              The next value is computed by adding the step value to the current cell value.<br />
                 *      GCTYPE.Spread.Sheets.Fill.FillType.growth:<br />
                 *              Fills the specified range using a growth trend when the source value type is number.<br />
                 *              The next value is generated by the step and stop values.<br />
                 *              The next value is computed by multiplying the step value with the current cell.<br />
                 *      GCTYPE.Spread.Sheets.Fill.FillType.date:<br />
                 *              Fills the specified range when the source value type is date.<br />
                 *              The next value is generated by adding the step value to the current value.<br />
                 *              The step value is affected by the fill date unit.<br />
                 *      GCTYPE.Spread.Sheets.Fill.FillType.auto:<br />
                 *              Fills the specified range automatically.<br />
                 *              When the value is a string, the value is copied to other cells.<br />
                 *              When the value is a number, the new value is generated by the TREND formula.<br />
                 * @param {GCTYPE.Spread.Sheets.Fill.FillSeries} [options.series] - The fill series.
                 * @param {GCTYPE.Spread.Sheets.Fill.FillDirection} [options.direction] - direction The fill direction.
                 * @param {number} [options.step] step - The fill step value.
                 * @param {number|Date} [options.stop] stop - The fill stop value.
                 * @param {GCTYPE.Spread.Sheets.Fill.FillDateUnit} [options.unit] - unit The fill date unit.
                 * @example
                 * activeSheet.setValue(0, 0, 5);
                 * var start = new GCTYPE.Spread.Sheets.Range(0, 0, 1, 1);
                 * var r3 = new GCTYPE.Spread.Sheets.Range(0, 0, 4, 1);
                 * activeSheet.fillAuto(start,r3, {fillType:GCTYPE.Spread.Sheets.Fill.FillType.auto, series:GCTYPE.Spread.Sheets.Fill.FillSeries.column, direction:GCTYPE.Spread.Sheets.Fill.FillDirection.down});
                 */
                fillAuto(startRange: GCTYPE.Spread.Sheets.Range,  wholeRange: GCTYPE.Spread.Sheets.Range,  options: GCTYPE.Spread.Sheets.Fill.IFillOptions): void;
                /**
                 * Loads the object state from the specified JSON string.
                 * @param {Object} sheetSettings The sheet data from deserialization.
                 * @example
                 * //This example uses the fromJSON method.
                 * activeSheet.getCell(0,0).value(123);
                 * var jsonStr = null;
                 * //export
                 * jsonStr = JSON.stringify(activeSheet.toJSON());
                 * //import
                 * activeSheet.fromJSON(JSON.parse(jsonStr));
                 * alert(jsonStr);
                 */
                fromJSON(sheetSettings: Object): void;
                /**
                 * Gets or sets the number of frozen columns of the sheet.
                 * @param {number} [colCount] The number of columns to freeze.
                 * @returns {number|GCTYPE.Spread.Sheets.Worksheet} If no value is set, returns the number of frozen columns; otherwise, returns the worksheet.
                 * @example
                 * sheet.frozenColumnCount(1);
                 */
                frozenColumnCount(colCount?: number): any;
                /**
                 * Gets or sets the number of frozen rows of the sheet.
                 * @param {number} [rowCount] The number of rows to freeze.
                 * @returns {number|GCTYPE.Spread.Sheets.Worksheet} If no value is set, returns the number of frozen rows; otherwise, returns the worksheet.
                 * @example
                 * sheet.frozenRowCount(1);
                 */
                frozenRowCount(rowCount?: number): any;
                /**
                 * Gets or sets the number of trailing frozen columns of the sheet.
                 * @param {number} [colCount] The number of columns to freeze at the right side of the sheet.
                 * @param {boolean} [stickToEdge] Whether the frozenTrailingColumn stick to the right edge of viewport area. By default is true.
                 * @returns {number|GCTYPE.Spread.Sheets.Worksheet} If no value is set, returns the number of trailing frozen columns; otherwise, returns the worksheet.
                 * @example
                 * sheet.frozenTrailingColumnCount(1, false);
                 */
                frozenTrailingColumnCount(colCount?: number,  stickToEdge?: boolean): any;
                /**
                 * Gets or sets the number of trailing frozen rows of the sheet.
                 * @param {number} [rowCount] The number of rows to freeze at the bottom of the sheet.
                 * @param {boolean} [stickToEdge] Whether the frozenTrailingRow stick to the bottom edge of viewport area. By default is true.
                 * @returns {number|GCTYPE.Spread.Sheets.Worksheet} If no value is set, returns the number of trailing frozen rows; otherwise, returns the worksheet.
                 * @example
                 * sheet.frozenTrailingRowCount(1, false);
                 */
                frozenTrailingRowCount(rowCount?: number,  stickToEdge?: boolean): any;
                /**
                 * Gets the active column index for this sheet.
                 * @returns {number} The column index of the active cell.
                 * @example
                 * //This example gets the active column.
                 * sheet.setActiveCell(5,5);
                 * alert(sheet.getActiveColumnIndex());
                 * alert(sheet.getActiveRowIndex());
                 * spread.bind(GCTYPE.Spread.Sheets.Events.EnterCell, function (event, data) {
                 *     alert(data.col);
                 *     alert(data.row);
                 *   });
                 * spread.bind(GCTYPE.Spread.Sheets.Events.LeaveCell, function (event, data) {
                 *     alert(data.col);
                 *     alert(data.row);
                 *   });
                 */
                getActiveColumnIndex(): number;
                /**
                 * Gets the active row index for this sheet.
                 * @returns {number} The row index of the active cell.
                 * @example
                 * //This example gets the active row.
                 * sheet.setActiveCell(5,5);
                 * alert(sheet.getActiveColumnIndex());
                 * alert(sheet.getActiveRowIndex());
                 * spread.bind(GCTYPE.Spread.Sheets.Events.EnterCell, function (event, data) {
                 *     alert(data.col);
                 *     alert(data.row);
                 *   });
                 * spread.bind(GCTYPE.Spread.Sheets.Events.LeaveCell, function (event, data) {
                 *     alert(data.col);
                 *     alert(data.row);
                 *   });
                 */
                getActiveRowIndex(): number;
                /**
                 * Gets the actual style information for a specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} column The column index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @param {boolean} [sheetStyleOnly] If <c>true</c>, the row filter and the conditional format style are not applied to the return style;
                 * otherwise, the return style only contains the cell's inherited style.
                 * @returns {GCTYPE.Spread.Sheets.Style} Returns the cell style of the specified cell.
                 * @example
                 * //This example uses the getActualStyle method.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * var cstyle = activeSheet.getActualStyle(1,1,GCTYPE.Spread.Sheets.SheetArea.viewport, true);
                 * alert(cstyle.backColor);
                 */
                getActualStyle(row: number,  column: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea,  sheetStyleOnly?: boolean): GCTYPE.Spread.Sheets.Style;
                /**
                 * Gets an object array from a specified range of cells.
                 * @param {number} row The row index.
                 * @param {number} column The column index.
                 * @param {number} rowCount The row count.
                 * @param {number} colCount The column count.
                 * @param {boolean} getFormula If <c>true</c>, return formulas; otherwise, return values.
                 * @returns {Array.<Array.<Object>>} The object array from the specified range of cells.
                 * @example
                 * //This example uses the getArray method.
                 * //set value
                 * var array = [[1,2,3],[4,5],[6,7,8,9]];
                 * activeSheet.setArray(1, 2, array);
                 * //set formula
                 * var array = [["=1+1","=2+2","=3+3"],["=4+4","=5+5"],["=6+6","=7+7","=8+8","=9+9"]];
                 * activeSheet.setArray(1, 2, array, true);
                 * //get value
                 * var newArray = activeSheet.getArray(1, 2, 3, 4);
                 * //getformula
                 * var newArray = activeSheet.getArray(1, 2, 3, 4, true);
                 * //alert(newArray[0]);
                 */
                getArray(row: number,  column: number,  rowCount: number,  columnCount: number,  getFormula?: boolean): any[];
                /**
                 * Gets the binding path of cell-level binding from the specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @returns {string} Returns the binding path of the cell for cell-level binding.
                 * @example
                 * //This example uses the getBindingPath method.
                 * var person = {name: "Wang feng", age: 25, address: {postcode: "710075"}};
                 * var source = new GCTYPE.Spread.Sheets.Bindings.CellBindingSource(person);
                 * activeSheet.setBindingPath(0, 0, "name");
                 * activeSheet.setBindingPath(1, 1, "age");
                 * activeSheet.setBindingPath(3, 3, "address.postcode");
                 * activeSheet.setDataSource(source);
                 * alert(activeSheet.getBindingPath(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport));
                 */
                getBindingPath(row: number,  col: number): string;
                /**
                 * Gets the specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {GCTYPE.Spread.Sheets.CellRange} The cell.
                 * @example
                 * //This example gets the cell.
                 * activeSheet.getCell(1,1).text("cell object");
                 */
                getCell(row: number,  col: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): GCTYPE.Spread.Sheets.CellRange;
                /**
                 * Gets the rectangle of the cell.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {number} [rowViewportIndex] Index of the row of the viewport: -1 represents column header area, 0 represents frozen row area, 1 represents viewport area, 2 represents trailing frozen row area.
                 * @param {number} [colViewportIndex] Index of the column of the viewport: -1 represents row header area, 0 represents frozen column area, 1 represents viewport area, 2 represents trailing frozen column area.
                 * @returns {GCTYPE.Spread.Sheets.Rect} Object that contains the size and location of the cell rectangle.
                 * @example
                 * //This example uses the getCellRect method.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.CellClick, function (e, info) {
                 *                if (info.sheetArea === GCTYPE.Spread.Sheets.SheetArea.viewport) {
                 *                    alert("Clicked cell index (" + info.row + "," + info.col + ")");
                 *                    //Acquire the coordinate information of regular cells which exist at the specified index position
                 *                    var cellRect = activeSheet.getCellRect(info.row, info.col);
                 *                    alert("X coordinate:" + cellRect.x);
                 *                    alert("Y coordinate:" + cellRect.y);
                 *                    alert("Cell width:" + cellRect.width);
                 *                    alert("Cell height:" + cellRect.height);
                 *                }
                 *            });
                 */
                getCellRect(row: number,  col: number,  rowViewportIndex?: number,  colViewportIndex?: number): GCTYPE.Spread.Sheets.Rect;
                /**
                 * Gets the cell type.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @returns {GCTYPE.Spread.Sheets.CellTypes.Base} Returns the cell type for the specified cell.
                 * @example
                 * //This example gets the cell type.
                 * var cellType = new GCTYPE.Spread.Sheets.CellTypes.Button();
                 * cellType.buttonBackColor("#FFFF00");
                 * cellType.text("this is a button");
                 * activeSheet.getCell(0, 2).cellType(cellType);
                 * var cellType = activeSheet.getCellType(0,2,GCTYPE.Spread.Sheets.SheetArea.viewport)
                 * if (cellType instanceof GCTYPE.Spread.Sheets.CellTypes.Button) {
                 *       alert("This is a ButtonCellType");
                 * }
                 */
                getCellType(row: number,  col: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): GCTYPE.Spread.Sheets.CellTypes.Base;
                /**
                 * Gets the column count in the specified sheet area.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {number} The number of columns.
                 * @example
                 * //This example gets the number of columns.
                 * var count = activeSheet.getColumnCount(GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * alert(count);
                 */
                getColumnCount(sheetArea?: GCTYPE.Spread.Sheets.SheetArea): number;
                /**
                 * Gets whether a forced page break is inserted before the specified column on this sheet when printing.
                 * @param {number} column The column index.
                 * @returns {boolean} <c>true</c> if a forced page break is inserted before the specified column; otherwise, <c>false</c>.
                 */
                getColumnPageBreak(column: number): boolean;
                /**
                 * Gets a value that indicates whether the user can resize a specified column in the specified sheet area.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {boolean} <c>true</c> if the user can resize the specified column; otherwise, <c>false</c>.
                 * @example
                 * //This example gets whether the column is resizable.
                 * sheet.setRowCount(10);
                 * sheet.setColumnCount(7);
                 * sheet.setValue(0, 0,"Western");
                 * sheet.setValue(0, 1,"Western");
                 * sheet.setValue(0, 2,"Western");
                 * sheet.setValue(1, 0,"A");
                 * sheet.setValue(1, 1,"B");
                 * sheet.setValue(1, 2,"C");
                 * sheet.setColumnResizable(0,true, GCTYPE.Spread.Sheets.SheetArea.colHeader);
                 * sheet.setRowResizable(0,true, GCTYPE.Spread.Sheets.SheetArea.rowHeader);
                 * alert( sheet.getColumnResizable(0));
                 * alert( sheet.getRowResizable(0, GCTYPE.Spread.Sheets.SheetArea.rowHeader));
                 */
                getColumnResizable(col: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): boolean;
                /**
                 * Gets whether a column in the specified sheet area is displayed.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {boolean} <c>true</c> if the column is visible in the sheet area; otherwise, <c>false</c>.
                 * @example
                 * //This example returns the visible and width settings for a column.
                 * var visible = activeSheet.getColumnVisible(1, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * var width = activeSheet.getColumnWidth(1, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * alert(visible);
                 * alert(width);
                 */
                getColumnVisible(col: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): boolean;
                /**
                 * Gets the width in pixels or the dynamic size for the specified column in the specified sheet area.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to viewport.
                 * @param {boolean} [getDynamicSize] Whether get the dynamic size. If not given, it defaults to false. If this parameter is true, and dynamic size is not set, will return undefined.
                 * @returns {number | string} The column width in pixels or the dynamic size.
                 * @example
                 * //This example returns the visible and width settings for a column.
                 * var visible = activeSheet.getColumnVisible(1, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * var width = activeSheet.getColumnWidth(1, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * alert(visible);
                 * alert(width);
                 */
                getColumnWidth(col: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea,  getDynamicSize?: boolean): any;
                /**
                 * Gets delimited text from a range.
                 * @param {number} row The start row.
                 * @param {number} column The start column.
                 * @param {number} rowCount The row count.
                 * @param {number} columnCount The column count.
                 * @param {string} rowDelimiter The row delimiter that is appended to the end of the row.
                 * @param {string} columnDelimiter The column delimiter that is appended to the end of the column.
                 * @returns {string} The text from the range with the specified delimiters.
                 */
                getCsv(row: number,  column: number,  rowCount: number,  columnCount: number,  rowDelimiter: string,  columnDelimiter: string): string;
                /**
                 * Gets a custom function.
                 * @param {string} fnName The custom function name.
                 * @returns {GCTYPE.Spread.CalcEngine.Functions.Function} The custom function.
                 */
                getCustomFunction(name: string): void;
                /**
                 * Gets the specified custom name information.
                 * @param {string} fnName The custom name.
                 * @returns {GCTYPE.Spread.Sheets.NameInfo} The information for the specified custom name.
                 * @example
                 * //This example gets the custom name and formula.
                 * activeSheet.setValue(0, 0, 1);
                 * activeSheet.setValue(0, 1, 2);
                 * activeSheet.setValue(0, 2, 3);
                 * activeSheet.addCustomName("customName1", "=12", 0, 0);
                 * activeSheet.addCustomName("customName2", "Average(20,45)", 0, 0);
                 * activeSheet.addCustomName("customName3", "=$A$1:$C$1");
                 * activeSheet.setFormula(1, 0, "customName1");
                 * activeSheet.setFormula(1, 1, "customName2");
                 * activeSheet.setFormula(1, 2, "sum(customName3)");
                 * $("#button1").click(function () {
                 *     var cname = activeSheet.getCustomName("customName2");
                 *     if (cname instanceof GCTYPE.Spread.Sheets.NameInfo) {
                 *         //get CustomName
                 *         var name = cname.getName();
                 *         //get Expression
                 *         var expression = cname.getExpression();
                 *         //get Expression String
                 *         var expStr = GCTYPE.Spread.Sheets.CalcEngine.expressionToFormula(activeSheet, expression, 0, 0);
                 *         alert("Name:" + name + ";Expression: =" + expStr);
                 *     }
                 * });
                 */
                getCustomName(name: string): GCTYPE.Spread.Sheets.NameInfo;
                /**
                 * Gets all custom name information.
                 * @returns {Array.<GCTYPE.Spread.Sheets.NameInfo>} The type GCTYPE.Spread.Sheets.NameInfo stored in an array.
                 */
                getCustomNames(): GCTYPE.Spread.Sheets.NameInfo[];
                /**
                 * Gets the column name at the specified position.
                 * @param {number} column The column index for which the name is requested.
                 * @returns {string} The column name for data binding.
                 * @example
                 * //This example returns the name for the specified bound column.
                 * var test = [
                 *         {"Series0":2,"Series1":1},
                 *         {"Series0":4,"Series1":2},
                 *         {"Series0":3,"Series1":4}
                 *     ];
                 * activeSheet.setDataSource(test);
                 * activeSheet.bindColumn(1,"Series0");
                 * activeSheet.bindColumn(0,"Series1");
                 * var colname = activeSheet.getDataColumnName(0);
                 * alert(colname);
                 */
                getDataColumnName(column: number): string;
                /**
                 * Gets the data item.
                 * @param {number} row The row index.
                 * @returns {Object} The row data.
                 * @example
                 * //This example uses the getDataItem method.
                 * var test = [
                 *       { "Series0": 2, "Series1": 1 },
                 *       { "Series0": 4, "Series1": 2 },
                 *       { "Series0": 3, "Series1": 4 }
                 *            ];
                 *            activeSheet.autoGenerateColumns = true;
                 *            activeSheet.setDataSource(test, false);
                 *            alert(JSON.stringify(activeSheet.getDataItem(0)));
                 */
                getDataItem(row: number): any;
                /**
                 * Gets the data source that populates the sheet.
                 * @function
                 * @returns {Object} Returns the data source.
                 * @example
                 * var test = [
                 *         {"Series0":2,"Series1":1},
                 *         {"Series0":4,"Series1":2},
                 *         {"Series0":3,"Series1":4}
                 *     ];
                 * activeSheet.setDataSource(test);
                 * alert(activeSheet.getDataSource);
                 */
                getDataSource(): any;
                /**
                 * Gets the cell data validator.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @returns {GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} Returns the cell data validator for the specified cell.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GCTYPE.Spread.Sheets.DataValidation.createListValidator("1,2,3");
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Value must be 1,2 or 3");
                 * dv.inputTitle("tip");
                 * activeSheet.setDataValidator(1,1,1,1,dv,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * alert(activeSheet.getDataValidator(1,1).getValidList(activeSheet,1,1));
                 */
                getDataValidator(row: number,  col: number,  sheetArea: GCTYPE.Spread.Sheets.SheetArea): GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator;
                /**
                 * Gets the default style information for the sheet.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @returns {GCTYPE.Spread.Sheets.Style} Returns the sheet's default style.
                 * @example
                 * //This example uses the getDefaultStyle method.
                 * var defaultStyle = new GCTYPE.Spread.Sheets.Style();
                 * defaultStyle.backColor = "LemonChiffon";
                 * defaultStyle.foreColor = "Red";
                 * defaultStyle.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("Green");
                 * defaultStyle.borderTop = new GCTYPE.Spread.Sheets.LineBorder("Green");
                 * defaultStyle.borderRight = new GCTYPE.Spread.Sheets.LineBorder("Green");
                 * defaultStyle.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("Green");
                 * activeSheet.setDefaultStyle(defaultStyle, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * var cstyle = activeSheet.getDefaultStyle(GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * alert(cstyle.backColor);
                 */
                getDefaultStyle(sheetArea?: GCTYPE.Spread.Sheets.SheetArea): GCTYPE.Spread.Sheets.Style;
                /**
                 * Gets the deleted row collection.
                 * @return {Array.<Object>} The deleted rows collection. the item in array contains two properties, row.row: specifies deleted row index, row.originalItem: specifies deleted data item.
                 */
                getDeletedRows(): any[];
                /**
                 *  Gets the dependent CellRange information object array of the cell.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @returns {Array.<Object>} Returns dependent cell information object array
                 * dependentsInfo.row {number} Indicates the cellRange row index.
                 * dependentsInfo.col {number} Indicates the cellRange col index.
                 * dependentsInfo.rowCount {number} Indicates the cellRange row count.
                 * dependentsInfo.colCount {number} Indicates the cellRange colcount.
                 * dependentsInfo.sheetName {string} Indicates the workSheet name.
                 * @example
                 * sheet.getDependents(1, 1);
                 */
                getDependents(row: number,  col: number): GCTYPE.Spread.Sheets.ICellsInfo[];
                /**
                 * Gets the dirty cell collection.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {number} rowCount The number of rows in the range of dirty cells.
                 * @param {number} colCount The number of columns in the range of dirty cells.
                 * @return {Array} The dirty cells.
                 */
                getDirtyCells(row: number,  col: number,  rowCount: number,  colCount: number): GCTYPE.Spread.Sheets.IDirtyCellInfo[];
                /**
                 * Gets the dirty row collection.
                 * @returns {Array.<Object>} The dirty rows collection, the item in array contains three properties, row.row: specifies row index, row.item: specifies data item of current row, row.originalItem: specifies original data item of the row.
                 */
                getDirtyRows(): any[];
                /**
                 * Gets the cell formatter.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @returns {string|GCTYPE.Spread.Formatter.FormatterBase} Returns the cell formatter string or object for the specified cell.
                 * @example
                 * //This example returns the format object for the active sheet.
                 * activeSheet.getCell(0, 1).formatter("M");
                 * activeSheet.setValue(0, 1, new Date(2011, 2, 9));
                 * var style = activeSheet.getFormatter(0,1,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * alert(style);
                 */
                getFormatter(row: number,  col: number,  sheetArea: GCTYPE.Spread.Sheets.SheetArea): any;
                /**
                 * Gets the formula in the specified cell in this sheet.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If you do not provide this parameter, it defaults to <b>viewport</b>.
                 * @returns {string} Returns the formula string.
                 * @example
                 * //This example returns the formula in the specified cell.
                 * activeSheet.setValue(0,0,1);
                 * activeSheet.setValue(0,1,2);
                 * activeSheet.setValue(0,2,10);
                 * activeSheet.getCell(1,1).formula("=SUM(A1:C1)");
                 * var formula = activeSheet.getFormula(1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * alert(formula);
                 */
                getFormula(row: number,  col: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): string;
                /**
                 * Gets the formula detail information in the specified cell in this sheet.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @returns {Object} formulaInfo - Returns the formula information about the cell.
                 * formulaInfo.hasFormula {boolean} Indicates whether there is a formula in the cell.
                 * formulaInfo.isArrayFormula {boolean} Indicates whether the formula is an array formula.
                 * formulaInfo.formula {string} The formula string.
                 * formulaInfo.formulaWithCulture {string} The formula string with culture.
                 * @example
                 * activeSheet.setValue(0,0,1);
                 * activeSheet.setValue(0,1,2);
                 * activeSheet.setValue(0,2,10);
                 * activeSheet.getCell(1,1).formula("=SUM(A1:C1)");
                 * var test = activeSheet.getFormulaInformation(1,1, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * alert(test.formula);
                 */
                getFormulaInformation(row: number,  col: number): GCTYPE.Spread.Sheets.IFormulaInfo;
                /**
                 * Sets the hyperlink data for the specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @example
                 * //This example uses the getHyperlink method.
                 * let firstHyperlinkData = sheet.getHyperlink(0, 2, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * let secondHyperlinkData = sheet.setHyperlink(1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                getHyperlink(row: number,  col: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): GCTYPE.Spread.Sheets.IHyperlink;
                /**
                 * Gets the inserted row collection.
                 * @returns {Array.<Object>} The inserted rows collection, the item in array contains two properties, row.row: specifies insert row index, row.item: specifies insert data item.
                 */
                getInsertRows(): any[];
                /**
                 * Gets a style from the Worksheet named styles collection which has the specified name.
                 * @param {string} name The name of the style to return.
                 * @returns {GCTYPE.Spread.Sheets.Style} Returns the specified named style.
                 */
                getNamedStyle(name: string): GCTYPE.Spread.Sheets.Style;
                /**
                 * Gets named styles from the Worksheet.
                 * @returns {Array.<GCTYPE.Spread.Sheets.Style>} The GCTYPE.Spread.Sheets.Style array of named styles.
                 */
                getNamedStyles(): GCTYPE.Spread.Sheets.Style[];
                /**
                 * Gets the parent Spread object of the current sheet.
                 * @returns {GCTYPE.Spread.Sheets.Workbook} Returns the parent Spread object of the current sheet.
                 */
                getParent(): GCTYPE.Spread.Sheets.Workbook;
                /**
                 *  Gets the precedent CellRange information object array of the cell.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @returns {Array.<Object>} Returns precedent cellRange information object array
                 * precedentsInfo.row {number} Indicates the cellRange row index.
                 * precedentsInfo.col {number} Indicates the cellRange col index.
                 * precedentsInfo.rowCount {number} Indicates the cellRange row count.
                 * precedentsInfo.colCount {number} Indicates the cellRange colcount.
                 * precedentsInfo.sheetName {string} Indicates the workSheet name.
                 * @example
                 * sheet.getPrecedents(1, 1);
                 */
                getPrecedents(row: number,  col: number): GCTYPE.Spread.Sheets.ICellsInfo[];
                /**
                 * Gets a range of cells by row info and column info in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {number} rowCount The row count of the range. If you do not provide this parameter, it defaults to <b>1</b>.
                 * @param {number} colCount The column count of the range. If you do not provide this parameter, it defaults to <b>1</b>.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {GCTYPE.Spread.Sheets.CellRange} The cellRange.
                 * If row is -1 and rowCount is -1, the range represents columns. For example, sheet.getRange(-1,4,-1,6) returns the columns "E:J".
                 * If col is -1 and colCount is -1, the range represents rows. For example, sheet.getRange(4,-1,6,-1) returns the rows "5:10".
                 */
                getRange(row: number,  col: number,  rowCount?: number,  colCount?: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): GCTYPE.Spread.Sheets.CellRange;
                /**
                 * Gets a range of cells by A1 style address(not support R1C1 style) in the specified sheet area.
                 * @param {string} address The range address string. For example "C1", "A:C", "A1:C3", "1:3".
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {GCTYPE.Spread.Sheets.CellRange} The cellRange.
                 * @example
                 * // Get a single cell, it equals to sheet.getRange(0, 0, 1, 1)
                 * sheet.getRange("A1")
                 * // Get whole columns, it equals to sheet.getRange(-1, 0, -1, 3)
                 * sheet.getRange("A:C")
                 * // Get whole rows, it equals to sheet.getRange(0, -1, 3, -1)
                 * sheet.getRange("1:3")
                 * // Get a range, it equals to sheet.getRange(0, 0, 3, 3)
                 * sheet.getRange("A1:C3")
                 */
                getRange(address: string,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): GCTYPE.Spread.Sheets.CellRange;
                /**
                 * Gets the row count in the specified sheet area.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {number} The number of rows.
                 * @example
                 * //This example gets the row count.
                 * var count = activeSheet.getRowCount(GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * alert(count);
                 */
                getRowCount(sheetArea?: GCTYPE.Spread.Sheets.SheetArea): number;
                /**
                 * Gets the height in pixels or the dynamic size for the specified row in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @param {boolean} [getDynamicSize] Whether get the dynamic size. If not given, it defaults to false. If this parameter is true, and dynamic size is not set, will return undefined.
                 * @returns {number | string} The row height in pixels or the dynamic size.
                 * @example
                 * //This example returns the height for the specified row.
                 * var rheight = activeSheet.getRowHeight(1,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * alert(rheight);
                 */
                getRowHeight(row: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea,  getDynamicSize?: boolean): any;
                /**
                 * Gets whether a forced page break is inserted before the specified row on this sheet when printing.
                 * @param {number} row The row index.
                 * @returns {boolean} <c>true</c> if a forced page break is inserted before the specified row; otherwise, <c>false</c>.
                 */
                getRowPageBreak(row: number): boolean;
                /**
                 * Gets a value that indicates whether users can resize the specified row in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {boolean} <c>true</c> if the users can resize the specified row; otherwise, <c>false</c>.
                 * @example
                 * //This example gets whether the row is resizable.
                 * sheet.setRowCount(10);
                 * sheet.setColumnCount(7);
                 * sheet.setValue(0, 0,"Western");
                 * sheet.setValue(0, 1,"Western");
                 * sheet.setValue(0, 2,"Western");
                 * sheet.setValue(1, 0,"A");
                 * sheet.setValue(1, 1,"B");
                 * sheet.setValue(1, 2,"C");
                 * sheet.setColumnResizable(0,true, GCTYPE.Spread.Sheets.SheetArea.colHeader);
                 * sheet.setRowResizable(0,true, GCTYPE.Spread.Sheets.SheetArea.rowHeader);
                 * alert( sheet.getColumnResizable(0));
                 * alert( sheet.getRowResizable(0, GCTYPE.Spread.Sheets.SheetArea.rowHeader));
                 */
                getRowResizable(row: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): boolean;
                /**
                 * Gets whether the control displays the specified row.
                 * @param {number} row The row index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {boolean} <c>true</c> if the row is visible in the sheet area; otherwise, <c>false</c>.
                 * @example
                 * //This example returns the visible setting for the specified row.
                 * rvisible = activeSheet.getRowVisible(1,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * alert(rvisible);
                 */
                getRowVisible(row: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): boolean;
                /**
                 * Gets the selections in the current sheet.
                 * @returns {Array.<GCTYPE.Spread.Sheets.Range>} The type GCTYPE.Spread.Sheets.Range is stored in an Array.
                 */
                getSelections(): GCTYPE.Spread.Sheets.Range[];
                /**
                 * Gets the spans in the specified range in the specified sheet area.
                 * @param {GCTYPE.Spread.Sheets.Range} range The cell range.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @returns {Array.<GCTYPE.Spread.Sheets.Range>} An array that contains span information whose item type is GCTYPE.Spread.Sheets.Range.
                 */
                getSpans(range?: GCTYPE.Spread.Sheets.Range,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): GCTYPE.Spread.Sheets.Range[];
                /**
                 *  Gets the sparkline for the specified cell.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @returns {GCTYPE.Spread.Sheets.Sparkline} The sparkline for the cell.
                 * @example
                 * //This example creates and gets a sparkline.
                 * var cellr = new GCTYPE.Spread.Sheets.Range(0, 0, 1, 5);
                 * var ex = new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting();
                 * ex.options.SeriesColor  = "Aquamarine";
                 * sheet.setValue(0, 0, 2);
                 * sheet.setValue(0, 1, 5);
                 * sheet.setValue(0, 2, 4);
                 * sheet.setValue(0, 3, -1);
                 * sheet.setValue(0, 4, 3);
                 * sheet.setSparkline(0, 5, cellr, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.horizontal, GCTYPE.Spread.Sheets.Sparklines.SparklineType.column, ex);
                 * alert(sheet.getSparkline(0, 5).toString());
                 * //sheet.removeSparkline(0, 5);
                 */
                getSparkline(row: number,  column: number): GCTYPE.Spread.Sheets.Sparklines.Sparkline;
                /**
                 * Gets the style information for a specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} column The column index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @returns {GCTYPE.Spread.Sheets.Style} Returns the cell style of the specified cell.
                 * @example
                 * //This example uses the getStyle method.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * var cstyle = activeSheet.getStyle(1,1,GCTYPE.Spread.Sheets.SheetArea.viewport, true);
                 * alert(cstyle.backColor);
                 */
                getStyle(row: number,  column: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): GCTYPE.Spread.Sheets.Style;
                /**
                 * Gets the name of the style for a specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} column The column index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @returns {string} Returns the name string for the style.
                 * @example
                 * //This example uses the getStyleName method.
                 * var namedStyle = new GCTYPE.Spread.Sheets.Style();
                 * namedStyle.name = "style1";
                 * namedStyle.backColor = "green";
                 * activeSheet.addNamedStyle(namedStyle);
                 * activeSheet.setStyleName(1, 1, "style1"); // cell(1,1)'s backColor is  green.
                 * activeSheet.setStyleName(2, 1, "style1");
                 * alert(activeSheet.getStyleName(1,1,GCTYPE.Spread.Sheets.SheetArea.viewport));
                 */
                getStyleName(row: number,  column: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): string;
                /**
                 * Gets the tag value from the specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @returns {Object} Returns the tag value of the cell.
                 * @example
                 * //This example adds and gets a cell tag.
                 * activeSheet.getRange(1, -1, 1, -1).tag("row tag");
                 * alert(activeSheet.getTag(1,-1,GCTYPE.Spread.Sheets.SheetArea.viewport));
                 */
                getTag(row: number,  col: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): any;
                /**
                 * Gets the formatted text in the cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @returns {string} Returns the formatted text of the cell.
                 * @example
                 * activeSheet.getText(1, 0);
                 */
                getText(row: number,  col: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): string;
                /**
                 * Gets the unformatted data from the specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @param {GCTYPE.Spread.Sheets.ValueType} [valueType] - Indicate the return value type is normal text or rich text, default is normal text.
                 * @returns {Object} Returns the value of the cell.
                 * @example
                 * activeSheet.getValue(1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport, GCTYPE.Spread.Sheets.ValueType.richText);
                 */
                getValue(row: number,  col: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea,  valueType?: GCTYPE.Spread.Sheets.ValueType): any;
                /**
                 * Gets the index of the bottom row in the viewport.
                 * @param {number} rowViewportIndex The index of the viewport.
                 * @returns {number} The index of the bottom row in the viewport.
                 * @example
                 * //This example returns the indices for the bottom and top rows and left and right columns in the current sheet view.
                 * var brow = activeSheet.getViewportBottomRow(1);
                 * var lcol = activeSheet.getViewportLeftColumn(1);
                 * var rcol = activeSheet.getViewportRightColumn(1);
                 * var trow = activeSheet.getViewportTopRow(1);
                 * alert(brow);
                 * alert(lcol);
                 * alert(rcol);
                 * alert(trow);
                 */
                getViewportBottomRow(rowViewportIndex: number): number;
                /**
                 * Gets the height of the specified viewport row for the active sheet.
                 * @param {number} rowViewportIndex The index of the row viewport.
                 * @returns {number} The height of the viewport.
                 * @example
                 * //This example uses the getViewportHeight method.
                 * alert(activeSheet.getViewportHeight(1));
                 */
                getViewportHeight(rowViewportIndex: number): number;
                /**
                 * Gets the index of the left column in the viewport.
                 * @param {number} columnViewportIndex The index of the viewport.
                 * @returns {number} The index of the left column in the viewport.
                 * @example
                 * //This example returns the indices for the bottom and top rows and left and right columns in the current sheet view.
                 * var brow = activeSheet.getViewportBottomRow(1);
                 * var lcol = activeSheet.getViewportLeftColumn(1);
                 * var rcol = activeSheet.getViewportRightColumn(1);
                 * var trow = activeSheet.getViewportTopRow(1);
                 * alert(brow);
                 * alert(lcol);
                 * alert(rcol);
                 * alert(trow);
                 */
                getViewportLeftColumn(columnViewportIndex: number): number;
                /**
                 * Gets the index of the right column in the viewport.
                 * @param {number} columnViewportIndex The index of the viewport.
                 * @returns {number} The index of the right column in the viewport.
                 * @example
                 * //This example returns the indices for the bottom and top rows and left and right columns in the current sheet view.
                 * var brow = activeSheet.getViewportBottomRow(1);
                 * var lcol = activeSheet.getViewportLeftColumn(1);
                 * var rcol = activeSheet.getViewportRightColumn(1);
                 * var trow = activeSheet.getViewportTopRow(1);
                 * alert(brow);
                 * alert(lcol);
                 * alert(rcol);
                 * alert(trow);
                 */
                getViewportRightColumn(columnViewportIndex: number): number;
                /**
                 * Gets the index of the top row in the viewport.
                 * @param {number} rowViewportIndex The index of the viewport.
                 * @returns {number} The index of the top row in the viewport.
                 * @example
                 * //This example returns the indices for the bottom and top rows and left and right columns in the current sheet view.
                 * var brow = activeSheet.getViewportBottomRow(1);
                 * var lcol = activeSheet.getViewportLeftColumn(1);
                 * var rcol = activeSheet.getViewportRightColumn(1);
                 * var trow = activeSheet.getViewportTopRow(1);
                 * alert(brow);
                 * alert(lcol);
                 * alert(rcol);
                 * alert(trow);
                 */
                getViewportTopRow(rowViewportIndex: number): number;
                /**
                 * Gets the width of the specified viewport column for the active sheet.
                 * @param {number} columnViewportIndex The index of the column viewport.
                 * @returns {number} The width of the viewport
                 * @example
                 * //This example uses the getViewportWidth method.
                 * alert(activeSheet.getViewportWidth(1));
                 */
                getViewportWidth(columnViewportIndex: number): number;
                /**
                 * Groups the sparklines.
                 * @param {Array.<GCTYPE.Spread.Sheets.Sparklines.Sparkline>} sparklines The sparklines to group.
                 * @returns {GCTYPE.Spread.Sheets.Sparklines.SparklineGroup} The sparkline group.
                 * @example
                 * //This example groups a sparkline.
                 * sheet.setValue(0, 0, "Data Range is A2-A9");
                 * sheet.setValue(1, 0, 1);
                 * sheet.setValue(2, 0, -2);
                 * sheet.setValue(3, 0, -1);
                 * sheet.setValue(4, 0, 6);
                 * sheet.setValue(5, 0, 4);
                 * sheet.setValue(6, 0, -4);
                 * sheet.setValue(7, 0, 3);
                 * sheet.setValue(8, 0, 8);
                 * var data = new GCTYPE.Spread.Sheets.Range(1, 0, 8, 1);
                 * var setting = new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting();
                 * var s1=  sheet.setSparkline(13, 0, data
                 *         , GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical
                 *         , GCTYPE.Spread.Sheets.Sparklines.SparklineType.line
                 *         , setting
                 *         );
                 * var s2 =sheet.setSparkline(13, 3, data
                 *         , GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical
                 *         , GCTYPE.Spread.Sheets.Sparklines.SparklineType.column
                 *         , setting
                 *         );
                 * var s3=  sheet.setSparkline(13, 6, data
                 *         , GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical
                 *         , GCTYPE.Spread.Sheets.Sparklines.SparklineType.winloss
                 *         , setting
                 *         );
                 * var group = sheet.groupSparkline([s1,s2,s3]);
                 */
                groupSparkline(sparklines: Sparklines.Sparkline[]): GCTYPE.Spread.Sheets.Sparklines.SparklineGroup;
                /**
                 * Gets whether there is a dirty, insert, or delete status for the specified range.
                 * @returns {boolean} <c>true</c> if any of the rows or cells in the range are dirty, or have been inserted or deleted; otherwise, <c>false</c>.
                 */
                hasPendingChanges(): boolean;
                /**
                 * Performs a hit test.
                 * @param {number} x The <i>x</i>-coordinate.
                 * @param {number} y The <i>y</i>-coordinate.
                 * @returns {Object} The hit test information.
                 */
                hitTest(x: number,  y: number): GCTYPE.Spread.Sheets.IHitTestInformation;
                /**
                 * Invalidates the sheet layout.
                 * @example
                 * //This example updates the layout.
                 * activeSheet.columnOutlines.group(0, 1);
                 * activeSheet.invalidateLayout();
                 * activeSheet.repaint();
                 */
                invalidateLayout(): void;
                /**
                 * Gets whether recording the dirty data is suspended.
                 * @returns {boolean} Whether the dirty data is suspended.
                 * @example
                 * //This example uses the isDirtySuspended method.
                 * var customers = [
                 *                { ID: 0, Name: 'A', Info1: 'Info0' },
                 *                { ID: 1, Name: 'B', Info1: 'Info1' },
                 *                { ID: 2, Name: 'C', Info1: 'Info2' },
                 *             ];
                 * activeSheet.setDataSource(customers);
                 * activeSheet.suspendDirty();
                 * alert(activeSheet.isDirtySuspended());
                 * activeSheet.resumeDirty();
                 * alert(activeSheet.isDirtySuspended());
                 */
                isDirtySuspended(): boolean;
                /**
                 * Gets whether the sheet is in edit mode.
                 * @returns {boolean} <c>true</c> if the sheet is in edit mode; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the isEditing method.
                 * alert(activeSheet.isEditing());
                 */
                isEditing(): boolean;
                /**
                 * Get if sheet paint is suspended.
                 */
                isPaintSuspended(): boolean;
                /**
                 * Gets or sets whether display a print line for the sheet.
                 * @param {boolean} [value] Whether display a print line for the sheet
                 * @returns {boolean} If no value is set, returns a value indicating whether the print line is displayed
                 */
                isPrintLineVisible(value?: boolean): boolean;
                /**
                 * Gets or sets the selected state of the worksheet.
                 * @param {boolean} [selectedState] The selected state of the worksheet.
                 * @returns {boolean|GCTYPE.Spread.Sheets.Worksheet} If no selectedState is set, returns the worksheet selected state; otherwise, returns the worksheet.
                 * @example
                 * spread.sheets[0].isSelected();
                 * spread.sheets[1].isSelected(true);
                 */
                isSelected(selectedState?: boolean): any;
                /**
                 * Determines whether the cell value is valid.
                 * @param {number} row The row index.
                 * @param {number} column The column index.
                 * @param {Object} value The cell value.
                 * @returns {boolean} <c>true</c> if the value is valid; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the isValid method.
                 * alert(activeSheet.isValid(0, 0, 10));
                 */
                isValid(row: number,  column: number,  value: Object): boolean;
                /**
                 * Moves data from one range to another.
                 * @param {number} fromRow The source row.
                 * @param {number} fromColumn The source column.
                 * @param {number} toRow The target row.
                 * @param {number} toColumn The target column.
                 * @param {number} rowCount The row count.
                 * @param {number} columnCount The column count.
                 * @param {GCTYPE.Spread.Sheets.CopyToOptions} option The copy option.
                 * @example
                 * //This example moves the data to the specified location.
                 * activeSheet.getCell(0,0).value("A1");
                 * activeSheet.getCell(1,1).value("Test")
                 * activeSheet.moveTo(0,0,3,3,2,2,GCTYPE.Spread.Sheets.CopyToOptions.value);
                 */
                moveTo(fromRow: number,  fromColumn: number,  toRow: number,  toColumn: number,  rowCount: number,  columnCount: number,  option: GCTYPE.Spread.Sheets.CopyToOptions): void;
                /**
                 * Gets or sets the name of the worksheet.
                 * @param {string} [value] The name of the worksheet.
                 * @returns {string|GCTYPE.Spread.Sheets.Worksheet} If no value is set, returns the worksheet name; otherwise, returns the worksheet.
                 * @example
                 * spread.sheets[0].name("The first sheet");
                 * spread.sheets[1].name( "The second sheet");
                 */
                name(value?: string): any;
                /**
                 * Gets or sets the print information for the sheet.
                 * @param {GCTYPE.Spread.Sheets.Print.PrintInfo} [value] The print information for the sheet.
                 * @returns {GCTYPE.Spread.Sheets.Print.PrintInfo | GCTYPE.Spread.Sheets.Worksheet} If no value is set, returns the print information for the sheet; otherwise, returns the sheet.
                 */
                printInfo(value?: GCTYPE.Spread.Sheets.Print.PrintInfo): any;
                /**
                 * Recalculates all the formulas in the sheet.
                 * @param {boolean} refreshAll Specifies whether to rebuild all fromula reference, custom name and custom functions.
                 * @example
                 * //This example uses the recalcAll method.
                 * activeSheet.setValue(0,0,1);
                 * activeSheet.setValue(0,1,2);
                 * activeSheet.setValue(0,2,10);
                 * activeSheet.getCell(1,1).formula("=SUM(A1:C1)");
                 * activeSheet.recalcAll();
                 */
                recalcAll(refreshAll?: boolean): void;
                /**
                 * Removes a custom function.
                 * @param {string} fnName The custom function name.
                 * @example
                 * //This example uses the removeCustomFunction method.
                 * // Add Custom function
                 * // Type =myfunc(1)
                 * // in a cell to see the result
                 * function myfunc() {}
                 * myfunc.prototype = new GCTYPE.Spread.CalcEngine.Functions.Function("myfunc", 0, 0, {name: "myfunc",description: "This is my first function"});
                 * myfunc.prototype.evaluate = function (args) {
                 *     return 100;
                 * }
                 * spread.addCustomFunction(new myfunc());
                 * //spread.removeCustomFunction("myfunc");
                 */
                removeCustomFunction(name: string): void;
                /**
                 * Removes the specified custom name.
                 * @param {string} fnName The custom name.
                 * @example
                 * //This example uses the removeCustomName method.
                 * activeSheet.setValue(0, 0, 1);
                 * activeSheet.setValue(0, 1, 2);
                 * activeSheet.setValue(0, 2, 3);
                 * activeSheet.addCustomName("customName1","=12", 0, 0);
                 * activeSheet.addCustomName("customName2","Average(20,45)", 0, 0);
                 * activeSheet.addCustomName("customName3", "=$A$1:$C$1", 0, 0);
                 * activeSheet.setFormula(1, 0, "customName1");
                 * activeSheet.setFormula(1, 1, "customName2");
                 * activeSheet.setFormula(1, 2, "sum(customName3)");
                 * //activeSheet.removeCustomName("customName3");
                 */
                removeCustomName(name: string): void;
                /**
                 * Removes a style from the Worksheet named styles collection which has the specified name.
                 * @param {string} name The name of the style to remove.
                 */
                removeNamedStyle(name: string): void;
                /**
                 * Removes the span that contains a specified anchor cell in the specified sheet area.
                 * @param {number} row The row index of the anchor cell for the span (at which spanned cells start).
                 * @param {number} col The column index of the anchor cell for the span (at which spanned cells start).
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @example
                 * activeSheet.addSpan(0,0,3,3,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * //activeSheet.removeSpan(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                removeSpan(row: number,  col: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Removes the sparkline for the specified cell.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @example
                 * //This example removes a sparkline.
                 * var cellr = new GCTYPE.Spread.Sheets.Range(0, 0, 1, 5);
                 * var ex = new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting();
                 * ex.options.SeriesColor  = "Aquamarine";
                 * sheet.setValue(0, 0, 2);
                 * sheet.setValue(0, 1, 5);
                 * sheet.setValue(0, 2, 4);
                 * sheet.setValue(0, 3, -1);
                 * sheet.setValue(0, 4, 3);
                 * sheet.setSparkline(0, 5, cellr, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.horizontal, GCTYPE.Spread.Sheets.Sparklines.SparklineType.column, ex);
                 * alert(sheet.getSparkline(0, 5).toString());
                 * //sheet.removeSparkline(0, 5);
                 */
                removeSparkline(row: number,  col: number): void;
                /**
                 * Repaints the specified rectangle.
                 * @param {GCTYPE.Spread.Sheets.Rect} clipRect The rectangle to repaint.
                 * @example
                 * //This example causes a repaint.
                 * var cellrange =new GCTYPE.Spread.Sheets.Range(0, 0, 5, 1);
                 * var hideRowFilter =new GCTYPE.Spread.Sheets.Filter.HideRowFilter(cellrange);
                 * sheet.rowFilter(hideRowFilter);
                 * sheet.resumePaint();
                 * sheet.repaint();
                 */
                repaint(clipRect?: GCTYPE.Spread.Sheets.Rect): void;
                /**
                 * Resets the sheet.
                 * @example
                 * //This example uses the reset method.
                 * activeSheet.reset();
                 */
                reset(): void;
                /**
                 * Resumes the calculation service.
                 * @param {boolean} recalcAll Specifies whether to recalculate all formulas.
                 * @example
                 * //This example uses the resumeCalcService method.
                 * activeSheet.suspendCalcService(false);
                 * activeSheet.setValue(0,0,1);
                 * activeSheet.setValue(0,1,2);
                 * activeSheet.setValue(0,2,10);
                 * activeSheet.getCell(1,1).formula("=SUM(A1:C1)");
                 * activeSheet.resumeCalcService(true);
                 */
                resumeCalcService(recalcAll?: boolean): void;
                /**
                 * Resumes recording the dirty data.
                 * @example
                 * //This example uses the resumeDirty method.
                 *  var customers = [
                 *                { ID: 0, Name: 'A', Info1: 'Info0' },
                 *                { ID: 1, Name: 'B', Info1: 'Info1' },
                 *                { ID: 2, Name: 'C', Info1: 'Info2' },
                 *             ];
                 * activeSheet.setDataSource(customers);
                 * activeSheet.suspendDirty();
                 * alert(activeSheet.isDirtySuspended());
                 * activeSheet.resumeDirty();
                 * alert(activeSheet.isDirtySuspended());
                 */
                resumeDirty(): void;
                /**
                 * Resumes the event.
                 * @example
                 * //This example suspends and resumes the event.
                 *  activeSheet.bind(GCTYPE.Spread.Sheets.Events.CellChanged, function (sender, args) {
                 *     if (args.propertyName === "value") {
                 *         alert(activeSheet.getValue(args.row, args.col));
                 *     }
                 * });
                 * activeSheet.suspendEvent();
                 * activeSheet.setValue(0, 0, "111");
                 * activeSheet.resumeEvent();
                 * activeSheet.setValue(1, 1, "222");
                 */
                resumeEvent(): void;
                /**
                 * Resumes the paint.
                 */
                resumePaint(): void;
                /**
                 * Gets or sets the row filter for the sheet.
                 * @param {GCTYPE.Spread.Sheets.Filter.RowFilterBase} value The row filter for the sheet.
                 * @returns {GCTYPE.Spread.Sheets.Filter.RowFilterBase} The row filter for the sheet.
                 * @example
                 * //This example creates a row filter.
                 * sheet.rowFilter(new GCTYPE.Spread.Sheets.Filter.HideRowFilter(new GCTYPE.Spread.Sheets.Range(1,1,10,3)));
                 */
                rowFilter(value?: GCTYPE.Spread.Sheets.Filter.RowFilterBase): GCTYPE.Spread.Sheets.Filter.RowFilterBase;
                /**
                 * Scrolls the sheet by specified pixels.
                 * When vPixels is positive, worksheet will scroll down; when vPixels is negative, worksheet will scroll up; when vPixels is 0, worksheet won't scroll in vertical direction.
                 * When hPixels is positive, worksheet will scroll right; when hPixels is negative, worksheet will scroll left; when hPixels is 0, worksheet won't scroll in horizontal direction.
                 * When Workbook's option scrollByPixel is true, worksheet will scroll to new top row/left column index and new top row/left column offset;
                 * When Workbook's option scrollByPixel is false, worksheet will scroll to new top row/left column index, and new top row/left column offset will be always 0.
                 * @param {number} vPixels The pixels to scroll in vertical direction.
                 * @param {number} hPixels The pixels to scroll in horizontal direction.
                 * @example
                 * //This example scrolls down the sheet 10 pixels and scrolls right the sheet 5 pixels.
                 * activeSheet.scroll(10, 5);
                 */
                scroll(vPixels: number,  hPixels: number): void;
                /**
                 * Searches the specified content.
                 * @param {GCTYPE.Spread.Sheets.Search.SearchCondition} searchCondition The search condition.
                 * @returns {GCTYPE.Spread.Sheets.Search.SearchResult} The search result.
                 * @example
                 * //This example uses the search method.
                 * activeSheet.getCell(2,3).value("testSearch");
                 * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                 * searchCondition.searchString = "testSearch";
                 * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                 * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                 * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.ignoreCase| GCTYPE.Spread.Sheets.Search.SearchFlags.useWildCards;
                 * var searchresult= activeSheet.search(searchCondition);
                 * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" +
                 * searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundSheetIndex+"]";
                 * alert(str);
                 */
                search(searchCondition: GCTYPE.Spread.Sheets.Search.SearchCondition): GCTYPE.Spread.Sheets.Search.SearchResult;
                /**
                 * Gets or sets whether users can select ranges of items on a sheet.
                 * @param {GCTYPE.Spread.Sheets.SelectionPolicy} [value] Whether users can select single items, ranges, or a combination of both.
                 * @returns {GCTYPE.Spread.Sheets.SelectionPolicy|GCTYPE.Spread.Sheets.Worksheet} If no value is set, returns the selection policy setting; otherwise, returns the sheet.
                 * @example
                 * //This example uses the selectionPolicy method.
                 * activeSheet.selectionUnit(GCTYPE.Spread.Sheets.SelectionUnit.row);
                 * activeSheet.selectionPolicy(GCTYPE.Spread.Sheets.SelectionPolicy.range);
                 */
                selectionPolicy(value?: GCTYPE.Spread.Sheets.SelectionPolicy): any;
                /**
                 * Gets or sets whether users can select cells, rows, or columns on a sheet.
                 * @param {GCTYPE.Spread.Sheets.SelectionUnit} [value] Whether users can select cells, rows, or columns.
                 * @returns {GCTYPE.Spread.Sheets.SelectionUnit|GCTYPE.Spread.Sheets.Worksheet} If no value is set, returns the selection unit setting; otherwise, returns the sheet.
                 * @example
                 * //This example uses the selectionUnit method.
                 * activeSheet.selectionUnit(GCTYPE.Spread.Sheets.SelectionUnit.row);
                 * activeSheet.selectionPolicy(GCTYPE.Spread.Sheets.SelectionPolicy.range);
                 */
                selectionUnit(value?: GCTYPE.Spread.Sheets.SelectionUnit): any;
                /**
                 * Sets the active cell for this sheet.
                 * @param {number} row The row index of the cell.
                 * @param {number} col The column index of the cell.
                 * @example
                 * //This example sets the active cell.
                 * sheet.setActiveCell(5,5);
                 * alert(sheet.getActiveColumnIndex());
                 * alert(sheet.getActiveRowIndex());
                 * spread.bind(GCTYPE.Spread.Sheets.Events.EnterCell, function (event, data) {
                 *     alert(data.col);
                 *     alert(data.row);
                 *   });
                 * spread.bind(GCTYPE.Spread.Sheets.Events.LeaveCell, function (event, data) {
                 *     alert(data.col);
                 *     alert(data.row);
                 *   });
                 */
                setActiveCell(row: number,  col: number): void;
                /**
                 * Sets the values in the specified two-dimensional array of objects into the specified range of cells on this sheet.
                 * @param {number} row The row index.
                 * @param {number} column The column index.
                 * @param {Array} array The array from which to set values.
                 * @param {boolean} [setFormula] If <c>true</c>, set formulas; otherwise, set values.
                 * @example
                 * //This example uses the setArray method.
                 * //set value
                 * var array = [[1,2,3],[4,5],[6,7,8,9]];
                 * activeSheet.setArray(1, 2, array);
                 * //set formula
                 * var array = [["=1+1","=2+2","=3+3"],["=4+4","=5+5"],["=6+6","=7+7","=8+8","=9+9"]];
                 * activeSheet.setArray(1, 2, array, true);
                 * //get value
                 * var newArray = activeSheet.getArray(1, 2, 3, 4);
                 * //getformula
                 * var newArray = activeSheet.getArray(1, 2, 3, 4, true);
                 * //alert(newArray[0]);
                 */
                setArray(row: number,  column: number,  array: any[],  setFormula?: boolean): void;
                /**
                 * Sets a formula in a specified cell in the specified sheet area.
                 * @param {number} row The start row index.
                 * @param {number} col The start column index.
                 * @param {number} rowCount The number of rows in range.
                 * @param {number} colCount The number of columns in range.
                 * @param {string} value The array formula to place in the specified range.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If you do not provide this parameter, it defaults to <b>viewport</b>.
                 * @example
                 * //This example uses the setArrayFormula method.
                 * activeSheet.getCell(1,1).value(3);
                 * activeSheet.getCell(2,1).value(1);
                 * activeSheet.getCell(3,1).value(3);
                 * activeSheet.getCell(4,1).value(7);
                 * activeSheet.getCell(1,2).value(7);
                 * activeSheet.getCell(2,2).value(7);
                 * activeSheet.getCell(3,2).value(7);
                 * activeSheet.getCell(4,2).value(7);
                 * spread.allowUserEditFormula(true);
                 * activeSheet.setArrayFormula(0, 3, 4, 1, "B2:B5*C2:C5", GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                setArrayFormula(row: number,  col: number,  rowCount: number,  colCount: number,  value: string,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the binding path for cell-level binding in a specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {string} path The binding path for the cell binding source.
                 * @returns {GCTYPE.Spread.Sheets.Worksheet}
                 * @example
                 * //This example binds a cell.
                 * var test = {name: "John", gender: "male"};
                 * sheet.setBindingPath(0, 0, "name");
                 * sheet.setBindingPath(0, 1, "gender");
                 * sheet.setDataSource(new GCTYPE.Spread.Sheets.Bindings.CellBindingSource(test));
                 */
                setBindingPath(row: number,  col: number,  path: string): GCTYPE.Spread.Sheets.Worksheet;
                /**
                 * Sets the cell type.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.CellTypes.Base} value The cell type.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @example
                 * //This example uses the setCellType method.
                 * var cellType = new GCTYPE.Spread.Sheets.CellTypes.Button();
                 * cellType.buttonBackColor("#FFFF00");
                 * cellType.text("this is a button");
                 * activeSheet.setCellType(1,1,cellType);
                 * spread.bind(GCTYPE.Spread.Sheets.Events.ButtonClicked, function (e, args) {
                 *     var sheet = args.sheet, row = args.row, col = args.col;
                 *     var cellType = activeSheet.getCellType(row, col);
                 *     if (cellType instanceof GCTYPE.Spread.Sheets.CellTypes.Button) {
                 *         alert("Button Clicked");
                 *     }
                 * });
                 */
                setCellType(row: number,  col: number,  value: GCTYPE.Spread.Sheets.CellTypes.Base,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the column count in the specified sheet area.
                 * @param {number} colCount The column count.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @example
                 * //This example sets the number of columns.
                 * sheet.setRowCount(4,1);
                 * sheet.setColumnCount(4,2);
                 * sheet.addSpan(0,0,3,3,GCTYPE.Spread.Sheets.SheetArea.colHeader);
                 * sheet.addSpan(0,0,3,3,GCTYPE.Spread.Sheets.SheetArea.rowHeader);
                 * sheet.addSpan(0,0,3,3,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                setColumnCount(colCount: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets whether a forced page break is inserted before the specified column on this sheet when printing.
                 * @param {number} column The column index.
                 * @param {boolean} value Set to <c>true</c> to force a page break before the specified column on this sheet when printing.
                 * @example
                 * //This example sets the page break.
                 * activeSheet.setColumnPageBreak(5, true);
                 */
                setColumnPageBreak(column: number,  value: boolean): void;
                /**
                 * Sets whether users can resize the specified column in the specified sheet area.
                 * @param {number} col The column index.
                 * @param {boolean} value Set to <c>true</c> to allow users to resize the column.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @example
                 * //This example sets the setColumnResizable method.
                 * sheet.setRowResizable(3,false,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * sheet.setColumnResizable(3,false,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * sheet.getRange(1,-1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).resizable(false);
                 * sheet.getRange(-1, 1, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).resizable(false);
                 */
                setColumnResizable(col: number,  value: boolean,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets whether a column in the specified sheet area is displayed.
                 * @param {number} col The column index.
                 * @param {boolean} value Whether to display the column.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @example
                 * //This example sets the specified column to be hidden.
                 * activeSheet.setColumnVisible(2,false,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                setColumnVisible(col: number,  value: boolean,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the width in pixels or dynamic size for the specified column in the specified sheet area.
                 * @param {number} col The column index.
                 * @param {number | string} value The width in pixels, or use the string with "*" to represent the dynamic size.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to viewport.
                 * @example
                 * //This example sets the column width.
                 * sheet.setValue(0, 0, "value");
                 * sheet.addRows(0, 2);
                 * sheet.addColumns(0, 2);
                 * sheet.setRowHeight(0, 50.0, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * sheet.setColumnWidth(0, 150.0, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * sheet.setColumnWidth(1, "2*", GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * sheet.getRange(0, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).backColor("Gray");
                 * sheet.getRange(-1, 0, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).backColor ("Brown");
                 */
                setColumnWidth(col: number,  value: number | string,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets delimited text (CSV) in the sheet.
                 * @param {number} row The start row.
                 * @param {number} column The start column.
                 * @param {string} text The delimited text.
                 * @param {string} rowDelimiter The row delimiter.
                 * @param {string} columnDelimiter The column delimiter.
                 */
                setCsv(row: number,  column: number,  text: string,  rowDelimiter: string,  columnDelimiter: string): void;
                /**
                 * Sets the data source that populates the sheet.
                 * @param {Object} data The data source.
                 * @param {boolean} reset <c>true</c> if the sheet is reset; otherwise, <c>false</c>.
                 * @example
                 * var test = [
                 *        { "Series0": 2, "Series1": 1 },
                 *        { "Series0": 4, "Series1": 2 },
                 *        { "Series0": 3, "Series1": 4 }
                 *             ];
                 * activeSheet.autoGenerateColumns = true;
                 * activeSheet.setDataSource(test, true);
                 */
                setDataSource(data: any,  reset?: boolean): void;
                /**
                 * Sets the cell data validator.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} value The data validator.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GCTYPE.Spread.Sheets.DataValidation.createListValidator("1,2,3");
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Value must be 1,2 or 3");
                 * dv.inputTitle("tip");
                 * activeSheet.setDataValidator(1,1,dv,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * alert(activeSheet.getDataValidator(1,1).getValidList(activeSheet,1,1));
                 */
                setDataValidator(row: number,  col: number,  value: GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the cell data validator.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {number} rowCount The row count.
                 * @param {number} colCount The column count.
                 * @param {GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} value The data validator.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GCTYPE.Spread.Sheets.DataValidation.createListValidator("1,2,3");
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Value must be 1,2 or 3");
                 * dv.inputTitle("tip");
                 * activeSheet.setDataValidator(1,1,1,1,dv,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * alert(activeSheet.getDataValidator(1,1).getValidList(activeSheet,1,1));
                 */
                setDataValidator(row: number,  col: number,  rowCount: number,  colCount: number,  value: GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the default style information for the sheet.
                 * @param {GCTYPE.Spread.Sheets.Style} style The style to set.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 */
                setDefaultStyle(style: GCTYPE.Spread.Sheets.Style,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the cell formatter.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {string | GCTYPE.Spread.Formatter.FormatterBase} value The formatter string or object.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @example
                 * //This example sets the format object for the active sheet.
                 * activeSheet.setValue(2, 3, new Date(2011, 2, 9));
                 * activeSheet.setFormatter(2,3,"M",GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                setFormatter(row: number,  col: number,  value: string | GCTYPE.Spread.Formatter.FormatterBase,  sheetArea: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets a formula in a specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {string} value The formula to place in the specified cell.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If you do not provide this parameter, it defaults to <b>viewport</b>.
                 * @example
                 * //This example sets the formula for the specified cell.
                 * activeSheet.setValue(0, 2, 3);
                 * activeSheet.setFormula(1,1,"C1+D1",GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                setFormula(row: number,  col: number,  value: string,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the hyperlink data for the specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {Object} value The hyperlink data to set for the specified cell.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @example
                 * //This example uses the setHyperlink method.
                 * sheet.setHyperlink(0, 2, {
                 *    url: 'https://www.grapecity.com/spreadjs',
                 *    tooltip: 'baidu',
                 *    linkColor: 'blue',
                 *    visitedLinkColor: 'red',
                 *    target: GCTYPE.Spread.Sheets.Hyperlink.HyperlinkTargetType.blank,
                 *    command: 'navigationLeft'
                 * }, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * sheet.setHyperlink(1, 1, {
                 *    url: 'https://www.grapecity.com/spreadjs',
                 *    tooltip: 'baidu',
                 *    setUnderlineToStyle: true;
                 *    setForeColorToStyle: true;
                 *    target: GCTYPE.Spread.Sheets.Hyperlink.HyperlinkTargetType.top,
                 *    command: function() { console.log('Only show this message when click the hyperlink.')}
                 * }, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                setHyperlink(row: number,  col: number,  value: GCTYPE.Spread.Sheets.IHyperlink,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the row count in the specified sheet area.
                 * @param {number} rowCount The row count.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @example
                 * //This example sets the row count.
                 * sheet.setRowCount(4,1);
                 * sheet.setColumnCount(4,2);
                 * sheet.addSpan(0,0,3,3,GCTYPE.Spread.Sheets.SheetArea.colHeader);
                 * sheet.addSpan(0,0,3,3,GCTYPE.Spread.Sheets.SheetArea.rowHeader);
                 * sheet.addSpan(0,0,3,3,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                setRowCount(rowCount: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the height in pixels or dynamic size for the specified row in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number | string} value The height in pixels, or use the string with "*" to represent the dynamic size.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @example
                 * //This example sets the row height.
                 * sheet.setValue(0, 0, "value");
                 * sheet.addRows(0, 2);
                 * sheet.addColumns(0, 2);
                 * sheet.setRowHeight(0, 50.0, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * sheet.setRowHeight(1, "3*", GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * sheet.setColumnWidth(0, 150.0, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * sheet.getRange(0, -1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).backColor("Gray");
                 * sheet.getRange(-1, 0, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).backColor ("Brown");
                 */
                setRowHeight(row: number,  value: number | string,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets whether a forced page break is inserted before the specified row on this sheet when printing.
                 * @param {number} row The row index.
                 * @param {boolean} value Set to <c>true</c> to force a page break before the specified row on this sheet when printing.
                 * @example
                 * activeSheet.setRowPageBreak(3, true);
                 */
                setRowPageBreak(row: number,  value: boolean): void;
                /**
                 * Sets whether users can resize the specified row in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {boolean} value Set to <c>true</c> to let the users resize the specified row.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @example
                 * //This example prevents certain rows and columns from being resized.
                 * sheet.setRowResizable(3,false,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * sheet.setColumnResizable(3,false,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * sheet.getRange(1,-1, 1, -1, GCTYPE.Spread.Sheets.SheetArea.viewport).resizable(false);
                 * sheet.getRange(-1, 1, -1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).resizable(false);
                 */
                setRowResizable(row: number,  value: boolean,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets whether the control displays the specified row in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {boolean} value Set to <c>true</c> to display the specified row.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not given, it defaults to <b>viewport</b>.
                 * @example
                 * //This example sets the specified row to be hidden.
                 * activeSheet.setRowVisible(1,false,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                setRowVisible(row: number,  value: boolean,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the selection to a cell or a range and sets the active cell to the first cell.
                 * @param {number} row The row index of the first cell to add.
                 * @param {number} column The column index of the first cell to add.
                 * @param {number} rowCount The number of rows to add.
                 * @param {number} columnCount The number of columns to add.
                 * @example
                 * //This example selects a range of cells.
                 * sheet.setValue(0,0, 1,3);
                 * sheet.setValue(1,0, 50,3);
                 * sheet.setValue(2,0, 100,3);
                 * sheet.setValue(3,0, 2,3);
                 * sheet.setValue(4,0, 60,3);
                 * sheet.setValue(5,0, 90,3);
                 * sheet.setValue(6,0, 3,3);
                 * sheet.setValue(7,0, 40,3);
                 * sheet.setValue(8,0, 70,3);
                 * sheet.setValue(9,0, 5,3);
                 * sheet.setValue(10,0, 35,3);
                 * sheet.setSelection(0,0,11,1);
                 * sheet.conditionalFormats.add3ScaleRule(1, 10, "red", 0, 50, "blue",2, 100, "yellow", sheet.getSelections());
                 */
                setSelection(row: number,  column: number,  rowCount: number,  columnCount: number): void;
                /**
                 * Sets the sparkline for a cell.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.Range | string} dataRange The data range.
                 * @param {GCTYPE.Spread.Sheets.Sparklines.DataOrientation} dataOrientation The data orientation.
                 * @param {GCTYPE.Spread.Sheets.Sparklines.SparklineType} sparklineType The sparkline type.
                 * @param {GCTYPE.Spread.Sheets.Sparklines.SparklineSetting} sparklineSetting The sparkline setting.
                 * @param {GCTYPE.Spread.Sheets.Range | string} dateAxisRange The date axis range.
                 * @param {GCTYPE.Spread.Sheets.Sparklines.DataOrientation} dateAxisOrientation The date axis range orientation.
                 * @returns {GCTYPE.Spread.Sheets.Sparklines.Sparkline} The sparkline.
                 * @example
                 * //This example creates a sparkline for the specified range.
                 * var data = new GCTYPE.Spread.Sheets.Range(1, 0, 8, 1);
                 * var setting = new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting();
                 * setting.options.showMarkers = true;
                 * setting.options.lineWeight = 3;
                 * setting.options.displayXAxis = true;
                 * setting.options.showFirst = true;
                 * setting.options.showLast = true;
                 * setting.options.showLow = true;
                 * setting.options.showHigh = true;
                 * setting.options.showNegative = true;
                 * setting.options.seriesColor = "Text 2 1";
                 * setting.options.firstMarkerColor = "Text 2 3";
                 * setting.options.negativeColor = "Accent 2 1";
                 * setting.options.markersColor = "Accent 3 1";
                 * setting.options.lowMarkerColor = "Accent 4 1";
                 * setting.options.highMarkerColor = "Accent 6 1";
                 * setting.options.lastMarkerColor = "Accent 6 6";
                 * setting.options.axisColor ="Text 1 1";
                 * sheet.addSpan(13, 0, 4, 3, null);
                 * sheet.setSparkline(13, 0, data, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.Vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 * sheet.setValue(1, 0, 1);
                 * sheet.setValue(2, 0, -2);
                 * sheet.setValue(3, 0, -1);
                 * sheet.setValue(4, 0, 6);
                 * sheet.setValue(5, 0, 4);
                 * sheet.setValue(6, 0, -4);
                 * sheet.setValue(7, 0, 3);
                 * sheet.setValue(8, 0, 8);
                 */
                setSparkline(row: number,  col: number,  dataRange: GCTYPE.Spread.Sheets.Range | string,  dataOrientation: GCTYPE.Spread.Sheets.Sparklines.DataOrientation,  sparklineType: GCTYPE.Spread.Sheets.Sparklines.SparklineType,  sparklineSetting: GCTYPE.Spread.Sheets.Sparklines.SparklineSetting,  dateAxisRange?: GCTYPE.Spread.Sheets.Range | string,  dateAxisOrientation?: GCTYPE.Spread.Sheets.Sparklines.DataOrientation): GCTYPE.Spread.Sheets.Sparklines.Sparkline;
                /**
                 * Sets the style information for a specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} column The column index.
                 * @param {GCTYPE.Spread.Sheets.Style} value The cell style.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @example
                 * //This example uses the setStyle method.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "lightgreen";
                 * style.backgroundImage = "./css/images/quarter1.png";
                 * activeSheet.setStyle(1,1,style,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                setStyle(row: number,  col: number,  value: GCTYPE.Spread.Sheets.Style,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the specified style name for a specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} column The column index.
                 * @param {string} value The name of the style to set.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @example
                 * var namedStyle = new GCTYPE.Spread.Sheets.Style();
                 * namedStyle.name = "style1";
                 * namedStyle.backColor = "green";
                 * activeSheet.addNamedStyle(namedStyle);
                 * activeSheet.setStyleName(1, 1, "style1"); // cell(1,1)'s backColor is  green.
                 * activeSheet.setStyleName(2, 1, "style1");
                 */
                setStyleName(row: number,  column: number,  value: string,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the tag value for the specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {Object} tag The tag value to set for the specified cell.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} sheetArea The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @example
                 * activeSheet.setTag(1,1,"test");
                 */
                setTag(row: number,  col: number,  tag: any,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the formatted text in the cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {string} value The text for the specified cell.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @example
                 * activeSheet.setText(1, 0, "10");
                 */
                setText(row: number,  col: number,  value: string,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                /**
                 * Sets the value for the specified cell in the specified sheet area.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {Object} value The value to set for the specified cell. if the value is rich text format, should include a richText field which type is a rich text style array.
                 * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                 * @param {boolean} ignoreRecalc Whether to ignore recalculation.
                 * @example
                 * //This example uses the setValue method.
                 * sheet.setValue(0,2,"ColumnHeader", GCTYPE.Spread.Sheets.SheetArea.colHeader);
                 * sheet.setValue(2,0,{richText:[{style:{font:'bold 24px Arial'},text:'SpreadJS'}]}, GCTYPE.Spread.Sheets.SheetArea.rowHeader);
                 * sheet.setValue(1, 1, {richText:[{style:{vertAlign: GCTYPE.Spread.Sheets.VertAlign.subscript},text:'SpreadJS'}]}, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                setValue(row: number,  col: number,  value: any,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea,  ignoreRecalc?: boolean): void;
                /**
                 * Moves the view of a cell to the specified position in the viewport.
                 * @param {number} row The row index.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.VerticalPosition} verticalPosition The vertical position in which to display the cell.
                 * @param {GCTYPE.Spread.Sheets.HorizontalPosition} horizontalPosition The horizontal position in which to display the cell.
                 * @example
                 * //This example uses the showCell method.
                 * //Set cell (3,3) as the active cell
                 * activeSheet.setActiveCell(3, 3);
                 * //Display the active cell at top left
                 * activeSheet.showCell(3, 3, GCTYPE.Spread.Sheets.VerticalPosition.top, GCTYPE.Spread.Sheets.HorizontalPosition.left);
                 */
                showCell(row: number,  col: number,  verticalPosition: GCTYPE.Spread.Sheets.VerticalPosition,  horizontalPosition: GCTYPE.Spread.Sheets.HorizontalPosition): void;
                /**
                 * Moves the view of a column to the specified position in the viewport.
                 * @param {number} col The column index.
                 * @param {GCTYPE.Spread.Sheets.HorizontalPosition} horizontalPosition The horizontal position in which to display the column.
                 * @example
                 * activeSheet.showColumn(9, GCTYPE.Spread.Sheets.HorizontalPosition.left);
                 */
                showColumn(col: number,  horizontalPosition: GCTYPE.Spread.Sheets.HorizontalPosition): void;
                /**
                 * Gets or sets whether the column outline (range group) is visible.
                 * @param {boolean} value Whether to display the column outline.
                 * @returns {boolean | GCTYPE.Spread.Sheets.Worksheet} If no value is set, returns a value that indicates whether the column outline is displayed on this sheet; otherwise, returns the worksheet.
                 * @example
                 * //This example uses the showColumnOutline method.
                 * activeSheet.showColumnOutline(false);
                 */
                showColumnOutline(value?: boolean): any;
                /**
                 * Moves the view of a row to the specified position in the viewport.
                 * @param {number} row The row index.
                 * @param {GCTYPE.Spread.Sheets.VerticalPosition} verticalPosition The vertical position in which to display the row.
                 * @example
                 * activeSheet.showRow(9, GCTYPE.Spread.Sheets.VerticalPosition.top);
                 */
                showRow(row: number,  verticalPosition: GCTYPE.Spread.Sheets.VerticalPosition): void;
                /**
                 * Gets or sets whether the row outline (range group) is visible.
                 * @param {boolean} value Whether to display the row outline.
                 * @returns {boolean | GCTYPE.Spread.Sheets.Worksheet} If no value is set, returns a value that indicates whether the row outline is displayed on this sheet; otherwise, returns the worksheet.
                 * @example
                 * //This example uses the showRowOutline method.
                 * activeSheet.showRowOutline(false);
                 */
                showRowOutline(value?: boolean): any;
                /**
                 * Sorts a range of cells in this sheet in the data model.
                 * @param {number} row The index of the starting row of the block of cells to sort.
                 * @param {number} column The index of the starting column of the block of cells to sort.
                 * @param {number} rowCount The number of rows in the block of cells.
                 * @param {number} columnCount The number of columns in the block of cells.
                 * @param {boolean} byRows Set to <c>true</c> to sort by rows, and <c>false</c> to sort by columns.
                 * @param {Object} sortInfo The SortInfo object with sort criteria and information about how to perform the sort. For example, [{index:0,ascending:true}]
                 * @param {number} sortInfo.index The index of the column or row on which to sort.
                 * @param {boolean} sortInfo.ascending Whether the sort order is ascending When sort by value or custom sort.
                 * @param {string} sortInfo.order Only support "top" and "bottom". color selected will group on top when order is "top".
                 * @param {string | null} sortInfo.fontColor The font color of sort.
                 * @param {string | Object} sortInfo.backColor The back color of sort. this paramter supports color string, gradient fill and pattern fill.
                 * @param {Function} sortInfo.compareFunction Whether the sort order is ascending.  function (value1, value2) {return 0;}.
                 * @param {ISortOptions} sortOption The sortOption indicate the detail performance of the sort.
                 * @param {GroupSort} sortOption.groupSort The groupSort indicate the sort action with group, whether sort all the groups and its inner content.
                 * @param {boolean} sortOption.ignoreHidden Whether to ignore the hidden values and only sort visible values.
                 * @returns {boolean} <c>true</c> if the data is sorted successfully; otherwise, <c>false</c>.
                 * @example
                 * //This example sorts a range.
                 * sheet.setValue(0,0,"112");
                 * sheet.setValue(1,0,"10");
                 * sheet.setValue(2,0,"223");
                 * sheet.setValue(3,0,"20");
                 * sheet.setValue(4,0,"334");
                 * sheet.setValue(5,0,"30");
                 * function pinyinCompare (obj1, obj2) {
                 *     return obj1.toString().localeCompare(obj2.toString(), 'zh');
                 * }
                 * sheet.sortRange(0, 0, 6, 1, true, [
                 *                 {index:0, ascending:true, compareFunction: pinyinCompare}
                 *                 ], {groupSort: GCTYPE.Spread.Sheets.GroupSort.full, ignoreHidden: true});
                 */
                sortRange(row: number,  column: number,  rowCount: number,  columnCount: number,  byRows: boolean,  sortInfo: Array<GCTYPE.Spread.Sheets.IValueSortInfo | GCTYPE.Spread.Sheets.ICellColorSortInfo | GCTYPE.Spread.Sheets.IFontColorSortInfo | GCTYPE.Spread.Sheets.ICustomSortInfo>,  sortOption?: GCTYPE.Spread.Sheets.ISortOptions): boolean;
                /**
                 * Starts to edit the cell.
                 * @param {boolean} selectAll Set to <c>true</c> to select all the text in the cell.
                 * @param {string} defaultText The default text to display while editing the cell.
                 * @example
                 * //This example uses the startEdit method.
                 * activeSheet.setActiveCell(5,5);
                 * activeSheet.startEdit(true, "Test");
                 */
                startEdit(selectAll?: boolean,  defaultText?: string): void;
                /**
                 * Suspends the calculation service.
                 * @param {boolean} ignoreDirty Specifies whether to invalidate the dependency cells.
                 * @example
                 * //This example uses the suspendCalcService method.
                 * activeSheet.suspendCalcService(false);
                 * activeSheet.setValue(0,0,1);
                 * activeSheet.setValue(0,1,2);
                 * activeSheet.setValue(0,2,10);
                 * activeSheet.getCell(1,1).formula("=SUM(A1:C1)");
                 * activeSheet.resumeCalcService(true);
                 */
                suspendCalcService(ignoreDirty?: boolean): void;
                /**
                 * Suspends recording the dirty data.
                 * @example
                 * //This example uses the suspendDirty method.
                 *  var customers = [
                 *                { ID: 0, Name: 'A', Info1: 'Info0' },
                 *                { ID: 1, Name: 'B', Info1: 'Info1' },
                 *                { ID: 2, Name: 'C', Info1: 'Info2' },
                 *             ];
                 * activeSheet.setDataSource(customers);
                 * activeSheet.suspendDirty();
                 * alert(activeSheet.isDirtySuspended());
                 * activeSheet.resumeDirty();
                 * alert(activeSheet.isDirtySuspended());
                 */
                suspendDirty(): void;
                /**
                 * Suspends the event.
                 * @example
                 * //This example suspends and resumes the event.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.CellChanged, function (sender, args) {
                 *     if (args.propertyName === "value") {
                 *         alert(activeSheet.getValue(args.row, args.col));
                 *     }
                 * });
                 * activeSheet.suspendEvent();
                 * activeSheet.setValue(0, 0, "111");
                 * activeSheet.resumeEvent();
                 * activeSheet.setValue(1, 1, "222");
                 */
                suspendEvent(): void;
                /**
                 * Suspends the paint.
                 */
                suspendPaint(): void;
                /**
                 * Gets or sets the tag value for the current sheet.
                 * @param {Object} value The tag value to set for the current sheet.
                 * @returns {Object | GCTYPE.Spread.Sheets.Worksheet} If no value is set, returns the tag value of the current sheet; otherwise, returns the worksheet.
                 * @example
                 * //This example sets the sheet tag.
                 * activeSheet.tag("test");
                 * alert(activeSheet.tag());
                 */
                tag(value?: any): any;
                /**
                 * Saves the object state to a JSON string.
                 * @param {Object} serializationOption Serialization option that contains the <i>includeBindingSource</i> argument. See the Remarks for more information.
                 * @returns {Object} The sheet data.
                 * @example
                 * //This example uses the toJSON method.
                 * activeSheet.getCell(0,0).value(123);
                 * var jsonStr = null;
                 * //export
                 * jsonStr = JSON.stringify(activeSheet.toJSON());
                 * //import
                 * activeSheet.fromJSON(JSON.parse(jsonStr));
                 * alert(jsonStr);
                 */
                toJSON(serializationOption?: Object): Object;
                /**
                 * Removes the binding of an event to the sheet.
                 * @param {string} type The event type.
                 * @param {Function} fn Specifies the function for which to remove the binding.
                 * @example
                 * //This example unbinds the event after setting the first value.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.CellChanged, function (sender, args) {
                 *     if (args.propertyName === "value") {
                 *         alert(activeSheet.getValue(args.row, args.col));
                 *     }
                 * });
                 * activeSheet.setValue(0, 0, "111");
                 * activeSheet.unbind(GCTYPE.Spread.Sheets.Events.CellChanged);
                 * activeSheet.setValue(1, 0, "222");
                 * activeSheet.setValue(2, 0, "333");
                 * activeSheet.setValue(3, 0, "444");
                 */
                unbind(type: string,  fn?: Function): void;
                /**
                 * Removes the binding of all events to the sheet.
                 * @example
                 * //This example cancels monitoring of all events.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.CellChanged, function (sender, args) {
                 *     if (args.propertyName === "value") {
                 *         alert(activeSheet.getValue(args.row, args.col));
                 *     }
                 * });
                 * activeSheet.setValue(0, 0, "111");
                 * activeSheet.unbindAll(); //cancel monitoring of all events.
                 * activeSheet.setValue(1, 0, "222");
                 * activeSheet.setValue(2, 0, "333");
                 * activeSheet.setValue(3, 0, "444");
                 */
                unbindAll(): void;
                /**
                 * Ungroups the sparklines in the specified group.
                 * @param {GCTYPE.Spread.Sheets.Sparklines.SparklineGroup} group The sparkline group.
                 * @example
                 * //This example uses the ungroupSparkline method.
                 * activeSheet.setValue(0, 0, "Data Range is A2-A9");
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 * var data = new GCTYPE.Spread.Sheets.Range(1, 0, 8, 1);
                 * var setting = new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting();
                 * var s1=  activeSheet.setSparkline(11, 0, data, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.Vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 * var s2 =activeSheet.setSparkline(11, 3, data, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.Vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.column, setting);
                 * var s3=  activeSheet.setSparkline(11, 6, data, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.Vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.winloss, setting);
                 * var group = activeSheet.groupSparkline([s1,s2,s3]);
                 * //activeSheet.ungroupSparkline(group);
                 */
                ungroupSparkline(group: GCTYPE.Spread.Sheets.Sparklines.SparklineGroup): void;
                /**
                 * Sets whether the worksheet is displayed.
                 * @param {boolean} [value] Whether the worksheet is displayed.
                 * @returns {boolean|GCTYPE.Spread.Sheets.Worksheet} If you call this function without a parameter, it returns a boolean indicating whether the sheet is visible;
                 * otherwise, it returns the current worksheet object.
                 * @example
                 * activeSheet.visible(false);
                 */
                visible(value?: boolean): any;
                /**
                 * Gets or sets the zoom factor for the sheet.
                 * @param {number} [factor] The zoom factor.
                 * @returns {number|GCTYPE.Spread.Sheets.Worksheet} If no value is set, returns the zoom factor; otherwise, returns the worksheet.
                 * @example
                 * //This example zooms the sheet.
                 * spread.options.allowUserZoom = false;
                 * sheet.zoom(3);
                 */
                zoom(factor?: number): any;
            }
            module AutoMerge{

                export interface IRangeInfo{
                    range: GCTYPE.Spread.Sheets.Range;
                    direction: GCTYPE.Spread.Sheets.AutoMerge.AutoMergeDirection;
                    mode: GCTYPE.Spread.Sheets.AutoMerge.AutoMergeMode;
                    sheetArea: GCTYPE.Spread.Sheets.SheetArea;
                    selectionMode?: GCTYPE.Spread.Sheets.AutoMerge.SelectionMode;
                }

                /**
                 * Indicates the auto merge direction.
                 * @enum {number}
                 */
                export enum AutoMergeDirection{
                    /**
                     * Indicates to cancel the auto merge.
                     */
                    none= 0,
                    /**
                     * Indicates to apply the auto merge in column direction.
                     */
                    column= 1,
                    /**
                     * Indicates to apply the auto merge in row direction.
                     */
                    row= 2,
                    /**
                     * Indicates to apply the auto merge in column direction preferentially then in row direction.
                     */
                    columnRow= 3,
                    /**
                     * Indicates to apply the auto merge in row direction preferentially then in column direction.
                     */
                    rowColumn= 4
                }

                /**
                 * Indicates the auto merge mode.
                 * @enum {number}
                 */
                export enum AutoMergeMode{
                    /**
                     * Indicates to apply the auto merge when neighboring cells have same value.
                     */
                    free= 0,
                    /**
                     * Indicates to apply the auto merge when neighboring cells have same value and the corresponding cells in previous row or column are merged automatically.
                     */
                    restricted= 1
                }

                /**
                 * Indicates the auto merge selection mode.
                 * @enum {number}
                 */
                export enum SelectionMode{
                    /**
                     * Indicates to select individual cell when the auto merge is applied.
                     */
                    source= 0,
                    /**
                     * Indicates to select all cells which have same value when the auto merge is applied.
                     */
                    merged= 1
                }

            }

            module Barcode{

                export class Codabar extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the Codabar.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class Code128 extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the Code128.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class Code39 extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the Code39.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class Code49 extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the Code49.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class Code93 extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the Code93.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class DataMatrix extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the DataMatrix.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class EAN13 extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the EAN13.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class EAN8 extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the EAN8.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class GS1_128 extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the GS1_128.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class PDF417 extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the PDF417.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class QRCode extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx{
                    /**
                     * Represents the class for the QRCode.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }
            }

            module Bindings{

                export class CellBindingSource{
                    /**
                     * Represents a source for cell binding.
                     * @param {Object} source The data source.
                     * @class
                     * @example
                     * var person = {name: "Wang feng", age: 25, address: {postcode: "710075"}};
                     * var source = new GCTYPE.Spread.Sheets.Bindings.CellBindingSource(person);
                     * activeSheet.setBindingPath(0, 0, "name");
                     * activeSheet.setBindingPath(1, 1, "age");
                     * activeSheet.setBindingPath(3, 3, "address.postcode");
                     * activeSheet.setDataSource(source);
                     */
                    constructor(source: Object);
                    /**
                     * Gets the wrapped data source for cell binding.
                     * @returns {Object} The original data source.
                     * @example
                     * //This example gets the name.
                     * var person = { name: "Wang feng", age: 25, address: { postcode: "710075" } };
                     * var source = new GCTYPE.Spread.Sheets.Bindings.CellBindingSource(person);
                     * activeSheet.setBindingPath(0, 0, "name");
                     * activeSheet.setBindingPath(1, 1, "age");
                     * activeSheet.setBindingPath(3, 3, "address.postcode");
                     * activeSheet.setDataSource(source);
                     * alert(source.getSource().name);
                     */
                    getSource(): Object;
                    /**
                     * Gets the value of the source by the binding path.
                     * @param {string} path The binding path.
                     * @returns {Object} Returns the value of the binding source at the specified path.
                     * @example
                     * //This example gets the value.
                     * var person = {name: "Wang feng", age: 25, address: {postcode: "710075"}};
                     * var source = new GCTYPE.Spread.Sheets.Bindings.CellBindingSource(person);
                     * activeSheet.setBindingPath(0, 0, "name");
                     * activeSheet.setBindingPath(1, 1, "age");
                     * activeSheet.setBindingPath(3, 3, "address.postcode");
                     * activeSheet.setDataSource(source);
                     * alert(source.getValue("name"));
                     */
                    getValue(path: string): Object;
                    /**
                     * Sets the value of the source by the binding path.
                     * @param {string} path The row index.
                     * @param {Object} value The value to set.
                     * @example
                     * //This example sets the name value.
                     * var person = {name: "Wang feng", age: 25, address: {postcode: "710075"}};
                     * var source = new GCTYPE.Spread.Sheets.Bindings.CellBindingSource(person);
                     * activeSheet.setBindingPath(0, 0, "name");
                     * activeSheet.setBindingPath(1, 1, "age");
                     * activeSheet.setBindingPath(3, 3, "address.postcode");
                     * activeSheet.setDataSource(source);
                     * source.setValue("name", "test");
                     * activeSheet.resumePaint();
                     * activeSheet.repaint();
                     */
                    setValue(path: string,  value: Object): void;
                }
            }

            module CalcEngine{
                /**
                 * Evaluates the specified formula.
                 * @param {object} context The evaluation context; in general, you should use the active sheet object.
                 * @param {string} formula The formula string.
                 * @param {number} [baseRow] The base row index of the formula.
                 * @param {number} [baseColumn] The base column index of the formula.
                 * @param {boolean} [useR1C1] Whether to use the r1c1 reference style.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById('ss'), { sheetCount: 1 });
                 * sheet = spread.getSheet(0);
                 * sheet.setValue(0, 0, 1);
                 * sheet.setValue(1, 0, 2);
                 * // Using EvaluateFormula() method to evaluate formula without setting formula in sheet's cell
                 * var result = GCTYPE.Spread.Sheets.CalcEngine.evaluateFormula(sheet, "SUM(A1:A2)", 0, 0);
                 * console.log("SUM(A1:A2) = " + result);
                 * @returns {object} The evaluated formula result.
                 */
                function evaluateFormula(context: Object,  formula: string,  baseRow?: number,  baseColumn?: number,  useR1C1?: boolean): any;
                /**
                 * Unparse the specified expression tree to formula string.
                 * @param {object} context The context; in general, you should use the active sheet object.
                 * @param {GCTYPE.Spread.CalcEngine.Expression} expression The expression tree.
                 * @param {number} [baseRow] The base row index of the formula.
                 * @param {number} [baseColumn] The base column index of the formula.
                 * @param {boolean} [useR1C1] Whether to use the r1c1 reference style.
                 * @returns {string} The formula string.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById('ss'), { sheetCount: 1 });
                 * sheet = spread.getSheet(0);
                 * sheet.setValue(0, 0, 1);
                 * sheet.setValue(0, 1, 2);
                 * sheet.setValue(0, 2, 3);
                 * sheet.addCustomName("customName1", "=12", 0, 0);
                 * sheet.addCustomName("customName2", "Average(20,45)", 0, 0);
                 * sheet.addCustomName("customName3", "=$A$1:$C$1");
                 * sheet.setFormula(1, 0, "customName1");
                 * sheet.setFormula(1, 1, "customName2");
                 * sheet.setFormula(1, 2, "sum(customName3)");
                 * var cname = sheet.getCustomName("customName2");
                 * if (cname instanceof GCTYPE.Spread.Sheets.NameInfo) {
                 *     // Get CustomName
                 *     var name = cname.getName();
                 *     // Get Expression
                 *     var expression = cname.getExpression();
                 *     // Get Expression String
                 *     var expStr = GCTYPE.Spread.Sheets.CalcEngine.expressionToFormula(sheet, expression, 0, 0);
                 *     console.log("Name: " + name + " ; Expression: " + expStr);
                 * }
                 */
                function expressionToFormula(context: Object,  expression: GCTYPE.Spread.CalcEngine.Expression,  baseRow?: number,  baseColumn?: number,  useR1C1?: boolean): string;
                /**
                 * Parse the specified formula to expression tree.
                 * @param {object} context The context; in general, you should use the active sheet object.
                 * @param {string} formula The formula string.
                 * @param {number} [baseRow] The base row index of the formula.
                 * @param {number} [baseColumn] The base column index of the formula.
                 * @param {boolean} [useR1C1] Whether to use the r1c1 reference style.
                 * @returns {GCTYPE.Spread.CalcEngine.Expression} The expression tree.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById('ss'), { sheetCount: 1 });
                 * sheet = spread.getSheet(0);
                 * sheet.setValue(0, 0, 1);
                 * sheet.setValue(0, 1, 2);
                 * sheet.setValue(0, 2, 3);
                 * sheet.getCell(4, 4).formula("=SUM(A1:C1)");
                 * var formula = sheet.getFormula(4, 4);
                 * var expression = GCTYPE.Spread.Sheets.CalcEngine.formulaToExpression(sheet, formula, 0, 0);
                 * console.log("Function Name is: " + expression.functionName);
                 */
                function formulaToExpression(context: Object,  formula: string,  baseRow?: number,  baseColumn?: number,  useR1C1?: boolean): GCTYPE.Spread.CalcEngine.Expression;
                /**
                 * Converts a formula string to the specified cell ranges.
                 * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The base sheet.
                 * @param {string} formula The formula.
                 * @param {number} baseRow The base row index of the formula.
                 * @param {number} baseCol The base column index of the formula.
                 * @returns {Array} The cell ranges that refers to the formula string.
                 */
                function formulaToRanges(sheet: GCTYPE.Spread.Sheets.Worksheet,  formula: string,  baseRow?: number,  baseCol?: number): Object[];
                /**
                 * Attempts to find a value for one cell that produces the desired formula result in another cell.
                 * @param {GCTYPE.Spread.Sheets.Worksheet} changingSheet The sheet that contains the cell that you want to adjust.
                 * @param {number} changingRow The row index of the cell that contains the value that you want to adjust.
                 * @param {number} changingColumn The column index of the cell that contains the value that you want to adjust.
                 * @param {GCTYPE.Spread.Sheets.Worksheet} formulaSheet The sheet that contains the formula that you want to resolve.
                 * @param {number} formulaRow The row index of the cell that contains the formula that you want to resolve.
                 * @param {number} formulaColumn The column index of the cell that contains the formula that you want to resolve.
                 * @param {number} desiredResult The formula result that you want.
                 * @returns {boolean} Indicate that whether a solution has been found.
                 * @example
                 * // This sample shows how to use the goal seek.
                 * // Loan amount is 10000, term is 18 months and pay 600 each month, evaluate what interest rate you will need to secure in order to meet your loan goal.
                 * sheet.setValue(0, 1, 10000); // Loan Amount
                 * sheet.setValue(1, 1, 18); // Term in Months
                 * sheet.setFormatter(2, 1, "0%"); // Interest Rate
                 * sheet.setFormatter(3, 1, "0.00");
                 * sheet.setFormula(3, 1, "PMT(B3/12,B2,B1)"); // Payment
                 * GCTYPE.Spread.Sheets.CalcEngine.goalSeek(sheet, 2, 1, sheet, 3, 1, -600); // result in B3 is 10%
                 */
                function goalSeek(changingSheet: GCTYPE.Spread.Sheets.Worksheet,  changingRow: number,  changingColumn: number,  formulaSheet: GCTYPE.Spread.Sheets.Worksheet,  formulaRow: number,  formulaColumn: number,  desiredResult: number): boolean;
                /**
                 * Converts the specified cell range to a formula string.
                 * @param {Array.<GCTYPE.Spread.Sheets.Range>} ranges The cell range in the sheet.
                 * @param {number} [baseRow] The base row index of the formula.
                 * @param {number} [baseCol] The base column index of the formula.
                 * @param {GCTYPE.Spread.Sheets.CalcEngine.RangeReferenceRelative} [rangeReferenceRelative] Whether the range reference is relative or absolute.
                 * @param {boolean} [useR1C1] Whether to use the r1c1 reference style.
                 * @returns {string} The formula string that refers to the specified cell range.
                 * @example
                 * spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById('ss'), { sheetCount: 1 });
                 * sheet = spread.getSheet(0);
                 * // Setting Value
                 * sheet.setValue(0, 0, 1, 3);
                 * sheet.setValue(1, 0, 50, 3);
                 * sheet.setValue(2, 0, 100, 3);
                 * sheet.setValue(3, 0, 2, 3);
                 * sheet.setValue(4, 0, 60, 3);
                 * sheet.setValue(5, 0, 90, 3);
                 * sheet.setValue(6, 0, 3, 3);
                 * sheet.setValue(7, 0, 40, 3);
                 * sheet.clearSelection();
                 * // Adding selections
                 * sheet.addSelection(0, 0, 3, 1);
                 * sheet.addSelection(5, 0, 2, 1);
                 * var ranges = sheet.getSelections();
                 * // getting range string
                 * var rangesStr = GCTYPE.Spread.Sheets.CalcEngine.rangesToFormula(ranges);
                 * // creating formula using selected ranges
                 * var formula = "Sum(" + rangesStr + ")";
                 * // setting formula in Sheet's cell
                 * sheet.setFormula(5, 5, formula, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                function rangesToFormula(ranges: GCTYPE.Spread.Sheets.Range[],  baseRow?: number,  baseCol?: number,  rangeReferenceRelative?: GCTYPE.Spread.Sheets.CalcEngine.RangeReferenceRelative,  useR1C1?: boolean): string;
                /**
                 * Converts the specified cell range to a formula string.
                 * @param {GCTYPE.Spread.Sheets.Range} range The cell range in the sheet.
                 * @param {number} [baseRow] The base row index of the formula.
                 * @param {number} [baseCol] The base column index of the formula.
                 * @param {GCTYPE.Spread.Sheets.CalcEngine.RangeReferenceRelative} [rangeReferenceRelative] Whether the range reference is relative or absolute.
                 * @param {boolean} [useR1C1] Whether to use the r1c1 reference style.
                 * @returns {string} The formula string that refers to the specified cell range.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById('ss'), { sheetCount: 1 });
                 * sheet = spread.getSheet(0);
                 * // setting value
                 * sheet.setValue(0, 0, 1, 3);
                 * sheet.setValue(1, 0, 50, 3);
                 * sheet.setValue(2, 0, 100, 3);
                 * sheet.setValue(3, 0, 2, 3);
                 * sheet.setValue(4, 0, 60, 3);
                 * sheet.setValue(5, 0, 90, 3);
                 * sheet.clearSelection();
                 * // adding selection
                 * sheet.addSelection(2, 0, 3, 1);
                 * var range = sheet.getSelections();
                 * // Getting range string
                 * var rangeStr = GCTYPE.Spread.Sheets.CalcEngine.rangeToFormula(range[0]);
                 * // creating formula using selected range
                 * var formula = "Sum(" + rangeStr + ")";
                 * // setting formula in Sheet's cell
                 * sheet.setFormula(5, 5, formula, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                function rangeToFormula(range: GCTYPE.Spread.Sheets.Range,  baseRow?: number,  baseCol?: number,  rangeReferenceRelative?: GCTYPE.Spread.Sheets.CalcEngine.RangeReferenceRelative,  useR1C1?: boolean): string;
                /**
                 * Specifies whether the range reference is relative or absolute.
                 * @enum {number}
                 */
                export enum RangeReferenceRelative{
                    /**
                     * Specifies all reference is absolute
                     */
                    allAbsolute= 0,
                    /**
                     * Specifies start row is relative
                     */
                    startRowRelative= 1,
                    /**
                     * Specifies start column is relative
                     */
                    startColRelative= 2,
                    /**
                     * Specifies end row is relative
                     */
                    endRowRelative= 4,
                    /**
                     * Specifies end column is relative
                     */
                    endColRelative= 8,
                    /**
                     * Specifies row is relative
                     */
                    rowRelative= 5,
                    /**
                     * Specifies column is relative
                     */
                    colRelative= 10,
                    /**
                     * Specifies all reference is relative
                     */
                    allRelative= 15
                }

            }

            module CellState{

                export class CellStateManager{
                    /**
                     * Represents a cellstate manager that can manage all cell state in a sheet.
                     * @class
                     * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The worksheet.
                     */
                    constructor(sheet: GCTYPE.Spread.Sheets.Worksheet);
                    /**
                     * @description Add cell state instance for range , which will apply style of cellState when the state of range cell matched.
                     * @param range {GCTYPE.Spread.Sheets.Range} The scope range which will apply style of cellState.
                     * @param state {GCTYPE.Spread.Sheets.CellStatesType} Which state will use style.
                     * @param style {GCTYPE.Spread.Sheets.Style} Which style when the state is matched.
                     * @param sheetArea {GCTYPE.Spread.Sheets.SheetArea} The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                     * @example
                     * var style = new  GCTYPE.Spread.Sheets.Style();
                     * style.backColor = 'blue';
                     * style.foreColor = 'red';
                     * var range = new GCTYPE.Spread.Sheets.Range(1,2,3,3);
                     * sheet.cellStates.add(range,GCTYPE.Spread.Sheets.CellStatesType.hover,style,101);
                     */
                    add(range: GCTYPE.Spread.Sheets.Range,  state: GCTYPE.Spread.Sheets.CellStatesType,  style: GCTYPE.Spread.Sheets.Style,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                    /**
                     * @description Clear all style by range, after clear there are no style will be applied when the cell state is matched.
                     * @param range {GCTYPE.Spread.Sheets.Range} The scope range for clear.
                     * @param sheetArea {GCTYPE.Spread.Sheets.SheetArea} The sheet area. If this parameter is not provided, it defaults to <b>viewport</b>.
                     * @example
                     * var range = new GCTYPE.Spread.Sheets.Range(1,2,3,3);
                     * sheet.cellStates.clear(range, GCTYPE.Spread.Sheets.SheetArea.viewport);
                     */
                    clear(range: GCTYPE.Spread.Sheets.Range,  sheetArea: GCTYPE.Spread.Sheets.SheetArea): void;
                }
            }

            module CellTypes{

                export interface ICelltypeItemOption{
                    text: string;
                    value: number | string;
                }


                export interface IItemSpacing{
                    horizontal?: number;
                    vertical?: number;
                }

                /**
                 * Specifies the text alignment for check box cells.
                 * @enum {number}
                 * @example
                 * //This example creates a check box cell.
                 * var cellType1 = new GCTYPE.Spread.Sheets.CellTypes.CheckBox();
                 * cellType1.caption("caption");
                 * cellType1.textTrue("true");
                 * cellType1.textFalse("false");
                 * cellType1.textIndeterminate("indeterminate");
                 * cellType1.textAlign(GCTYPE.Spread.Sheets.CellTypes.CheckBoxTextAlign.bottom);
                 * cellType1.isThreeState(true);
                 * cellType1.boxSize(20);
                 * activeSheet.getCell(1, 1).cellType(cellType1);
                 */
                export enum CheckBoxTextAlign{
                    /**
                     * Specifies text is on top of the check box.
                     */
                    top= 0,
                    /**
                     * Specifies text is below the check box.
                     */
                    bottom= 1,
                    /**
                     * Specifies text is to the left of the check box.
                     */
                    left= 2,
                    /**
                     * Specifies text is to the right of the check box.
                     */
                    right= 3
                }

                /**
                 * Specifies the extend direction for radio list cells.
                 * @enum {number}
                 * @example
                 * //This example creates a radio button list cell.
                 * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.RadioButtonList();
                 * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                 * cellType2.direction(GCTYPE.Spread.Sheets.CellTypes.Direction.vertical);
                 * activeSheet.getCell(2, 2).cellType(cellType2);
                 */
                export enum Direction{
                    /**
                     * Specifies item extend by horizontal.
                     */
                    horizontal= 0,
                    /**
                     * Specifies item extend by vertical.
                     */
                    vertical= 1
                }

                /**
                 * Represents the editor type of text cell type.
                 * @enum {number}
                 * @example
                 * //This example shows how to change the editor of text cell type to textarea.
                 * var tempStyle = new GCTYPE.Spread.Sheets.Style();
                 * tempStyle.cellType = new GCTYPE.Spread.Sheets.CellTypes.Text(GCTYPE.Spread.Sheets.CellTypes.EditorType.textarea);
                 * activeSheet.setDefaultStyle(tempStyle);
                 */
                export enum EditorType{
                    /**
                     *  Use textarea element as the editor of text cell type.
                     */
                    textarea= 0,
                    /**
                     *  Use editorable div element as the editor of text cell type.
                     */
                    editableDiv= 1
                }

                /**
                 *  Specifies what is written out to the data model for a selected item from
                 *  certain cell types that offer a selection of multiple values.
                 * @readonly
                 * @enum {number}
                 * @example
                 * //This example uses the EditorValueType enumeration.
                 * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.ComboBox();
                 * cellType2.items(["a","b","c"]);
                 * cellType2.editorValueType(GCTYPE.Spread.Sheets.CellTypes.EditorValueType.text);
                 * activeSheet.getCell(2, 2).cellType(cellType2);
                 */
                export enum EditorValueType{
                    /**
                     *  Writes the text value of the selected item to the model.
                     */
                    text= 0,
                    /**
                     * Writes the index of the selected item to the model.
                     */
                    index= 1,
                    /**
                     *  Writes the corresponding data value of the selected item to the model.
                     */
                    value= 2
                }

                /**
                 * Specifies the hyperlink's target type.
                 * @enum {number}
                 * @example
                 * //This example creates a hyperlink cell.
                 * var cellType = new GCTYPE.Spread.Sheets.CellTypes.HyperLink();
                 * cellType.linkColor("blue");
                 * cellType.visitedLinkColor("#FFFF00");
                 * cellType.text("GrapeCity");
                 * cellType.linkToolTip("Company Web Site");
                 * cellType.target(GCTYPE.Spread.Sheets.CellTypes.HyperLinkTargetType.self);
                 * activeSheet.getCell(0, 2).cellType(cellType).value("http://www.grapecity.com/");
                 */
                export enum HyperLinkTargetType{
                    /**
                     * Opens the hyperlinked document in a new window or tab.
                     */
                    blank= 0,
                    /**
                     * Opens the hyperlinked document in the same frame where the user clicked.
                     */
                    self= 1,
                    /**
                     * Opens the hyperlinked document in the parent frame.
                     */
                    parent= 2,
                    /**
                     * Opens the hyperlinked document in the full body of the window.
                     */
                    top= 3
                }

                /**
                 * Specifies the text selection mode for buttonList cells.
                 * @enum {number}
                 * @example
                 * //This example creates a buttonList cell.
                 * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.ButtonList();
                 * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                 * cellType2.selectionMode(GCTYPE.Spread.Sheets.CellTypes.SelectionMode.single);
                 * activeSheet.getCell(2, 2).cellType(cellType2);
                 */
                export enum SelectionMode{
                    /**
                     * Specifies selection mode is single.
                     */
                    single= 0,
                    /**
                     * Specifies selection mode is multiple.
                     */
                    multiple= 1
                }

                /**
                 * Specifies the text alignment for check box cells.
                 * @enum {number}
                 * @example
                 * //This example creates a check box cell.
                 * var cellType = new GCTYPE.Spread.Sheets.CellTypes.RadioButtonList();
                 * cellType.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                 * cellType.textAlign(GCTYPE.Spread.Sheets.CellTypes.TextAlign.left);
                 * activeSheet.getCell(2, 2).cellType(cellType);
                 */
                export enum TextAlign{
                    /**
                     * Specifies text is on the top.
                     */
                    //top = 0, = 0,
                    /**
                     * Specifies text is on the bottom.
                     */
                    //bottom = 1, = 1,
                    /**
                     * Specifies text is on the left.
                     */
                    left= 2,
                    /**
                     * Specifies text is on the right.
                     */
                    right= 3
                }


                export class Base{
                    /**
                     * Represents the base class for the other cell type classes.
                     * @class
                     */
                    constructor();
                    /**
                     * Represents the type name string used for supporting serialization.
                     * @type {string}
                     */
                    typeName: string;
                    /**
                     * Activates the editor, including setting properties or attributes for the editor and binding events for the editor.
                     * @param {Object} editorContext The DOM element that was created by the createEditorElement method.
                     * @param {GCTYPE.Spread.Sheets.Style} cellStyle The cell's actual style.
                     * @param {GCTYPE.Spread.Sheets.Rect} cellRect The cell's layout information.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     */
                    activateEditor(editorContext: HTMLElement,  cellStyle: GCTYPE.Spread.Sheets.Style,  cellRect: GCTYPE.Spread.Sheets.Rect,  context?: any): void;
                    /**
                     * Creates a DOM element then returns it.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {HTMLElement} Returns a DOM element.
                     */
                    createEditorElement(context?: any): HTMLElement;
                    /**
                     * Deactivates the editor, such as unbinding events for editor.
                     * @param {Object} editorContext The DOM element that was created by the createEditorElement method.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     */
                    deactivateEditor(editorContext: HTMLElement,  context?: any): void;
                    /**
                     * Focuses the editor DOM element.
                     * @param {HTMLElement} editorContext The DOM element that was created by the createEditorElement method.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     */
                    focus(editorContext: HTMLElement,  context?: any): void;
                    /**
                     * Formats a value with the specified format to a string.
                     * @param {Object} value The object value to format.
                     * @param {GCTYPE.Spread.Formatter.GeneralFormatter | string} format The format.
                     * @param {Object} formattedData the formatted data.
                     * @param {Array} [formattedData.content] - The formatted data array, each item is an object that has two properties type and value, And it may contain these types: 'number', 'text', 'fillingChar', 'placeholder', 'exponent', 'decimalSeparator', 'groupSeparator', 'numberPlaceholder', 'percent', 'permille' and 'currency'. For example: {type: 'number', value: '123'}.
                     * @param {string} [formattedData.conditionalForeColor] - The conditional foreground color.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {string} Returns the formatted string.
                     */
                    format(value: any,  format: GCTYPE.Spread.Formatter.GeneralFormatter | string,  formattedData?: GCTYPE.Spread.Sheets.FormattedData,  context?: any): string;
                    /**
                     * Loads the object state from the specified JSON string.
                     * @param {Object} settings The cell type data from deserialization.
                     */
                    fromJSON(settings: any): void;
                    /**
                     * Gets a cell's height that can be used to handle the row's automatic fit.
                     * @param {Object} value The cell's value.
                     * @param {string} text The cell's text.
                     * @param {GCTYPE.Spread.Sheets.Style} cellStyle The cell's actual value.
                     * @param {number} zoomFactor The current sheet's zoom factor.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {number} Returns the cell's height that can be used to handle the row's automatic fit.
                     */
                    getAutoFitHeight(value: any,  text: string,  cellStyle: GCTYPE.Spread.Sheets.Style,  zoomFactor: number,  context?: any): number;
                    /**
                     * Gets a cell's width that can be used to handle the column's automatic fit.
                     * @param {Object} value The cell's value.
                     * @param {string} text The cell's text.
                     * @param {GCTYPE.Spread.Sheets.Style} cellStyle The cell's actual value.
                     * @param {number} zoomFactor The current sheet's zoom factor.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {number} Returns the cell's width that can be used to handle the column's automatic fit.
                     */
                    getAutoFitWidth(value: any,  text: string,  cellStyle: GCTYPE.Spread.Sheets.Style,  zoomFactor: number,  context?: any): number;
                    /**
                     * Gets the editor's value.
                     * @param {Object} editorContext The DOM element that was created by the createEditorElement method.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {Object} Returns the editor's value.
                     */
                    getEditorValue(editorContext: HTMLElement,  context?: any): any;
                    /**
                     * Gets the cell type's hit information.
                     * @param {number} x <i>x</i>-coordinate of pointer's current location relative to the canvas.
                     * @param {number} y <i>y</i>-coordinate of pointer's current location relative to the canvas.
                     * @param {GCTYPE.Spread.Sheets.Style} cellStyle The current cell's actual style.
                     * @param {GCTYPE.Spread.Sheets.Rect} cellRect The current cell's layout information.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {Object} Returns an object that contains the <i>x</i>, <i>y</i>, <i>row</i>, <i>col</i>, <i>cellRect</i>, and <i>sheetArea</i> parameters, and a value to indicate <i>isReservedLocation</i>.
                     * <i>isReservedLocation</i> is <c>true</c> if the hit test is in a special area that the cell type needs to handle; otherwise, <c>false</c>.
                     */
                    getHitInfo(x: number,  y: number,  cellStyle: GCTYPE.Spread.Sheets.Style,  cellRect: GCTYPE.Spread.Sheets.Rect,  context?: any): GCTYPE.Spread.Sheets.IHitTestCellTypeHitInfo;
                    /**
                     * Whether the editing value has changed.
                     * @param {Object} oldValue Old editing value.
                     * @param {Object} newValue New editing value.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {boolean} <c>true</c> if oldValue equals newValue; otherwise, <c>false</c>.
                     */
                    isEditingValueChanged(oldValue: any,  newValue: any,  context?: any): boolean;
                    /**
                     * Whether this cell type is aware of IME.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {boolean} <c>true</c> if the cell type is aware of IME; otherwise, <c>false</c>.
                     */
                    isImeAware(context?: any): boolean;
                    /**
                     * Whether the cell type handles the keyboard event itself.
                     * @param {KeyboardEvent} e The KeyboardEvent.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {boolean} Returns <c>true</c> if the cell type handles the keyboard event itself; otherwise, <c>false</c>.
                     */
                    isReservedKey(e: KeyboardEvent,  context?: any): boolean;
                    /**
                     * Paints a cell on the canvas.
                     * @param {CanvasRenderingContext2D} ctx The canvas's two-dimensional context.
                     * @param {Object} value The cell's value.
                     * @param {number} x <i>x</i>-coordinate relative to the canvas.
                     * @param {number} y <i>y</i>-coordinate relative to the canvas.
                     * @param {number} w The cell's width.
                     * @param {number} h The cell's height.
                     * @param {GCTYPE.Spread.Sheets.Style} style The cell's actual style.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     */
                    paint(ctx: CanvasRenderingContext2D,  value: any,  x: number,  y: number,  w: number,  h: number,  style: GCTYPE.Spread.Sheets.Style,  context?: any): void;
                    /**
                     * Paints the cell content area on the canvas.
                     * @param {CanvasRenderingContext2D} ctx The canvas's two-dimensional context.
                     * @param {Object} value The cell's value.
                     * @param {number} x <i>x</i>-coordinate relative to the canvas.
                     * @param {number} y <i>y</i>-coordinate relative to the canvas.
                     * @param {number} w The cell content area's width.
                     * @param {number} h The cell content area's height.
                     * @param {GCTYPE.Spread.Sheets.Style} style The cell's actual style.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     */
                    paintContent(ctx: CanvasRenderingContext2D,  value: any,  x: number,  y: number,  w: number,  h: number,  style: GCTYPE.Spread.Sheets.Style,  context?: any): void;
                    /**
                     * Parses the text with the specified format string to an object.
                     * @param {string} text The parse text string.
                     * @param {string} formatStr The parse format string.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {Object} The parsed object.
                     */
                    parse(text: string,  formatStr: string,  context?: any): any;
                    /**
                     * Processes key down in display mode.
                     * @param {KeyboardEvent} event The KeyboardEvent.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {boolean} Returns <c>true</c> if the process is successful; otherwise, <c>false</c>.
                     */
                    processKeyDown(event: KeyboardEvent,  context?: any): boolean;
                    /**
                     * Processes key up in display mode.
                     * @param {KeyboardEvent} event The KeyboardEvent.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {boolean} Returns <c>true</c> if the process is successful; otherwise, <c>false</c>.
                     */
                    processKeyUp(event: KeyboardEvent,  context?: any): boolean;
                    /**
                     * Processes mouse down in display mode.
                     * @param {Object} hitInfo The hit test information returned by the getHitInfo method. See the Remarks for more information.
                     * @returns {boolean} Returns <c>true</c> if the process is successful; otherwise, <c>false</c>.
                     */
                    processMouseDown(hitInfo: GCTYPE.Spread.Sheets.IHitTestCellTypeHitInfo): boolean;
                    /**
                     * Processes mouse enter in display mode.
                     * @param {Object} hitInfo The hit test information returned by the getHitInfo method. See the Remarks for more information.
                     * @returns {boolean} Returns <c>true</c> if the process is successful; otherwise, <c>false</c>.
                     */
                    processMouseEnter(hitInfo: GCTYPE.Spread.Sheets.IHitTestCellTypeHitInfo): boolean;
                    /**
                     * Processes mouse leave in display mode.
                     * @param {Object} hitInfo The hit test information returned by the getHitInfo method. See the Remarks for more information.
                     * @returns {boolean} Returns <c>true</c> if the process is successful; otherwise, <c>false</c>.
                     */
                    processMouseLeave(hitInfo: GCTYPE.Spread.Sheets.IHitTestCellTypeHitInfo): boolean;
                    /**
                     * Processes mouse move in display mode.
                     * @param {Object} hitInfo The hit test information returned by the getHitInfo method. See the Remarks for more information.
                     * @returns {boolean} Returns <c>true</c> if the process is successful; otherwise, <c>false</c>.
                     */
                    processMouseMove(hitInfo: GCTYPE.Spread.Sheets.IHitTestCellTypeHitInfo): boolean;
                    /**
                     * Processes mouse up in display mode.
                     * @param {Object} hitInfo The hit test information returned by the getHitInfo method. See the Remarks for more information.
                     * @returns {boolean} Returns <c>true</c> if the process is successful; otherwise, <c>false</c>.
                     */
                    processMouseUp(hitInfo: GCTYPE.Spread.Sheets.IHitTestCellTypeHitInfo): boolean;
                    /**
                     * Selects all the text in the editor DOM element.
                     * @param {Object} editorContext The DOM element that was created by the createEditorElement method.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     */
                    selectAll(editorContext: HTMLElement,  context?: any): void;
                    /**
                     * Sets the editor's value.
                     * @param {Object} editorContext The DOM element that was created by the createEditorElement method.
                     * @param {Object} value The value returned from the active cell.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     */
                    setEditorValue(editorContext: HTMLElement,  value: any,  context?: any): void;
                    /**
                     * Saves the object state to a JSON string.
                     * @returns {Object} The cell type data.
                     */
                    toJSON(): any;
                    /**
                     * Updates the editor's size.
                     * @param {Object} editorContext The DOM element that was created by the createEditorElement method.
                     * @param {GCTYPE.Spread.Sheets.Style} cellStyle The cell's actual style.
                     * @param {GCTYPE.Spread.Sheets.Rect} cellRect The cell's layout information.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     * @returns {GCTYPE.Spread.Sheets.Rect} Returns the new size for cell wrapper element, it should contain two properties 'width' and 'height'.
                     */
                    updateEditor(editorContext: HTMLElement,  cellStyle: GCTYPE.Spread.Sheets.Style,  cellRect: GCTYPE.Spread.Sheets.Rect,  context?: any): GCTYPE.Spread.Sheets.Rect;
                    /**
                     * Updates the cell wrapper element size.
                     * @param {HTMLElement} editorContext The DOM element that was created by the createEditorElement method.
                     * @param {GCTYPE.Spread.Sheets.Rect} editorBounds The cell wrapper element's new size.
                     * @param {number} editorBounds.x - The cell wrapper element's x position.
                     * @param {number} editorBounds.y - The cell wrapper element's y position.
                     * @param {number} editorBounds.width - The cell wrapper element's new width value.
                     * @param {number} editorBounds.height - The cell wrapper element's new height value.
                     * @param {GCTYPE.Spread.Sheets.Style} cellStyle The cell's actual style.
                     */
                    updateEditorContainer(editorContext: HTMLElement,  editorBounds: GCTYPE.Spread.Sheets.Rect,  cellStyle: GCTYPE.Spread.Sheets.Style): void;
                    /**
                     * Updates the editor's ime-mode.
                     * @param {Object} editorContext The DOM element that was created by the createEditorElement method.
                     * @param {GCTYPE.Spread.Sheets.ImeMode} imeMode The ime-mode from cell's actual style.
                     * @param {Object} context The context associated with the cell type. See the Remarks for more information.
                     */
                    updateImeMode(editorContext: HTMLElement,  imeMode: GCTYPE.Spread.Sheets.ImeMode,  context?: any): void;
                }

                export class Button extends Base{
                    /**
                     * Represents a button cell.
                     * @extends GCTYPE.Spread.Sheets.CellTypes.Base
                     * @class
                     * @example
                     * //This example creates a button cell.
                     * var spread = new GCTYPE.Spread.Sheets.Workbook();
                     * var sheet = spread.getActiveSheet();
                     * var cellType = new GCTYPE.Spread.Sheets.CellTypes.Button();
                     * cellType.buttonBackColor("#FFFF00");
                     * cellType.text("this is a button");
                     * sheet.setCellType(1,1,cellType);
                     * //Bind event
                     * spread.bind(GCTYPE.Spread.Sheets.Events.ButtonClicked, function (e, args) {
                     *     var sheet = args.sheet, row = args.row, col = args.col;
                     *     var cellType = sheet.getCellType(row, col);
                     *     if (cellType instanceof GCTYPE.Spread.Sheets.CellTypes.Button) {
                     *         alert("Button Clicked");
                     *     }
                     * });
                     */
                    constructor();
                    /**
                     * Gets or sets the button's background color.
                     * @param {string} value The button's background color.
                     * @returns {string | GCTYPE.Spread.Sheets.CellTypes.Button} If no value is set, returns the background color; otherwise, returns the button cell type.
                     * @example
                     * //This example creates a button cell.
                     * var cellType = new GCTYPE.Spread.Sheets.CellTypes.Button();
                     * cellType.buttonBackColor("#FFFF00");
                     * cellType.text("this is a button");
                     * activeSheet.getCell(0, 2).cellType(cellType);
                     */
                    buttonBackColor(value?: string): any;
                    /**
                     * Gets or sets the button's bottom margin in pixels relative to the cell.
                     * @param {number} value The button's bottom margin relative to the cell.
                     * @returns {number | GCTYPE.Spread.Sheets.CellTypes.Button} If no value is set, returns the bottom margin in pixels; otherwise, returns the button cell type.
                     * @example
                     * //This example creates a button cell and sets its margins.
                     * var cellType = new GCTYPE.Spread.Sheets.CellTypes.Button();
                     * cellType.buttonBackColor("#FFFF00");
                     * cellType.text("this is a button");
                     * cellType.marginTop(5).marginRight(8).marginBottom(10).marginLeft(12);
                     * activeSheet.getCell(0, 2).cellType(cellType);
                     * activeSheet.setColumnWidth(2, 120.0,GCTYPE.Spread.Sheets.SheetArea.viewport);
                     * activeSheet.setRowHeight(0, 90.0,GCTYPE.Spread.Sheets.SheetArea.viewport);
                     */
                    marginBottom(value?: number): any;
                    /**
                     * Gets or sets the button's left margin in pixels relative to the cell.
                     * @param {number} value The button's left margin relative to the cell.
                     * @returns {number | GCTYPE.Spread.Sheets.CellTypes.Button} If no value is set, returns the left margin in pixels; otherwise, returns the button cell type.
                     * @example
                     * //This example creates a button cell and sets its margins.
                     * var cellType = new GCTYPE.Spread.Sheets.CellTypes.Button();
                     * cellType.buttonBackColor("#FFFF00");
                     * cellType.text("this is a button");
                     * cellType.marginTop(5).marginRight(8).marginBottom(10).marginLeft(12);
                     * activeSheet.getCell(0, 2).cellType(cellType);
                     * activeSheet.setColumnWidth(2, 120.0,GCTYPE.Spread.Sheets.SheetArea.viewport);
                     * activeSheet.setRowHeight(0, 90.0,GCTYPE.Spread.Sheets.SheetArea.viewport);
                     */
                    marginLeft(value?: number): any;
                    /**
                     * Gets or sets the button's right margin in pixels relative to the cell.
                     * @param {number} value The button's right margin relative to the cell.
                     * @returns {number | GCTYPE.Spread.Sheets.CellTypes.Button} If no value is set, returns the right margin in pixels; otherwise, returns the button cell type.
                     * @example
                     * //This example creates a button cell and sets its margins.
                     * var cellType = new GCTYPE.Spread.Sheets.CellTypes.Button();
                     * cellType.buttonBackColor("#FFFF00");
                     * cellType.text("this is a button");
                     * cellType.marginTop(5).marginRight(8).marginBottom(10).marginLeft(12);
                     * activeSheet.getCell(0, 2).cellType(cellType);
                     * activeSheet.setColumnWidth(2, 120.0,GCTYPE.Spread.Sheets.SheetArea.viewport);
                     * activeSheet.setRowHeight(0, 90.0,GCTYPE.Spread.Sheets.SheetArea.viewport);
                     */
                    marginRight(value?: number): any;
                    /**
                     * Gets or sets the button's top margin in pixels relative to the cell.
                     * @param {number} value The button's top margin relative to the cell.
                     * @returns {number | GCTYPE.Spread.Sheets.CellTypes.Button} If no value is set, returns the top margin in pixels; otherwise, returns the button cell type.
                     * @example
                     * //This example creates a button cell and sets its margins.
                     * var cellType = new GCTYPE.Spread.Sheets.CellTypes.Button();
                     * cellType.buttonBackColor("#FFFF00");
                     * cellType.text("this is a button");
                     * cellType.marginTop(5).marginRight(8).marginBottom(10).marginLeft(12);
                     * activeSheet.getCell(0, 2).cellType(cellType);
                     * activeSheet.setColumnWidth(2, 120.0,GCTYPE.Spread.Sheets.SheetArea.viewport);
                     * activeSheet.setRowHeight(0, 90.0,GCTYPE.Spread.Sheets.SheetArea.viewport);
                     */
                    marginTop(value?: number): any;
                    /**
                     * Gets or sets the button's content.
                     * @param {string} value The button's content.
                     * @returns {string | GCTYPE.Spread.Sheets.CellTypes.Button} If no value is set, returns the content; otherwise, returns the button cell type.
                     * @example
                     * //This example creates a button cell.
                     * var cellType = new GCTYPE.Spread.Sheets.CellTypes.Button();
                     * cellType.buttonBackColor("#FFFF00");
                     * cellType.text("this is a button");
                     * activeSheet.getCell(0, 2).cellType(cellType);
                     */
                    text(value?: string): any;
                }

                export class ButtonList extends Base{
                    /**
                     * Represents an editable buttonList cell.
                     * @extends GCTYPE.Spread.Sheets.CellTypes.Base
                     * @class
                     * @example
                     * //This example creates a buttonList cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.ButtonList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    constructor();
                    /**
                     * Gets or sets the buttonList list's orders.
                     * @param {GCTYPE.Spread.Sheets.CellTypes.Direction} value Whether the order is vertical.
                     * @returns {GCTYPE.Spread.Sheets.CellTypes.Direction | GCTYPE.Spread.Sheets.CellTypes.ButtonList} If no value is set, returns whether the buttonList list's orders is vertical; otherwise, returns the checkbox list cellType.
                     * @example
                     * //This example creates a buttonList list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.ButtonList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.direction(GCTYPE.Spread.Sheets.CellTypes.Direction.vertical);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    direction(value?: GCTYPE.Spread.Sheets.CellTypes.Direction): any;
                    /**
                     * Gets or sets the buttonList list's layout is autofit.
                     * @param {boolean} value Whether the layout is autofit.
                     * @returns {boolean | GCTYPE.Spread.Sheets.CellTypes.ButtonList} If no value is set, returns whether the layout is autofit, returns the buttonList list cellType.
                     * @example
                     * //This example creates a buttonList list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.ButtonList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.isFlowLayout(true);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    isFlowLayout(value?: boolean): any;
                    /**
                     * Gets or sets the items for the buttonList list.
                     * @param {Array} items The items for the buttonList list.
                     * @returns {Array | GCTYPE.Spread.Sheets.CellTypes.ButtonList} If no value is set, returns the items array; otherwise, returns the buttonList list cellType.
                     * @example
                     * //This example creates a buttonList list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.ButtonList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    items(items?: GCTYPE.Spread.Sheets.CellTypes.ICelltypeItemOption[] | string[]): any;
                    /**
                     * Gets or sets the space for two items in the buttonList.
                     * @param {object} value the space for two items in the buttonList.
                     * @returns {object | GCTYPE.Spread.Sheets.CellTypes.ButtonList} If no value is set, returns the space for two items in the buttonList; otherwise, returns the buttonList cellType.
                     * @example
                     * //This example creates a buttonList cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.ButtonList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.itemSpacing({
                     *      horizontal:80,
                     *      vertical:20
                     * });
                     */
                    itemSpacing(value?: GCTYPE.Spread.Sheets.CellTypes.IItemSpacing): any;
                    /**
                     * Gets or sets the items for the buttonList list's column count.
                     * @param {number} value The column count for the buttonList list.
                     * @returns {number | GCTYPE.Spread.Sheets.CellTypes.ButtonList} If no value is set, returns the column count; otherwise, returns the buttonList list cellType.
                     * @example
                     * //This example creates a buttonList list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.ButtonList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.maxColumnCount(2);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    maxColumnCount(value?: number): any;
                    /**
                     * Gets or sets the items for the buttonList list's row count.
                     * @param {number} value The row count for the buttonList list.
                     * @returns {number | GCTYPE.Spread.Sheets.CellTypes.ButtonList} If no value is set, returns the row count; otherwise, returns the buttonList list cellType.
                     * @example
                     * //This example creates buttonList list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.ButtonList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.maxRowCount(2);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    maxRowCount(value?: number): any;
                    /**
                     * Gets or sets the buttonList's padding in pixels relative to the cell.
                     * @param {string} value The buttonList's padding relative to the cell.
                     * @returns {string | GCTYPE.Spread.Sheets.CellTypes.ButtonList} If no value is set, returns the padding in pixels; otherwise, returns the buttonList cell type.
                     * @example
                     * //This example creates a buttonList cell and sets its padding.
                     * var cellType = new GCTYPE.Spread.Sheets.CellTypes.ButtonList();
                     * cellType.padding("5");
                     * activeSheet.getCell(0, 2).cellType(cellType);
                     * activeSheet.setColumnWidth(2, 120.0,GCTYPE.Spread.Sheets.SheetArea.viewport);
                     * activeSheet.setRowHeight(0, 90.0,GCTYPE.Spread.Sheets.SheetArea.viewport);
                     */
                    padding(value?: string): any;
                    /**
                     * Gets or sets the selected buttonList's background color.
                     * @param {string} value The selected buttonList's background color.
                     * @returns {string | GCTYPE.Spread.Sheets.CellTypes.ButtonList} If no value is set, returns the background color; otherwise, returns the buttonList cell type.
                     * @example
                     * //This example creates a buttonList cell.
                     * var cellType = new GCTYPE.Spread.Sheets.CellTypes.ButtonList();
                     * cellType.selectedBackColor("#FFFF00");
                     * activeSheet.getCell(0, 2).cellType(cellType);
                     */
                    selectedBackColor(value?: string): any;
                    /**
                     * Gets or sets the selected buttonList's fore color.
                     * @param {string} value The selected buttonList's fore color.
                     * @returns {string | GCTYPE.Spread.Sheets.CellTypes.ButtonList} If no value is set, returns the fore color; otherwise, returns the buttonList cell type.
                     * @example
                     * //This example creates a buttonList cell.
                     * var cellType = new GCTYPE.Spread.Sheets.CellTypes.ButtonList();
                     * cellType.selectedForeColor("#FFFF00");
                     * activeSheet.getCell(0, 2).cellType(cellType);
                     */
                    selectedForeColor(value?: string): any;
                    /**
                     * Gets or sets the buttonList's select mode.
                     * @param {GCTYPE.Spread.Sheets.CellTypes.SelectionMode} value The selected buttonList's select mode.
                     * @returns {GCTYPE.Spread.Sheets.CellTypes.SelectionMode | GCTYPE.Spread.Sheets.CellTypes.ButtonList} If no value is set, returns the select mode; otherwise, returns the buttonList cell type.
                     * @example
                     * //This example creates a buttonList cell.
                     * var cellType = new GCTYPE.Spread.Sheets.CellTypes.ButtonList();
                     * cellType.selectionMode(GCTYPE.Spread.Sheets.CellTypes.SelectionMode.single);
                     * activeSheet.getCell(0, 2).cellType(cellType);
                     */
                    selectionMode(value?: GCTYPE.Spread.Sheets.CellTypes.SelectionMode): any;
                }

                export class CheckBox extends Base{
                    /**
                     * Represents a check box cell.
                     * @extends GCTYPE.Spread.Sheets.CellTypes.Base
                     * @class
                     * @example
                     * //This example creates a check box cell.
                     * var cellType1 = new GCTYPE.Spread.Sheets.CellTypes.CheckBox();
                     * cellType1.caption("caption");
                     * cellType1.textTrue("true");
                     * cellType1.textFalse("false");
                     * cellType1.textIndeterminate("indeterminate");
                     * cellType1.textAlign(GCTYPE.Spread.Sheets.CellTypes.CheckBoxTextAlign.bottom);
                     * cellType1.isThreeState(true);
                     * cellType1.boxSize(20);
                     * activeSheet.getCell(1, 1).cellType(cellType1);
                     */
                    constructor();
                    /**
                     * Gets or sets a value that indicates the check box size
                     * @param {number | string} value The size of check box. this value support number and "auto".
                     * @returns {number | string | GCTYPE.Spread.Sheets.CellTypes.CheckBox} If no value is set, returns the size of check box.
                     * // This example creates a check box cell.
                     * var cellType1 = new GCTYPE.Spread.Sheets.CellTypes.CheckBox();
                     * cellType1.caption("caption");
                     * cellType1.textTrue("true");
                     * cellType1.textFalse("false");
                     * cellType1.textIndeterminate("indeterminate");
                     * cellType1.textAlign(GCTYPE.Spread.Sheets.CellTypes.CheckBoxTextAlign.bottom);
                     * cellType1.isThreeState(true);
                     * cellType1.boxSize(20);
                     * activeSheet.getCell(1, 1).cellType(cellType1);
                     */
                    boxSize(value?: number | string): any;
                    /**
                     * Gets or sets the caption of the cell type.
                     * @param {string} value The caption of the cell type.
                     * @returns {string | GCTYPE.Spread.Sheets.CellTypes.CheckBox} If no value is set, returns the caption; otherwise, returns the check box cell type.
                     * @example
                     * //This example creates a check box cell.
                     * var cellType1 = new GCTYPE.Spread.Sheets.CellTypes.CheckBox();
                     * cellType1.caption("caption");
                     * cellType1.textTrue("true");
                     * cellType1.textFalse("false");
                     * cellType1.textIndeterminate("indeterminate");
                     * cellType1.textAlign(GCTYPE.Spread.Sheets.CellTypes.CheckBoxTextAlign.bottom);
                     * cellType1.isThreeState(true);
                     * cellType1.boxSize(20);
                     * activeSheet.getCell(1, 1).cellType(cellType1);
                     */
                    caption(value?: string): any;
                    /**
                     * Gets or sets a value that indicates whether the check box supports three states.
                     * @param {boolean} value Whether the check box supports three states.
                     * @returns {boolean | GCTYPE.Spread.Sheets.CellTypes.CheckBox} If no value is set, returns whether the check box supports three states; otherwise, returns the check box cell type.
                     * @example
                     * //This example creates a check box cell.
                     * var cellType1 = new GCTYPE.Spread.Sheets.CellTypes.CheckBox();
                     * cellType1.caption("caption");
                     * cellType1.textTrue("true");
                     * cellType1.textFalse("false");
                     * cellType1.textIndeterminate("indeterminate");
                     * cellType1.textAlign(GCTYPE.Spread.Sheets.CellTypes.CheckBoxTextAlign.bottom);
                     * cellType1.isThreeState(true);
                     * cellType1.boxSize(20);
                     * activeSheet.getCell(1, 1).cellType(cellType1);
                     */
                    isThreeState(value?: boolean): any;
                    /**
                     * Gets or sets the text alignment relative to the check box.
                     * @param {GCTYPE.Spread.Sheets.CellTypes.CheckBoxTextAlign} value The text alignment relative to the check box.
                     * @returns {GCTYPE.Spread.Sheets.CellTypes.CheckBoxTextAlign | GCTYPE.Spread.Sheets.CellTypes.CheckBox} If no value is set, returns the text alignment relative to the check box; otherwise, returns the check box cell type.
                     * @example
                     * //This example creates a check box cell.
                     * var cellType1 = new GCTYPE.Spread.Sheets.CellTypes.CheckBox();
                     * cellType1.caption("caption");
                     * cellType1.textTrue("true");
                     * cellType1.textFalse("false");
                     * cellType1.textIndeterminate("indeterminate");
                     * cellType1.textAlign(GCTYPE.Spread.Sheets.CellTypes.CheckBoxTextAlign.bottom);
                     * cellType1.isThreeState(true);
                     * cellType1.boxSize(20);
                     * activeSheet.getCell(1, 1).cellType(cellType1);
                     */
                    textAlign(value?: GCTYPE.Spread.Sheets.CellTypes.CheckBoxTextAlign): any;
                    /**
                     * Gets or sets the text in the cell when the cell's value is <c>false</c>.
                     * @param {string} value The text in the cell when the cell's value is <c>false</c>.
                     * @returns {string | GCTYPE.Spread.Sheets.CellTypes.CheckBox} If no value is set, returns the text in the cell when the cell's value is <c>false</c>. If a value is set, returns the check box cell type.
                     * @example
                     * //This example creates a check box cell.
                     * var cellType1 = new GCTYPE.Spread.Sheets.CellTypes.CheckBox();
                     * cellType1.caption("caption");
                     * cellType1.textTrue("true");
                     * cellType1.textFalse("false");
                     * cellType1.textIndeterminate("indeterminate");
                     * cellType1.textAlign(GCTYPE.Spread.Sheets.CellTypes.CheckBoxTextAlign.bottom);
                     * cellType1.isThreeState(true);
                     * cellType1.boxSize(20);
                     * activeSheet.getCell(1, 1).cellType(cellType1);
                     */
                    textFalse(value?: string): any;
                    /**
                     * Gets or sets the text in the cell when the cell's value is indeterminate (neither <c>true</c> nor <c>false</c>).
                     * @param {string} value The text in the cell when the cell's value is indeterminate.
                     * @returns {string | GCTYPE.Spread.Sheets.CellTypes.CheckBox} If no value is set, returns the text in the cell when the cell's value is indeterminate. If a value is set, returns the check box cell type.
                     * @example
                     * //This example creates a check box cell.
                     * var cellType1 = new GCTYPE.Spread.Sheets.CellTypes.CheckBox();
                     * cellType1.caption("caption");
                     * cellType1.textTrue("true");
                     * cellType1.textFalse("false");
                     * cellType1.textIndeterminate("indeterminate");
                     * cellType1.textAlign(GCTYPE.Spread.Sheets.CellTypes.CheckBoxTextAlign.bottom);
                     * cellType1.isThreeState(true);
                     * cellType1.boxSize(20);
                     * activeSheet.getCell(1, 1).cellType(cellType1);
                     */
                    textIndeterminate(value?: string): any;
                    /**
                     * Gets or sets the text in the cell when the cell's value is <c>true</c>.
                     * @param {string} value The text when the cell's value is <c>true</c>.
                     * @returns {string | GCTYPE.Spread.Sheets.CellTypes.CheckBox} If no value is set, returns the text when the cell's value is <c>true</c>. If a value is set, returns the check box cell type.
                     * @example
                     * //This example creates a check box cell.
                     * var cellType1 = new GCTYPE.Spread.Sheets.CellTypes.CheckBox();
                     * cellType1.caption("caption");
                     * cellType1.textTrue("true");
                     * cellType1.textFalse("false");
                     * cellType1.textIndeterminate("indeterminate");
                     * cellType1.textAlign(GCTYPE.Spread.Sheets.CellTypes.CheckBoxTextAlign.bottom);
                     * cellType1.isThreeState(true);
                     * cellType1.boxSize(20);
                     * activeSheet.getCell(1, 1).cellType(cellType1);
                     */
                    textTrue(value?: string): any;
                }

                export class CheckBoxList extends Base{
                    /**
                     * Represents an editable CheckBoxList cell.
                     * @extends GCTYPE.Spread.Sheets.CellTypes.Base
                     * @class
                     * @example
                     * //This example creates a CheckBoxList cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.CheckBoxList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    constructor();
                    /**
                     * Gets or sets the text of checkbox's size, only support number and "auto". If use illegal value, the size won't change.
                     * @param {number | string} value the size of checkbox. If the value is "auto", the size of radio button will change with the font size.
                     * @returns {number | string | GCTYPE.Spread.Sheets.CellTypes.CheckBoxList} If no value is set, return the size of checkbox. otherwise, returns the checkbox list cellType.
                     * // This example creates a checkbox list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.CheckBoxList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.textAlign(20);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    boxSize(value?: number|string): any;
                    /**
                     * Gets or sets the checkbox list's orders.
                     * @param {GCTYPE.Spread.Sheets.CellTypes.Direction} value Whether the order is vertical.
                     * @returns {GCTYPE.Spread.Sheets.CellTypes.Direction | GCTYPE.Spread.Sheets.CellTypes.CheckBoxList} If no value is set, returns whether the checkbox list's orders is vertical; otherwise, returns the checkbox list cellType.
                     * @example
                     * //This example creates a checkbox list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.CheckBoxList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.direction(GCTYPE.Spread.Sheets.CellTypes.Direction.vertical);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    direction(value?: GCTYPE.Spread.Sheets.CellTypes.Direction): any;
                    /**
                     * Gets or sets the checkbox list's layout is autofit.
                     * @param {boolean} value Whether the layout is autofit.
                     * @returns {boolean | GCTYPE.Spread.Sheets.CellTypes.CheckBoxList} If no value is set, returns whether the layout is autofit, returns the checkbox list cellType.
                     * @example
                     * //This example creates a checkbox list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.CheckBoxList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.isFlowLayout(true);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    isFlowLayout(value?: boolean): any;
                    /**
                     * Gets or sets the items for the checkbox list.
                     * @param {Array} items The items for the checkbox list.
                     * @returns {Array | GCTYPE.Spread.Sheets.CellTypes.CheckBoxList} If no value is set, returns the items array; otherwise, returns the checkbox list cellType.
                     * @example
                     * //This example creates a checkbox list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.CheckBoxList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    items(items?: GCTYPE.Spread.Sheets.CellTypes.ICelltypeItemOption[] | string[]): any;
                    /**
                     * Gets or sets the space for two items in the checkbox list.
                     * @param {object} value the space for two items in the checkbox list.
                     * @returns {object | GCTYPE.Spread.Sheets.CellTypes.CheckBoxList} If no value is set, returns the space for two items in the checkbox list; otherwise, returns the checkbox list cellType.
                     * @example
                     * //This example creates a checkbox list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.CheckBoxList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.itemSpacing({
                     *      horizontal:80,
                     *      vertical:20
                     * });
                     */
                    itemSpacing(value?: GCTYPE.Spread.Sheets.CellTypes.IItemSpacing): any;
                    /**
                     * Gets or sets the items for the checkbox list's column count.
                     * @param {number} value The column count for the checkbox list.
                     * @returns {number | GCTYPE.Spread.Sheets.CellTypes.CheckBoxList} If no value is set, returns the column count; otherwise, returns the checkbox list cellType.
                     * @example
                     * //This example creates a checkbox list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.CheckBoxList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.maxColumnCount(2);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    maxColumnCount(value?: number): any;
                    /**
                     * Gets or sets the items for the checkbox list's row count.
                     * @param {number} value The row count for the checkbox list.
                     * @returns {number | GCTYPE.Spread.Sheets.CellTypes.CheckBoxList} If no value is set, returns the row count; otherwise, returns the checkbox list cellType.
                     * @example
                     * //This example creates checkbox list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.CheckBoxList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.maxRowCount(2);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    maxRowCount(value?: number): any;
                    /**
                     * Gets or sets the text of checkbox's position, only support left and right .
                     * @param {GCTYPE.Spread.Sheets.CellTypes.TextAlign} value the text of checkbox's position.
                     * @returns {GCTYPE.Spread.Sheets.CellTypes.TextAlign | GCTYPE.Spread.Sheets.CellTypes.CheckBoxList} If no value is set, returns the text of checkbox's position, returns the checkbox list cellType.
                     * @example
                     * //This example creates a checkbox list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.CheckBoxList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.textAlign(GCTYPE.Spread.Sheets.CellTypes.TextAlign.left);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    textAlign(value?: GCTYPE.Spread.Sheets.CellTypes.TextAlign): any;
                }

                export class ColumnHeader extends Base{
                    /**
                     * Represents the painter of the column header cells.
                     * @extends GCTYPE.Spread.Sheets.CellTypes.Base
                     * @class
                     */
                    constructor();
                }

                export class ComboBox extends Base{
                    /**
                     * Represents an editable combo box cell.
                     * @extends GCTYPE.Spread.Sheets.CellTypes.Base
                     * @class
                     * @example
                     * //This example creates a combo box cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.ComboBox();
                     * cellType2.items(["a","b","c"]);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    constructor();
                    /**
                     * Gets or sets whether the combo box is editable.
                     * @param {boolean} value Whether the combo box is editable.
                     * @returns {boolean | GCTYPE.Spread.Sheets.CellTypes.ComboBox} If no value is set, returns whether the combo box is editable; otherwise, returns the combo box cellType.
                     * @example
                     * //This example sets the editable method.
                     * var items2 = ["a", "ab", "abc", "apple", "boy", "cat", "dog"];
                     * var eComboBoxCellType = new GCTYPE.Spread.Sheets.CellTypes.ComboBox().items(items2).editable(true);
                     * activeSheet.getCell(1, 3).cellType(eComboBoxCellType);
                     * activeSheet.setColumnWidth(0,120);
                     * activeSheet.setColumnWidth(2,120);
                     */
                    editable(value?: boolean): any;
                    /**
                     * Gets or sets the value that is written to the underlying data model.
                     * @param {GCTYPE.Spread.Sheets.CellTypes.EditorValueType} value The type of editor value.
                     * @returns {GCTYPE.Spread.Sheets.CellTypes.EditorValueType | GCTYPE.Spread.Sheets.CellTypes.ComboBox} If no value is set, returns the type of editor value; otherwise, returns the combo box cellType.
                     * @example
                     * //This example gets the type.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.ComboBox();
                     * cellType2.items(["a","b","c"]);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     * alert(cellType2.editorValueType());
                     */
                    editorValueType(value?: GCTYPE.Spread.Sheets.CellTypes.EditorValueType): any;
                    /**
                     * Gets or sets the height of each item.
                     * @param {number} value The height of each item.
                     * @returns {number | GCTYPE.Spread.Sheets.CellTypes.ComboBox} If no value is set, returns the height of each item; otherwise, returns the  combo box cellType.
                     * @example
                     * //This example sets the item height.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.ComboBox();
                     * cellType2.items(["a","b","c"]);
                     * cellType2.itemHeight(30);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    itemHeight(value?: number): any;
                    /**
                     * Gets or sets the items for the drop-down list in the combo box.
                     * @param {Array} items The items for the combo box.
                     * @returns {Array | GCTYPE.Spread.Sheets.CellTypes.ComboBox} If no value is set, returns the items array; otherwise, returns the  combo box cellType.
                     * @example
                     * //This example creates a combo box cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.ComboBox();
                     * cellType2.items(["a","b","c"]);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    items(items?: any[]): any;
                    /**
                     * Gets or sets the maximum item count of the drop-down list per page.
                     * @param {number} value The maximum item count of the drop-down list per page.
                     * @returns {number | GCTYPE.Spread.Sheets.CellTypes.ComboBox} If no value is set, returns the maximum item count of the drop-down list per page; otherwise, returns the  combo box cellType.
                     * @example
                     * //This example shows three items in the list at a time.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.ComboBox();
                     * cellType2.items(["a", "b", "c", "d", "e", "f", "g", "h"]);
                     * cellType2.maxDropDownItems(3);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     * });
                     */
                    maxDropDownItems(value?: number): any;
                }

                export class Corner extends Base{
                    /**
                     * Represents the painter of the corner cell.
                     * @extends GCTYPE.Spread.Sheets.CellTypes.Base
                     * @class
                     */
                    constructor();
                }

                export class HyperLink extends Base{
                    /**
                     * Represents the hyperlink cell.
                     * @extends GCTYPE.Spread.Sheets.CellTypes.Base
                     * @class
                     * @example
                     * var cellType = new GCTYPE.Spread.Sheets.CellTypes.HyperLink();
                     * cellType.linkColor("blue");
                     * cellType.visitedLinkColor("#FF2235");
                     * cellType.text("GrapeCity");
                     * cellType.linkToolTip("Company Web Site");
                     * activeSheet.getCell(1, 1).cellType(cellType).value("http://www.grapecity.com/");
                     * activeSheet.getCell(1, -1).height(30);
                     * @example
                     * var cellType = new GCTYPE.Spread.Sheets.CellTypes.HyperLink();
                     * cellType.linkColor("blue");
                     * cellType.visitedLinkColor("#FF2235");
                     * cellType.text("GrapeCity");
                     * cellType.linkToolTip("Company Web Site");
                     * activeSheet.getCell(0, 2).cellType(cellType).value("formula.html");
                     */
                    constructor();
                    /**
                     *  Gets or sets whether to move to the active cell when clicked.
                     * @param {boolean} value Whether to move to the active cell when clicked.
                     * @returns {boolean | GCTYPE.Spread.Sheets.CellTypes.HyperLink} If no value is set, returns a value that indicates whether to move to the active cell; otherwise, returns the hyperlink cell type.
                     * @example
                     * //This example uses the activeOnClick method.
                     * var h1 = new GCTYPE.Spread.Sheets.CellTypes.HyperLink();
                     * h1.text("GrapeCity");
                     * h1.linkToolTip("link to GrapeCity Web page");
                     * h1.linkColor("rgb(0, 100, 200)");
                     * h1.visitedLinkColor("rgb(0, 200, 100)");
                     * h1.activeOnClick(true);
                     * activeSheet.setCellType(1, 1, h1);
                     * activeSheet.getCell(1, 1, GCTYPE.Spread.Sheets.SheetArea.viewport).value("http://www.grapecity.com/").hAlign(GCTYPE.Spread.Sheets.HorizontalAlign.center);
                     */
                    activeOnClick(value?: boolean): any;
                    /**
                     * Gets or sets the color of the hyperlink.
                     * @param {string} value The hyperlink color.
                     * @returns {string | GCTYPE.Spread.Sheets.CellTypes.HyperLink} If no value is set, returns the hyperlink color; otherwise, returns the hyperLink cell type.
                     * @example
                     * //This example creates a hyperlink cell.
                     * cellType = new GCTYPE.Spread.Sheets.CellTypes.HyperLink();
                     * cellType.linkColor("blue");
                     * cellType.visitedLinkColor("#FF2235");
                     * cellType.text("GrapeCity");
                     * cellType.linkToolTip("Company Web Site");
                     * activeSheet.getCell(1, 1).cellType(cellType).value("http://www.grapecity.com/");
                     * activeSheet.getCell(1, -1).height(30);
                     */
                    linkColor(value?: string): any;
                    /**
                     * Gets or sets the tooltip for the hyperlink.
                     * @param {string} value The tooltip text.
                     * @returns {string | GCTYPE.Spread.Sheets.CellTypes.HyperLink} If no value is set, returns the tooltip text; otherwise, returns the hyperLink cell type.
                     * @example
                     * //This example creates a hyperlink cell.
                     * cellType = new GCTYPE.Spread.Sheets.CellTypes.HyperLink();
                     * cellType.linkColor("blue");
                     * cellType.visitedLinkColor("#FF2235");
                     * cellType.text("GrapeCity");
                     * cellType.linkToolTip("Company Web Site");
                     * activeSheet.getCell(1, 1).cellType(cellType).value("http://www.grapecity.com/");
                     * activeSheet.getCell(1, -1).height(30);
                     */
                    linkToolTip(value?: string): any;
                    /**
                     *  Gets or sets the callback of the hyperlink, If execute the function will represent the context for the callback.
                     * @param {Function} value The callback of the hyperlink.
                     * @returns {Function | GCTYPE.Spread.Sheets.CellTypes.HyperLink} If no value is set, return a value that indicates the callback of the hyperlink; otherwise, returns the hyperlink cell type.
                     * @example
                     * //This example sets the tab color when selecting the hyperlink.
                     * var h2 = new GCTYPE.Spread.Sheets.CellTypes.HyperLink();
                     * h2.text("set sheet tab style");
                     * h2.linkToolTip("set sheet tab style");
                     * h2.linkColor("blue");
                     * h2.visitedLinkColor("#FF2235");
                     * activeSheet.getCell(2, 1).cellType(h2).value("set sheet tab style").hAlign(GCTYPE.Spread.Sheets.HorizontalAlign.center);
                     * h2.activeOnClick(true);
                     *             h2.onClickAction(function () {
                     *                 var setSheetTabColor = {
                     *                     canUndo: true,
                     *                     execute: function (context, options, isUndo) {
                     *                         activeSheet.name("Hyperlink");
                     *                         activeSheet.options.sheetTabColor = "red";
                     *                     }
                     *                 };
                     *                 var commandManager = spread.commandManager();
                     *                 var commandName = "setSheetTabStyle";
                     *                 commandManager.register(commandName, setSheetTabColor, null, false, false, false, false);
                     *                 commandManager.execute({cmd: commandName})
                     *             });
                     */
                    onClickAction(value?: Function): any;
                    /**
                     *  Gets or sets the type for the hyperlink's target.
                     * @param {GCTYPE.Spread.Sheets.CellTypes.HyperLinkTargetType} value The hyperlink's target type.
                     * @returns {GCTYPE.Spread.Sheets.CellTypes.HyperLinkTargetType | GCTYPE.Spread.Sheets.CellTypes.HyperLink} If no value is set, returns the hyperlink's target type; otherwise, returns the hyperLink cell type.
                     * @example
                     * //This example creates a hyperlink cell.
                     * var cellType = new GCTYPE.Spread.Sheets.CellTypes.HyperLink();
                     * cellType.linkColor("blue");
                     * cellType.visitedLinkColor("#FFFF00");
                     * cellType.text("GrapeCity");
                     * cellType.linkToolTip("Company Web Site");
                     * cellType.target(GCTYPE.Spread.Sheets.CellTypes.HyperLinkTargetType.self);
                     * activeSheet.getCell(0, 2).cellType(cellType).value("http://www.grapecity.com/");
                     */
                    target(value?: GCTYPE.Spread.Sheets.CellTypes.HyperLinkTargetType): any;
                    /**
                     * Gets or sets the text string for the hyperlink.
                     * @param {string} value The text displayed in the hyperlink.
                     * @returns {string | GCTYPE.Spread.Sheets.CellTypes.HyperLink} If no value is set, returns the text in the hyperlink; otherwise, returns the hyperLink cell type.
                     * @example
                     * //This example creates a hyperlink cell.
                     * var cellType = new GCTYPE.Spread.Sheets.CellTypes.HyperLink();
                     * cellType.linkColor("blue");
                     * cellType.visitedLinkColor("#FFFF00");
                     * cellType.text("GrapeCity");
                     * cellType.linkToolTip("Company Web Site");
                     * cellType.target(GCTYPE.Spread.Sheets.CellTypes.HyperLinkTargetType.self);
                     * activeSheet.getCell(0, 2).cellType(cellType).value("http://www.grapecity.com/");
                     */
                    text(value?: string): any;
                    /**
                     * Gets or sets the color of visited links.
                     * @param {string} value The visited link color.
                     * @returns {string | GCTYPE.Spread.Sheets.CellTypes.HyperLink} If no value is set, returns the visited link color; otherwise, returns the hyperLink cell type.
                     * @example
                     * //This example creates a hyperlink cell.
                     * var cellType = new GCTYPE.Spread.Sheets.CellTypes.HyperLink();
                     * cellType.linkColor("blue");
                     * cellType.visitedLinkColor("#FFFF00");
                     * cellType.text("GrapeCity");
                     * cellType.linkToolTip("Company Web Site");
                     * cellType.target(GCTYPE.Spread.Sheets.CellTypes.HyperLinkTargetType.self);
                     * activeSheet.getCell(0, 2).cellType(cellType).value("http://www.grapecity.com/");
                     */
                    visitedLinkColor(value?: string): any;
                }

                export class RadioButtonList extends Base{
                    /**
                     * Represents an editable radio button list cell.
                     * @extends GCTYPE.Spread.Sheets.CellTypes.Base
                     * @class
                     * @example
                     * //This example creates a radio button list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.RadioButtonList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    constructor();
                    /**
                     * Gets or sets the size of radio button, only support number and "auto".
                     * @param {number | string} value the size of radio button. If the value is "auto", the size of radio button will change with the font size.
                     * @returns {number | string | GCTYPE.Spread.Sheets.CellTypes.RadioButtonList} If no value is set, return the size of radio button. otherwise, return the radio list cellType.
                     * @example
                     * // This example create a radio button list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.RadioButtonList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.boxSize(20);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    boxSize(value?: number | string): any;
                    /**
                     * Gets or sets the radio button list's orders.
                     * @param {GCTYPE.Spread.Sheets.CellTypes.Direction} value the order is vertical.
                     * @returns {GCTYPE.Spread.Sheets.CellTypes.Direction | GCTYPE.Spread.Sheets.CellTypes.RadioButtonList} If no value is set, returns whether the radio button list's orders is vertical; otherwise, returns the radio button list cellType.
                     * @example
                     * //This example creates a radio button list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.RadioButtonList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.direction(GCTYPE.Spread.Sheets.CellTypes.Direction.vertical);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    direction(value?: GCTYPE.Spread.Sheets.CellTypes.Direction): any;
                    /**
                     * Gets or sets the radio button list's layout is autofit.
                     * @param {boolean} value Whether the layout is autofit.
                     * @returns {boolean | GCTYPE.Spread.Sheets.CellTypes.RadioButtonList} If no value is set, returns whether the layout is autofit, returns the radio button list cellType.
                     * @example
                     * //This example creates a radio button list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.RadioButtonList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.isFlowLayout(true);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    isFlowLayout(value?: boolean): any;
                    /**
                     * Gets or sets the items for the radio-button list.
                     * @param {Array} items The items for the radio button list.
                     * @returns {Array | GCTYPE.Spread.Sheets.CellTypes.RadioButtonList} If no value is set, returns the items array; otherwise, returns the radio button list cellType.
                     * @example
                     * //This example creates a radio button list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.RadioButtonList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    items(items?: GCTYPE.Spread.Sheets.CellTypes.ICelltypeItemOption[] | string[]): any;
                    /**
                     * Gets or sets the space for two items in the radio button list.
                     * @param {object} value the space for two items in the radio button list.
                     * @returns {object | GCTYPE.Spread.Sheets.CellTypes.RadioButtonList} If no value is set, returns the space for two items in the radio button list; otherwise, returns the radio button list cellType.
                     * @example
                     * //This example creates a radio button list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.RadioButtonList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.itemSpacing({
                     *      horizontal:80,
                     *      vertical:20
                     * });
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    itemSpacing(value?: GCTYPE.Spread.Sheets.CellTypes.IItemSpacing): any;
                    /**
                     * Gets or sets the items for the radio button list's column count.
                     * @param {number} value The column count for the radio button list.
                     * @returns {number | GCTYPE.Spread.Sheets.CellTypes.RadioButtonList} If no value is set, returns the column count; otherwise, returns the radio button list cellType.
                     * @example
                     * //This example creates a radio button list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.RadioButtonList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.maxColumnCount(2);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    maxColumnCount(value?: number): any;
                    /**
                     * Gets or sets the items for the radio button list's row count.
                     * @param {number} value The row count for the radio button list.
                     * @returns {number | GCTYPE.Spread.Sheets.CellTypes.RadioButtonList} If no value is set, returns the row count; otherwise, returns the radio button list cellType.
                     * @example
                     * //This example creates radio button list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.RadioButtonList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.maxRowCount(2);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    maxRowCount(value?: number): any;
                    /**
                     * Gets or sets the text of radio button's position, only support left and right .
                     * @param {GCTYPE.Spread.Sheets.CellTypes.TextAlign} value the text of radio button's position.
                     * @returns {GCTYPE.Spread.Sheets.CellTypes.TextAlign | GCTYPE.Spread.Sheets.CellTypes.RadioButtonList} If no value is set, returns the text of radio button's position, returns the radio button list cellType.
                     * @example
                     * //This example creates a radio button list cell.
                     * var cellType2 = new GCTYPE.Spread.Sheets.CellTypes.RadioButtonList();
                     * cellType2.items([{text:"a",value:1},{text:"b",value:2},{text:"c",value:3}]);
                     * cellType2.textAlign(GCTYPE.Spread.Sheets.CellTypes.TextAlign.left);
                     * activeSheet.getCell(2, 2).cellType(cellType2);
                     */
                    textAlign(value?: GCTYPE.Spread.Sheets.CellTypes.TextAlign): any;
                }

                export class RangeTemplate extends GCTYPE.Spread.Sheets.CellTypes.Base{
                    /**
                     * @description RangeTemplate provide a template from a range of referenced worksheet,it can apply to a cell.It will render the cell same as the tempalte and fill data different.If the param row,col, rowCount, colCount not set , it will use the whole sheet as the range scope.
                     * @extends GCTYPE.Spread.Sheets.CellTypes.Base
                     * @param {GCTYPE.Spread.Sheets.Worksheet} sheet  the referenced worksheet, the sheet could be an individual sheet outside the workbook.
                     * @param {number} [row] the template scope start row.
                     * @param {number} [col] the template scope start col.
                     * @param {number} [rowCount] the template scope row count.
                     * @param {number} [colCount] the template scope col count.
                     * @class
                     * @example
                     * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"), { sheetCount: 2 });
                     * var sheet = spread.getActiveSheet();
                     * var sheet2 = spread.getSheetFromName("Sheet2");
                     * var celltype = new GCTYPE.Spread.Sheets.CellTypes.RangeTemplate(sheet2, 0, 0, 6, 4);
                     * sheet.getRange(0,0,2,2).cellType(celltype);
                     */
                    constructor(sheet: GCTYPE.Spread.Sheets.Worksheet,  row?: number,  col?: number,  rowCount?: number,  colCount?: number);
                }

                export class RowHeader extends Base{
                    /**
                     * Represents the painter of the row header cells.
                     * @extends GCTYPE.Spread.Sheets.CellTypes.Base
                     * @class
                     */
                    constructor();
                }

                export class Text extends Base{
                    /**
                     * Represents a text cell type.
                     * @extends GCTYPE.Spread.Sheets.CellTypes.Base
                     * @class
                     * @param {GCTYPE.Spread.Sheets.CellTypes.EditorType} editorType The editor type of the text cell type.
                     */
                    constructor();
                }
            }

            module Charts{

                export interface ErrorBarItem{
                    type?: number;
                    valueType?: number;
                    noEndCap?: boolean;
                    value?: number;
                    custom?: {
                    positive: string;
                    negative: string;
                    };
                    style?: {
                    color?: string;
                    width?: number;
                    transparency?: number;
                    dashStyle?: GCTYPE.Spread.Sheets.Charts.ILineStyle;
                    visible?: boolean;
                    }
                }


                export interface ErrorBarItems{
                    vertical?: GCTYPE.Spread.Sheets.Charts.ErrorBarItem;
                    horizontal?: GCTYPE.Spread.Sheets.Charts.ErrorBarItem;
                }


                export interface IAxes{
                    primaryCategory?: IAxis;
                    primaryValue?: IAxis;
                    secondaryCategory?: IAxis;
                    secondaryValue?: IAxis;
                }


                export interface IAxis{
                    visible?: boolean;
                    tickLabelPosition?: GCTYPE.Spread.Sheets.Charts.TickLabelPosition;
                    lineStyle?: GCTYPE.Spread.Sheets.Charts.IBorder;
                    style?: GCTYPE.Spread.Sheets.Charts.IAxisStyle;
                    majorTickPosition?: GCTYPE.Spread.Sheets.Charts.TickMark;
                    minorTickPosition?: GCTYPE.Spread.Sheets.Charts.TickMark;
                    majorUnit?: number;
                    minorUnit?: number;
                    min?: number | Date;
                    max?: number | Date;
                    format?: string;
                    title?: GCTYPE.Spread.Sheets.Charts.IAxisTitle;
                    majorGridLine?: GCTYPE.Spread.Sheets.Charts.IGridLine;
                    minorGridLine?: GCTYPE.Spread.Sheets.Charts.IGridLine;
                    labelAngle?: number;
                    scaling?: GCTYPE.Spread.Sheets.Charts.IScaling;
                    displayUnit?: GCTYPE.Spread.Sheets.Charts.IDisplayUnit;
                    crossPoint?: number | GCTYPE.Spread.Sheets.Charts.AxisCrossPoint
                }


                export interface IAxisStyle{
                    color?: string;
                    transparency?: number;
                    fontFamily?: string;
                    fontSize?: number;
                }


                export interface IAxisTitle{
                    text?: string;
                    color?: string;
                    transparency?: number;
                    fontFamily?: string;
                    fontSize?: number;
                }


                export interface IBorder{
                    color?: string;
                    width?: number;
                    transparency?: number;
                    dashStyle?: GCTYPE.Spread.Sheets.Charts.LineType;
                }


                export interface IChartArea{
                    backColor?: string | GCTYPE.Spread.Sheets.Charts.IPatternFillBackColor;
                    backColorTransparency?: number;
                    fontFamily?: string;
                    fontSize?: number;
                    color?: string;
                    transparency?: number;
                    border?: GCTYPE.Spread.Sheets.Charts.IBorder;
                }


                export interface IChartLegend{
                    position?: GCTYPE.Spread.Sheets.Charts.LegendPosition;
                    visible?: boolean;
                    backColor?: string | GCTYPE.Spread.Sheets.Charts.IPatternFillBackColor;
                    backColorTransparency?: number;
                    borderStyle?: GCTYPE.Spread.Sheets.Charts.IBorder;
                    color?: string;
                    fontFamily?: string;
                    fontSize?: number;
                }


                export interface IChartTextStyle{
                    color?: string;
                    fontFamily?: string;
                    fontSize?: number | string;
                    transparency?: number;
                }


                export interface IChartTitle{
                    text?: string;
                    fontFamily?: string;
                    fontSize?: number;
                    color?: string;
                    transparency?:number;
                    backColor?: string | GCTYPE.Spread.Sheets.Charts.IPatternFillBackColor;
                    backColorTransparency?: number;
                }


                export interface IDataLabels{
                    showCategoryName?: boolean;
                    showSeriesName?: boolean;
                    showValue?: boolean;
                    showPercentage?: boolean;
                    position?: GCTYPE.Spread.Sheets.Charts.DataLabelPosition;
                    format?: string;
                    color?: string;
                    transparency?: number;
                    separator?: string;
                    backColor?: string | GCTYPE.Spread.Sheets.Charts.IPatternFillBackColor;
                    backColorTransparency?: number;
                    borderColor?: string;
                    borderWidth?: number;
                    borderColorTransparency?: number;
                }


                export interface IDataPointPart{
                    fillColor?: string;
                    idx?: number;
                    transparency?: number;
                }


                export interface IDisplayUnit{
                    unit?: number | GCTYPE.Spread.Sheets.Charts.DisplayUnit;
                    visible?: boolean;
                    style?: IChartTextStyle;
                }


                export interface IGridLine{
                    color?: string;
                    transparency?: number;
                    visible?: boolean;
                    width?: number;
                }


                export interface IHoverStyle{
                    color?:string;
                    transparency?:number;
                    borderStyle?: GCTYPE.Spread.Sheets.Charts.IBorder;
                    symbolStyle?: GCTYPE.Spread.Sheets.Charts.IHoverSymbolStyle;
                }


                export interface IHoverSymbolStyle{
                    color?:string;
                    transparency?:number;
                    borderStyle?: GCTYPE.Spread.Sheets.Charts.IBorder;
                }


                export interface ILineStyle{
                    color?: string;
                    width?: number;
                    transparency?: number;
                    dashStyle?: GCTYPE.Spread.Sheets.Charts.LineType;
                }


                export interface IPaintCallBack{
                    (chart: GCTYPE.Spread.Sheets.Charts.Chart, chartHost: HTMLElement) : void;
                }


                export interface IPatternFillBackColor{
                    type: GCTYPE.Spread.Sheets.Charts.PatternType;
                    foregroundColor?: string;
                    backgroundColor?: string;
                }


                export interface IScaling{
                    orientation?: number | GCTYPE.Spread.Sheets.Charts.AxisOrientation;
                    logBase?: number;
                }


                export interface ISeries{
                    chartType?: GCTYPE.Spread.Sheets.Charts.ChartType;
                    axisGroup?: GCTYPE.Spread.Sheets.Charts.AxisGroup;
                    backColor?: string | GCTYPE.Spread.Sheets.Charts.IPatternFillBackColor;
                    backColorTransparency?: number;
                    border?: GCTYPE.Spread.Sheets.Charts.ISeriesItemBorder;
                    startAngle?: number;
                    name?: string;
                    xValues?: string;
                    yValues?: string;
                    bubbleSizes?: string;
                    datalabels?: any;
                    symbol?: GCTYPE.Spread.Sheets.Charts.ISymbol;
                    errorBars?: GCTYPE.Spread.Sheets.Charts.ErrorBarItems;
                    trendlines?: GCTYPE.Spread.Sheets.Charts.TrendlineItem[];
                    plotVisibleOnly?: boolean;
                }


                export interface ISeriesItemBorder{
                    color?: string;
                    colorTransparency?: number;
                    transparency?: number;
                    width?: number;
                    lineType?: GCTYPE.Spread.Sheets.Charts.LineType;
                }


                export interface ISeriesSymbolBorder{
                    color?: string;
                    colorTransparency?: number;
                    transparency?: number;
                    width?: number;
                    lineType?: number;
                }


                export interface ISymbol{
                    fill: string;
                    fillColorTransparency: number;
                    size: number;
                    shape: GCTYPE.Spread.Sheets.Charts.SymbolShape;
                    border: GCTYPE.Spread.Sheets.Charts.ISeriesSymbolBorder;
                }


                export interface ITrendline{
                    type?: GCTYPE.Spread.Sheets.Charts.TrendlineType;
                    order?: number;
                    period?: number;
                    intercept?: number;
                    forward?: number;
                    backward?: number;
                    displayEquation?: boolean;
                    displayRSquared?: boolean;
                    fontFamily?: string;
                    fontSize?: number;
                    fontColor?: string;
                    name?: string;
                    style?: GCTYPE.Spread.Sheets.Charts.ILineStyle;
                }


                export interface TrendlineItem{
                    type?: GCTYPE.Spread.Sheets.Charts.TrendlineType;
                    display?: string;
                    order?: number;
                    period?: number;
                    label?: string;
                    style?: GCTYPE.Spread.Sheets.Charts.ILineStyle;
                    intercept?: number;
                    forward?: number;
                    backward?: number;
                    displayEquation?: boolean;
                    displayRSquared?: boolean;
                    name?: string;
                    fontFamily?: string;
                    fontSize?: number;
                    fontColor?: string;
                }

                /**
                 * Specifies  the point on the specified axis where the other axis crosses.
                 * @enum {string}
                 */
                export enum AxisCrossPoint{
                    /**
                     * The axis crosses at the auto value.
                     */
                    automatic= "auto",
                    /**
                     * The axis crosses at the maximum value.
                     */
                    maximum= "max",
                    /**
                     * The axis crosses at the minimum value.
                     */
                    minimum= "min"
                }

                /**
                 * Specifies the type of axis group.
                 * @enum {number}
                 */
                export enum AxisGroup{
                    /**
                     * Primary axis group.
                     */
                    primary= 0,
                    /**
                     * Secondary axis group.
                     */
                    secondary= 1
                }

                /**
                 * Specifies  the specified axis orientation
                 * @enum {number}
                 */
                export enum AxisOrientation{
                    /**
                     * The axis order is from min to max.
                     */
                    minMax= 0,
                    /**
                     * The axis order is from max to min.
                     */
                    maxMin= 1
                }

                /**
                 * Specifies the chart type.
                 * @enum {number}
                 */
                export enum ChartType{
                    /**
                     * Combo
                     */
                    combo= 0,
                    /**
                     * Scatter
                     */
                    xyScatter= 1,
                    /**
                     * Radar
                     */
                    radar= 2,
                    /**
                     * Doughnut
                     */
                    doughnut= 3,
                    /**
                     * Area
                     */
                    area= 8,
                    /**
                     * Line
                     */
                    line= 9,
                    /**
                     * Pie
                     */
                    pie= 10,
                    /**
                     * Bubble
                     */
                    bubble= 11,
                    /**
                     * Clustered Column
                     */
                    columnClustered= 12,
                    /**
                     * Stacked Column
                     */
                    columnStacked= 13,
                    /**
                     * 100% Stacked Column
                     */
                    columnStacked100= 14,
                    /**
                     * Clustered Bar
                     */
                    barClustered= 18,
                    /**
                     * Stacked Bar
                     */
                    barStacked= 19,
                    /**
                     * 100% Stacked Bar
                     */
                    barStacked100= 20,
                    /**
                     * Stacked Line
                     */
                    lineStacked= 24,
                    /**
                     * 100% Stacked Line
                     */
                    lineStacked100= 25,
                    /**
                     * Line with Markers
                     */
                    lineMarkers= 26,
                    /**
                     * Stacked Line with Markers
                     */
                    lineMarkersStacked= 27,
                    /**
                     * 100% Stacked Line with Markers
                     */
                    lineMarkersStacked100= 28,
                    /**
                     * Scatter with Smoothed Lines
                     */
                    xyScatterSmooth= 33,
                    /**
                     * Scatter with Smoothed Lines and No Data Markers
                     */
                    xyScatterSmoothNoMarkers= 34,
                    /**
                     * Scatter with Lines.
                     */
                    xyScatterLines= 35,
                    /**
                     * Scatter with Lines and No Data Markers
                     */
                    xyScatterLinesNoMarkers= 36,
                    /**
                     * Stacked Area
                     */
                    areaStacked= 37,
                    /**
                     * 100% Stacked Area
                     */
                    areaStacked100= 38,
                    /**
                     * Radar with data makers
                     */
                    radarMarkers= 42,
                    /**
                     * Filled Radar
                     */
                    radarFilled= 43,
                    /**
                     * High-Low-Close
                     */
                    stockHLC= 49,
                    /**
                     * Open-High-Low-Close
                     */
                    stockOHLC= 50,
                    /**
                     * Volume-High-Low-Close
                     */
                    stockVHLC= 51,
                    /**
                     * Volume-Open-High-Low-Close
                     */
                    stockVOHLC= 52,
                    /**
                     * Box & Whisker
                     */
                    boxWhisker= 53,
                    /**
                     * Funnel
                     */
                    funnel= 54,
                    /**
                     * Pareto
                     */
                    paretoLine= 55,
                    /**
                     * map
                     */
                    regionMap= 56,
                    /**
                     * sunburst
                     */
                    sunburst= 57,
                    /**
                     * tree map
                     */
                    treemap= 58,
                    /**
                     * Waterfull
                     */
                    waterfall= 59,
                    /**
                     *  Histogram
                     */
                    clusteredColumn= 60
                }

                /**
                 * Specifies where the data label is positioned.
                 * @enum {number}
                 */
                export enum DataLabelPosition{
                    /**
                     * Adjust data label position automatically.
                     */
                    bestFit= 0,
                    /**
                     * Data label below point.
                     */
                    below= 1,
                    /**
                     * Data label centered on data point or inside bar or pie.
                     */
                    center= 2,
                    /**
                     * Data label positioned arbitrarily.
                     */
                    insideBase= 3,
                    /**
                     * Data label positioned arbitrarily.
                     */
                    insideEnd= 4,
                    /**
                     * Data label positioned at bottom of bar or pie.
                     */
                    left= 5,
                    /**
                     * Data label positioned at top of bar or pie.
                     */
                    outsideEnd= 6,
                    /**
                     * Data label positioned at top of bar or pie.
                     */
                    right= 7,
                    /**
                     * Data label above point.
                     */
                    above= 8
                }

                /**
                 * Specifies the way of the chart display blank data.
                 * @enum {number}
                 */
                export enum DisplayBlanksAs{
                    /**
                     * Specifies display empty cells as connected
                     */
                    connected= 0,
                    /**
                     * Specifies display empty cells as gaps
                     */
                    gaps= 1,
                    /**
                     * Specifies display empty cells as zero
                     */
                    zero= 2
                }

                /**
                 * Specifies the built-in type of axis display unit.
                 * @enum {number}
                 */
                export enum DisplayUnit{
                    /**
                     * The hundreds of built-in type.
                     */
                    hundreds= "hundreds",
                    /**
                     * The thousands of built-in type.
                     */
                    thousands= "thousands",
                    /**
                     * The ten thousands of built-in type.
                     */
                    tenThousands= "tenThousands",
                    /**
                     * The hundred thousands of built-in type.
                     */
                    hundredThousands= "hundredThousands",
                    /**
                     * The millions of built-in type.
                     */
                    millions= "millions",
                    /**
                     * The ten millions of built-in type.
                     */
                    tenMillions= "tenMillions",
                    /**
                     * The hundred millions of built-in type.
                     */
                    hundredMillions= "hundredMillions",
                    /**
                     * The billions of built-in type.
                     */
                    billions= "billions",
                    /**
                     * The trillions of built-in type.
                     */
                    trillions= "trillions"
                }

                /**
                 * Specifies the type of error bar in series
                 * @enum {number}
                 */
                export enum ErrorBarType{
                    /**
                     * Specifies each error bar has both minus and plus type at each data point.
                     */
                    both= 0,
                    /**
                     * Specifies each error bar has minus type at each data point.
                     */
                    minus= 1,
                    /**
                     * Specifies each error bar has plus type at each data point.
                     */
                    plus= 2
                }

                /**
                 * Specifies the value type of error bar in series
                 * @enum {number}
                 */
                export enum ErrorBarValueType{
                    /**
                     * Specifies error bar has custom value type, each error bars has it own value, each values may be different.
                     */
                    custom= 0,
                    /**
                     * Specifies each error bar has fixed value type at each data point.
                     */
                    fixedValue= 1,
                    /**
                     * Specifies each error bar has percentage value type at each data point.
                     */
                    percentage= 2,
                    /**
                     * Specifies each error bar has calculated standard deviation value type at each data point.
                     */
                    standardDeviation= 3,
                    /**
                     * Specifies each error bar has calculated standard error value type at each data point.
                     */
                    standardError= 4
                }

                /**
                 * Specifies the position of the legend on a chart.
                 * @enum {number}
                 */
                export enum LegendPosition{
                    /**
                     * Above the chart.
                     */
                    top= 1,
                    /**
                     * To the right of the chart.
                     */
                    right= 2,
                    /**
                     * To the left of the chart.
                     */
                    left= 3,
                    /**
                     * Below the chart.
                     */
                    bottom= 4,
                    /**
                     * In the upper right-hand corner of the chart border.
                     */
                    topRight= 5
                }

                /**
                 * Specifies the type of line in series
                 * @enum {number}
                 */
                export enum LineType{
                    /**
                     * Specifies a solid line type
                     */
                    solid= 0,
                    /**
                     * Specifies a dot line type
                     */
                    dot= 1,
                    /**
                     * Specifies a dash line type
                     */
                    dash= 2,
                    /**
                     * Specifies a large dash line type
                     */
                    lgDash= 3,
                    /**
                     * Specifies a dash and a dot line type
                     */
                    dashDot= 4,
                    /**
                     * Specifies a large dash and a dot line type
                     */
                    lgDashDot= 5,
                    /**
                     * Specifies a large dash and a dot and a dot line type
                     */
                    lgDashDotDot= 6,
                    /**
                     * Specifies a small dash line type
                     */
                    sysDash= 7,
                    /**
                     * Specifies a small dot line type
                     */
                    sysDot= 8,
                    /**
                     * Specifies a small dash and a dot line type
                     */
                    sysDashDot= 9,
                    /**
                     * Specifies a small dash and a dot and a dot line type
                     */
                    sysDashDotDot= 10
                }

                /**
                 * Specifies the pattern type of chart element background color
                 * @enum {number}
                 */
                export enum PatternType{
                    /**
                     * not supported
                     */
                    none= 0,
                    /**
                     * 5% of the foreground color.
                     */
                    dottedPercent5= 1,
                    /**
                     * 10% of the foreground color.
                     */
                    dottedPercent10= 2,
                    /**
                     * 20% of the foreground color.
                     */
                    dottedPercent20= 3,
                    /**
                     * 25% of the foreground color.
                     */
                    dottedPercent25= 4,
                    /**
                     * 30% of the foreground color.
                     */
                    dottedPercent30= 5,
                    /**
                     * 40% of the foreground color.
                     */
                    dottedPercent40= 6,
                    /**
                     * 50% of the foreground color.
                     */
                    dottedPercent50= 7,
                    /**
                     * 60% of the foreground color.
                     */
                    dottedPercent60= 8,
                    /**
                     * 70% of the foreground color.
                     */
                    dottedPercent70= 9,
                    /**
                     * 75% of the foreground color.
                     */
                    dottedPercent75= 10,
                    /**
                     * 80% of the foreground color.
                     */
                    dottedPercent80= 11,
                    /**
                     * 90% of the foreground color.
                     */
                    dottedPercent90= 12,
                    /**
                     * Thick horizontal lines in the foreground color.
                     */
                    darkHorizontal= 13,
                    /**
                     * Thick vertical lines in the foreground color.
                     */
                    darkVertical= 14,
                    /**
                     * Thick lines in the foreground color running from the top to the right-hand side of the shape
                     */
                    darkDownwardDiagonal= 15,
                    /**
                     * Thick lines in the foreground color running from the top to the left-hand side of the shape.
                     */
                    darkUpwardDiagonal= 16,
                    /**
                     * Small squares in alternating foreground/background colors.
                     */
                    smallCheckerBoard= 17,
                    /**
                     * Trellis pattern in the foreground color.
                     */
                    trellis= 18,
                    /**
                     * Thin horizontal lines in the foreground color.
                     */
                    lightHorizontal= 19,
                    /**
                     * Thin vertical lines in the foreground color.
                     */
                    lightVertical= 20,
                    /**
                     * Thin lines in the foreground color running from the top to the right-hand side of the shape.
                     */
                    lightDownwardDiagonal= 21,
                    /**
                     * Thin lines in the foreground color running from the top to the left-hand side of the shape.
                     */
                    lightUpwardDiagonal= 22,
                    /**
                     * Solid, closely spaced perpendicular lines in the foreground color running horizontally and vertically to form grid lines across the shape.
                     */
                    smallGrid= 23,
                    /**
                     * Dotted perpendicular lines in the foreground color running diagonally to form diamonds across the shape.
                     */
                    dottedDiamond= 24,
                    /**
                     * Widely spaced lines in the foreground color running from the top to the right-hand side of the shape.
                     */
                    wideDownwardDiagonal= 25,
                    /**
                     * Widely spaced lines in the foreground color running from the top to the left-hand side of the shape.
                     */
                    wideUpwardDiagonal= 26,
                    /**
                     * Dashed lines in the foreground color running from the top to the left-hand side of the shape.
                     */
                    dashedUpwardDiagonal= 27,
                    /**
                     * Dashed lines in the foreground color running from the top to the right-hand side of the shape.
                     */
                    dashedDownwardDiagonal= 28,
                    /**
                     * Narrowly spaced vertical lines in the foreground color.
                     */
                    narrowVertical= 29,
                    /**
                     * Narrowly spaced horizontal lines in the foreground color.
                     */
                    narrowHorizontal= 30,
                    /**
                     * Dashed vertical lines in the foreground color.
                     */
                    dashedVertical= 31,
                    /**
                     * Dashed horizontal lines in the foreground color.
                     */
                    dashedHorizontal= 32,
                    /**
                     * Large dots in the foreground color scattered across the shape.
                     */
                    largeConfetti= 33,
                    /**
                     * Solid, widely spaced perpendicular lines in the foreground color running horizontally and vertically to form grid lines across the shape.
                     */
                    largeGrid= 34,
                    /**
                     * Rectangular brick pattern running horizontally across the shape.
                     */
                    horizontalBrick= 35,
                    /**
                     * Squares in alternating foreground/background colors.
                     */
                    largeCheckerBoard= 36,
                    /**
                     * Small dots in the foreground color scattered across the shape.
                     */
                    smallConfetti= 37,
                    /**
                     * Zigzag lines running horizontally across the shape.
                     */
                    zigZag= 38,
                    /**
                     * Diamond shapes in alternating foreground/background colors.
                     */
                    solidDiamond= 39,
                    /**
                     * Rectangular brick pattern running diagonally across the shape.
                     */
                    diagonalBrick= 40,
                    /**
                     * Solid perpendicular lines in the foreground color running diagonally to form diamonds across the shape.
                     */
                    outlinedDiamond= 41,
                    /**
                     * Very thick solid lines in the foreground color running vertically, coupled with very thick lines and 40% of the foreground color running horizontally.
                     */
                    plaid= 42,
                    /**
                     * Circles that use foreground and background colors to make them appear three-dimensional, oriented in rows across the shape.
                     */
                    sphere= 43,
                    /**
                     * Weave pattern in the foreground color running diagonally across the shape.
                     */
                    weave= 44,
                    /**
                     * Dotted perpendicular lines in the foreground color running horizontally and vertically to form grid lines across the shape.
                     */
                    dottedGrid= 45,
                    /**
                     * Small angled shapes in the foreground color running in alternating rows down the shape.
                     */
                    divot= 46,
                    /**
                     * Overlapping curved rectangles running diagonally across the shape.
                     */
                    shingle= 47,
                    /**
                     * Wavy lines in the foreground color.
                     */
                    wave= 48
                }

                /**
                 * Specifies whether the values corresponding to a particular data series are in rows or columns.
                 * @enum {number}
                 */
                export enum RowCol{
                    /**
                     * Data series is in a column.
                     */
                    rows= 0,
                    /**
                     * Data series is in a row.
                     */
                    columns= 1
                }

                /**
                 * Specifies the shape of symbol in series
                 * @enum {number}
                 */
                export enum SymbolShape{
                    /**
                     * Specifies a circle shall be drawn at each data point.
                     */
                    circle= 0,
                    /**
                     * Specifies a dash shall be drawn at each data point.
                     */
                    dash= 1,
                    /**
                     * Specifies a diamond shall be drawn at each data point.
                     */
                    diamond= 2,
                    /**
                     * Specifies a dot shall be drawn at each data point.
                     */
                    dot= 3,
                    /**
                     * Doesn't draw any symbol at each data point.
                     */
                    none= 4,
                    /**
                     * Specifies a picture shall be drawn at each data point.
                     */
                    picture= 5,
                    /**
                     * Specifies a plus shall be drawn at each data point.
                     */
                    plus= 6,
                    /**
                     * Specifies a square shall be drawn at each data point.
                     */
                    square= 7,
                    /**
                     * Specifies a star shall be drawn at each data point.
                     */
                    star= 8,
                    /**
                     * Specifies a triangle shall be drawn at each data point.
                     */
                    triangle= 9,
                    /**
                     * Specifies an X shall be drawn at each data point.
                     */
                    x= 10
                }

                /**
                 * Specifies the position of tick-mark labels on the specified axis.
                 * @enum {number}
                 */
                export enum TickLabelPosition{
                    /**
                     * Top or right side of the chart.
                     */
                    high= 0,
                    /**
                     * Bottom or left side of the chart.
                     */
                    low= 1,
                    /**
                     * Next to axis (where axis is not at either side of the chart).
                     */
                    nextToAxis= 2,
                    /**
                     * No tick marks.
                     */
                    none= 3
                }

                /**
                 * Specifies the position of major and minor tick marks for an axis.
                 * @enum {number}
                 */
                export enum TickMark{
                    /**
                     * Crosses the axis.
                     */
                    cross= 0,
                    /**
                     * Inside the axis.
                     */
                    inside= 1,
                    /**
                     * No mark.
                     */
                    none= 2,
                    /**
                     * Outside the axis.
                     */
                    outside= 3
                }

                /**
                 * Specifies how the trendline that smoothes out fluctuations in the data is calculated.
                 * @enum {number}
                 */
                export enum TrendlineType{
                    /**
                     * Uses an equation to calculate the least squares fit through points.
                     */
                    exponential= 0,
                    /**
                     * Uses the linear equation y = mx + b to calculate the least squares fit through points.
                     */
                    linear= 1,
                    /**
                     * Uses the equation y = c ln x + b to calculate the least squares fit through points.
                     */
                    logarithmic= 2,
                    /**
                     * Uses a sequence of averages computed from parts of the data series. The number
                     * of points equals the total number of points in the series less the number
                     * specified for the period.
                     */
                    movingAverage= 3,
                    /**
                     * Uses an equation to calculate the least squares fit through points.
                     */
                    polynomial= 4,
                    /**
                     * Uses an equation to calculate the least squares fit through points.
                     */
                    power= 5
                }


                export class Chart extends GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject{
                    /**
                     * Represents a chart.
                     * @extends GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject
                     * @class
                     * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The host sheet of the chart.
                     * @param {string} name The name of the chart.
                     * @param {GCTYPE.Spread.Sheets.Charts.ChartType} chartType The type of the chart.
                     * @param {number} x The <i>x</i> location of the chart.
                     * @param {number} y The <i>y</i> location of the chart.
                     * @param {number} width The width of the chart.
                     * @param {number} height The height of the chart.
                     * @param {string?} dataRange The formula string of data range for the chart.
                     * @param {GCTYPE.Spread.Sheets.Charts.RowCol?} dataOrientation The orientation of data for series.
                     */
                    constructor(sheet: GCTYPE.Spread.Sheets.Worksheet,  name: string,  chartType: GCTYPE.Spread.Sheets.Charts.ChartType,  x: number,  y: number,  width: number,  height: number,  dataRange?: string,  dataOrientation?: GCTYPE.Spread.Sheets.Charts.RowCol);
                    /**
                     * Gets or sets the chart axes of the chart.
                     * @param {Object} value The chart axes of the chart.
                     * @param {Object} value.primaryCategory The primary category axis of the chart.
                     * @param {Object} value.primaryValue The primary value axis of the chart.
                     * @param {Object} value.secondaryCategory The secondary category axis of the chart.
                     * @param {Object} value.secondaryValue The secondary value axis of the chart.
                     *
                     * The primaryCategory, primaryValue, secondaryCategory and secondaryValue have same type.
                     * @param {boolean} value.primaryCategory.visible Indicates if the specified axis should be shown.
                     * @param {GCTYPE.Spread.Sheets.Charts.TickLabelPosition} value.primaryCategory.tickLabelPosition The tick label position.
                     * @param {number | GCTYPE.Spread.Sheets.Charts.AxisCrossPoint} value.primaryCategory.crossPoint Indicates the axis crosses value.
                     * @param {Object} value.primaryCategory.lineStyle The line style of the primary category axis.
                     * @param {string} value.primaryCategory.lineStyle.color The line color of the primary category axis.
                     * @param {number} value.primaryCategory.lineStyle.transparency The transparency of the chart primary category axis line color.
                     * @param {number} value.primaryCategory.lineStyle.width The line width of the primary category axis.
                     * @param {Object} value.primaryCategory.style The style of the primary category axis.
                     * @param {string} value.primaryCategory.style.color The color of the primary category axis.
                     * @param {number} value.primaryCategory.style.transparency The transparency of the chart primary category axis color.
                     * @param {string} value.primaryCategory.style.fontFamily The font family of the primary category axis.
                     * @param {number} value.primaryCategory.style.fontSize The font size of the primary category axis, its unit is pixel.
                     * @param {GCTYPE.Spread.Sheets.Charts.TickMark} value.primaryCategory.majorTickPosition The major tick position of the primary category axis.
                     * @param {GCTYPE.Spread.Sheets.Charts.TickMark} value.primaryCategory.minorTickPosition The minor tick position of the primary category axis.
                     * @param {GCTYPE.Spread.Sheets.Charts.TimeUnit} value.primaryCategory.baseUnit The base unit scale of the date primary category axis.
                     * @param {number} value.primaryCategory.majorUnit The major unit of the primary category axis.
                     * @param {GCTYPE.Spread.Sheets.Charts.TimeUnit} value.primaryCategory.majorUnitScale The major unit scale of the date primary category axis.
                     * @param {number} value.primaryCategory.minorUnit The minor unit of the primary category axis.
                     * @param {GCTYPE.Spread.Sheets.Charts.TimeUnit} value.primaryCategory.minorUnitScale The minor unit scale of the date primary category axis.
                     * @param {number | Date} value.primaryCategory.min The minimum value of the related axis. (for value / date axis only)
                     * @param {number | Date} value.primaryCategory.max The maximum value of the related axis. (for value / date axis only)
                     * @param {string} value.primaryCategory.format The format of the primary category axis.
                     * @param {Object} value.primaryCategory.title The title of the primary category axis.
                     * @param {string} value.primaryCategory.title.text The title text of the primary category axis.
                     * @param {string} value.primaryCategory.title.color The title color of the primary category axis.
                     * @param {number} value.primaryCategory.title.transparency The transparency of the primary category axis color.
                     * @param {string} value.primaryCategory.title.fontFamily The title font family of the primary category axis.
                     * @param {number} value.primaryCategory.title.fontSize The title font size of the primary category axis, its unit is pixel.
                     * @param {Object} value.primaryCategory.majorGridLine The major grid line of the primary category axis.
                     * @param {Object} value.primaryCategory.minorGridLine The minor grid line of the primary category axis.
                     * @param {number} value.primaryCategory.labelAngle The label angle of the primary category axis.
                     * @param {Object} value.primaryCategory.scaling The scaling informations of the primary category axis.
                     * @param {number} value.primaryCategory.scaling.logBase The logarithmic scaling base value of the primary category axis.
                     * @param {number | GCTYPE.Spread.Sheets.Charts.AxisOrientation} value.primaryCategory.scaling.orientation Indicates the specified axis order.
                     * @param {Object} value.primaryCategory.displayUnit The display unit informations of the primary category axis.
                     * @param {number | GCTYPE.Spread.Sheets.Charts.DisplayUnit} value.primaryCategory.displayUnit.unit The built-in display unit string or custom number display unit of the primary category axis.
                     * @param {boolean} value.primaryCategory.displayUnit.visible The display unit label visible of the primary category axis.
                     * @param {Object} value.primaryCategory.displayUnit.style The display unit label style of the primary category axis.
                     * @param {string} value.primaryCategory.displayUnit.style.color The display unit label text color of the primary category axis.
                     * @param {number} value.primaryCategory.displayUnit.style.transparency The display unit label text transparency of the primary category axis color.
                     * @param {string} value.primaryCategory.displayUnit.style.fontFamily The display unit label text font family of the primary category axis.
                     * @param {number} value.primaryCategory.displayUnit.style.fontSize The display unit label text font size of the primary category axis, its unit is pixel.
                     * @returns {Object | GCTYPE.Spread.Sheets.Charts.Chart} If no value is set, returns the chart axes of the chart; otherwise, returns the chart.
                     *
                     * The majorGridLine and minorGridLine have same type.
                     * @param {string} value.primaryCategory.majorGridLine.color The color of the major grid line.
                     * @param {boolean} value.primaryCategory.majorGridLine.visible The visibility of the major grid line.
                     * @param {number} value.primaryCategory.majorGridLine.width The width of the major grid line.
                     * @param {number} value.primaryCategory.majorGridLine.transparency The transparency of the major grid line color.
                     *
                     * @returns {Object | GCTYPE.Spread.Sheets.Charts.Chart} If no value is set, returns the chart axes of the chart; otherwise, returns the chart.
                     */
                    axes(value?: GCTYPE.Spread.Sheets.Charts.IAxes): any;
                    /**
                     * Gets or sets the chart area style of the chart.
                     * @param {Object} value The chart area style of the chart.
                     * @param {string | Object} value.backColor The background color of the chart area.
                     * @param {GCTYPE.Spread.Sheets.Charts.PatternType} value.backColor.type The pattern fill background color type of the chart chartArea.
                     * @param {string} value.backColor.foregroundColor The pattern fill foreground color of the chart chartArea.
                     * @param {string} value.backColor.backgroundColor The pattern fill background color of the chart chartArea.
                     * @param {number} value.backColorTransparency The transparency of the chart area backColor.
                     * @param {string} value.fontFamily The font family of the chart area.
                     * @param {number} value.fontSize The font size of the chart area, its unit is pixel.
                     * @param {string} value.color The color of the chart area.
                     * @param {number} value.transparency The transparency of the chart area color.
                     * @param {Object} value.border The border of the chart area.
                     * @param {string} value.border.color The border color of the chart area.
                     * @param {number} value.border.transparency The border transparency of the chart area.
                     * @param {number} value.border.width The border width of the chart area.
                     * @param {GCTYPE.Spread.Sheets.Charts.LineType} value.border.dashStyle The border dash style of the chart area.
                     * @returns {Object | GCTYPE.Spread.Sheets.Charts.Chart} If no value is set, returns the chart area style of the chart; otherwise, returns the chart.
                     */
                    chartArea(value?: GCTYPE.Spread.Sheets.Charts.IChartArea): any;
                    /**
                     * Gets or sets the type of the chart.
                     * @param {GCTYPE.Spread.Sheets.Charts.ChartType} value The type of the chart.
                     * @returns {GCTYPE.Spread.Sheets.Charts.ChartType | GCTYPE.Spread.Sheets.Charts.Chart} If no value is set, returns the type of the chart; otherwise, returns the chart.
                     */
                    chartType(value?: GCTYPE.Spread.Sheets.Charts.ChartType): any;
                    /**
                     * Gets or sets the chart data labels style of the chart.
                     * @param {Object} value The chart data labels style of the chart.
                     * @param {boolean} value.showValue Whether to show value in data labels.
                     * @param {boolean} value.showSeriesName Whether to show series name in data labels.
                     * @param {boolean} value.showCategoryName Whether to show category name in data labels.
                     * @param {boolean} value.showPercentage Whether to show the percent value in data labels.
                     * @param {GCTYPE.Spread.Sheets.Charts.DataLabelPosition} value.position The position of the chart data labels.
                     * @param {string} value.format The format of the chart data labels.
                     * @param {string} value.color The color of the chart data labels.
                     * @param {number} value.transparency The transparency of the chart data labels color.
                     * @param {string} value.separator the separator of the series data labels.
                     * @param {string | Object} value.backColor The background color of the series data labels.
                     * @param {GCTYPE.Spread.Sheets.Charts.PatternType} value.backColor.type The pattern fill backgroundColor type of the chart series data labels.
                     * @param {string} value.backColor.foregroundColor The pattern fill foreground color of the chart series data labels.
                     * @param {string} value.backColor.backgroundColor The pattern fill background color of the chart series data labels.
                     * @param {number} value.backColorTransparency The background color transparency of the series data labels.
                     * @param {string} value.borderColor The border color of the series data labels.
                     * @param {number} value.borderWidth The border width of the series data labels.
                     * @param {number} value.borderColorTransparency The border color transparency of the series data labels.
                     * @returns {Object | GCTYPE.Spread.Sheets.Charts.Chart} If no value is set, returns the chart data labels style of the chart; otherwise, returns the chart.
                     */
                    dataLabels(value?: GCTYPE.Spread.Sheets.Charts.IDataLabels): any;
                    /**
                     * Gets or sets the whole data range of the chart as formula string.
                     * @param {string} value The formula string of the data range for the chart.
                     * @returns {string | GCTYPE.Spread.Sheets.Charts.Chart} If no value is set, returns the formula string of the whole data range for the chart; otherwise, returns the chart.
                     */
                    dataRange(value?: string): any;
                    /**
                     * Gets or sets the way that the chart display blank data.
                     * @param {GCTYPE.Spread.Sheets.Charts.DisplayBlanksAs} value the way that the chart display blank data.
                     * @returns {GCTYPE.Spread.Sheets.Charts.DisplayBlanksAs | GCTYPE.Spread.Sheets.Charts.Chart} If no value is set, returns the way that the chart display blank data, otherwise, returns the chart.
                     */
                    displayBlanksAs(value?: GCTYPE.Spread.Sheets.Charts.DisplayBlanksAs): any;
                    /**
                     * Gets or sets whether to show #N/A cells as blank cells.
                     * @param {boolean} value that whether to show #N/A cells as blank cells.
                     * @returns { boolean | GCTYPE.Spread.Sheets.Charts.Chart} If no value is set, returns whether to show #N/A cells as blank cells, otherwise, returns the chart.
                     */
                    displayNaAsBlank(value?: boolean): boolean | GCTYPE.Spread.Sheets.Charts.Chart;
                    /**
                     * Gets or sets the style when user hover over the dataPoint.
                     * @param {Object} value The hover style of the dataPoint been hovered.
                     * @param {string} value.color The color of the dataPoint been hovered.
                     * @param {number} value.transparency The color transparency of the dataPoint been hovered.
                     * @param {Object} value.borderStyle The border of the dataPoint been hovered.
                     * @param {string} value.borderStyle.color The border color of the dataPoint been hovered.
                     * @param {number} value.borderStyle.width The border width of the dataPoint been hovered.
                     * @param {number} value.borderStyle.transparency The border color transparency of the dataPoint been hovered.
                     * @param {GCTYPE.Spread.Sheets.Charts.LineType} value.borderStyle.dashStyle The border dash style of the dataPoint been hovered.
                     * @param {Object} value.symbolStyle The symbol style of the dataPoint been hovered.
                     * @param {string} value.symbolStyle.color The symbol's color of the dataPoint been hovered.
                     * @param {number} value.symbolStyle.transparency The symbol's transparency of the dataPoint been hovered.
                     * @param {Object} value.symbolStyle.borderStyle The symbol's border style of the dataPoint been hovered.
                     * @param {number} value.symbolStyle.borderStyle.color The symbol's border color of the dataPoint been hovered.
                     * @param {number} value.symbolStyle.borderStyle.width The symbol's border width of the dataPoint been hovered.
                     * @param {number} value.symbolStyle.borderStyle.transparency The symbol's border transparency of the dataPoint been hovered.
                     * @param {GCTYPE.Spread.Sheets.Charts.LineType} value.symbolStyle.borderStyle.dashStyle The symbol's border dash style of the dataPoint been hovered.
                     * @returns {Object | GCTYPE.Spread.Sheets.Charts.Chart} If no value is set, returns the current hover style of the chart; otherwise, returns the chart.
                     */
                    hoverStyle(value?: GCTYPE.Spread.Sheets.Charts.IHoverStyle): any;
                    /**
                     * Gets or sets the way that if the chart display hidden rows and columns data.
                     * @param {boolean} value the value that if the chart display hidden rows and columns data.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Charts.Chart} If no value is set, returns the value that if the chart display hidden rows and columns data, otherwise, returns the chart.
                     */
                    ignoreHidden(value?: boolean): boolean | GCTYPE.Spread.Sheets.Charts.Chart;
                    /**
                     * Gets or sets the legend of the chart.
                     * @param {Object} value The legend of the chart.
                     * @param {GCTYPE.Spread.Sheets.Charts.LegendPosition} value.position The position of the chart legend.
                     * @param {boolean} value.visible The visibility of the chart legend.
                     * @param {string | Object} value.backColor The backgroundColor of the chart legend.
                     * @param {GCTYPE.Spread.Sheets.Charts.PatternType} value.backColor.type The pattern fill backgroundColor type of the chart legend.
                     * @param {string} value.backColor.foregroundColor The pattern fill foreground color of the chart legend.
                     * @param {string} value.backColor.backgroundColor The pattern fill background color of the chart legend.
                     * @param {number} value.backColorTransparency The transparency of the chart legend color
                     * @param {Object} value.borderStyle The borderStyle of the chart legend.
                     * @param {string} value.borderStyle.color The border color of the chart legend.
                     * @param {number} value.borderStyle.width The border width of the chart legend.
                     * @param {number} value.borderStyle.transparency The transparency of the chart legend border color
                     * @param {string} value.color The color of the chart legend text.
                     * @param {string} value.fontFamily The font family of the chart legend text.
                     * @param {number} value.fontSize The font size of the chart legend text.
                     * @param {boolean} value.showLegendWithoutOverlapping whether the legend display without overlapping chart area
                     * @param {Object} value.layout The layout of the chart legend.
                     * @param {number} value.layout.x The x position of the chart legend, it's percentage, and the base line is chart's left edge.
                     * @param {number} value.layout.y The y position of the chart legend, it's percentage, and the base line is chart's top edge.
                     * @param {number} value.layout.width The width of the chart legend, it's percentage, and it's based on the chart's width.
                     * @param {number} value.layout.height The height of the chart legend, it's percentage, and it's based on the chart's height.
                     * @returns {Object | GCTYPE.Spread.Sheets.Charts.Chart} If no value is set, returns the legend of the chart; otherwise, returns the chart.
                     */
                    legend(value?: GCTYPE.Spread.Sheets.Charts.IChartLegend): any;
                    /**
                     * Gets the series collection of the chart.
                     * @returns {GCTYPE.Spread.Sheets.Charts.SeriesCollection} Returns the series collection of the chart.
                     */
                    series(): GCTYPE.Spread.Sheets.Charts.SeriesCollection;
                    /**
                     * Switches the data orientation between rows and columns.
                     * @returns {boolean} Returns true when data orienetation is changable and successful switched; otherwise, false.
                     */
                    switchDataOrientation(): boolean;
                    /**
                     * Gets or sets the title of the chart.
                     * @param {Object} value The title of the chart.
                     * @param {string} value.text The text of the chart title.
                     * @param {string} value.fontFamily The font family of the chart title.
                     * @param {number} value.fontSize The font size of the chart title, its unit is pixel.
                     * @param {string} value.color The color of the chart title.
                     * @param {number} value.transparency The transparency of the chart title color
                     * @param {string | Object} value.backColor The background color of the chart title area.
                     * @param {GCTYPE.Spread.Sheets.Charts.PatternType} value.backColor.type The pattern fill background color type of the chart title area.
                     * @param {string} value.backColor.foregroundColor The pattern fill foreground color of the chart title area.
                     * @param {string} value.backColor.backgroundColor The pattern fill background color of the chart title area.
                     * @param {number} value.backColorTransparency The transparency of the chart title area backColor.
                     * @returns {Object | GCTYPE.Spread.Sheets.Charts.Chart} If no value is set, returns the title of the chart; otherwise, returns the chart.
                     */
                    title(value?: GCTYPE.Spread.Sheets.Charts.IChartTitle): any;
                    /**
                     * Gets or sets whether apply animation to the chart.
                     * @param {boolean} value whether apply animation to the chart.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Charts.Chart} If no value is set, returns whether apply animation to the chart; otherwise, returns the chart.
                     */
                    useAnimation(value?: boolean): any;
                }

                export class ChartCollection{
                    /**
                     * Represents a chart manager that managers all charts in a sheet.
                     * @class
                     * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The worksheet.
                     */
                    constructor();
                    /**
                     * Adds a chart to the sheet.
                     * @param {string} name The name of the chart that will be added to the sheet.
                     * @param {GCTYPE.Spread.Sheets.Charts.ChartType} chartType The type of the chart.
                     * @param {number} x The x location of the chart.
                     * @param {number} y The y location of the chart.
                     * @param {number} width The width of the chart.
                     * @param {number} height The height of the chart.
                     * @param {string} dataRange The formula string of data range for the chart.
                     * @param {GCTYPE.Spread.Sheets.Charts.RowCol} dataOrientation The orientation of data for series.
                     * @return {GCTYPE.Spread.Sheets.Charts.Chart} The chart that has been added to the sheet.
                     * @example
                     * //This example shows how to add a chart.
                     * var dataRange = "A1:D4";
                     * var chart = activeSheet.charts.add('Chart1', GCTYPE.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 400, dataRange);
                     */
                    add(name: string,  chartType: GCTYPE.Spread.Sheets.Charts.ChartType,  x: number,  y: number,  width: number,  height: number,  dataRange?: string,  dataOrientation?: GCTYPE.Spread.Sheets.Charts.RowCol): GCTYPE.Spread.Sheets.Charts.Chart;
                    /**
                     * Gets all of the charts in the sheet.
                     * @return {Array.<GCTYPE.Spread.Sheets.Charts.Chart>} The collection of all the charts in the sheet.
                     * @example
                     * var dataRange = "A1:D4";
                     * activeSheet.charts.add('Chart1', GCTYPE.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 180, dataRange);
                     * var dataRange2 = "A20:D24";
                     * activeSheet.charts.add('Chart2', GCTYPE.Spread.Sheets.Charts.ChartType.columnClustered, 250, 220, 600, 180, dataRange2);
                     * var charts = activeSheet.charts.all();
                     * for (var i = 0; i &lt; charts.length; i++) {
                     *     alert("Name of chart " + i + " is:  " + charts[i].name())
                     * }
                     */
                    all(): GCTYPE.Spread.Sheets.Charts.Chart[];
                    /**
                     * Removes all charts in the sheet.
                     */
                    clear(): void;
                    /**
                     * Gets a chart from the sheet by the indicate name.
                     * @param {string} name The name of the chart.
                     * @return {GCTYPE.Spread.Sheets.Charts.Chart} The chart in the sheet with the indicate name.
                     * @example
                     * var dataRange = "A1:D4";
                     * activeSheet.charts.add('Chart1', GCTYPE.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 400, dataRange);
                     * //button
                     * $("#button1").click(function () {
                     *  var chart = activeSheet.charts.get("f2");
                     * });
                     */
                    get(name: string): GCTYPE.Spread.Sheets.Charts.Chart;
                    /**
                     * Gets or sets if preserve unsupport chart when import.
                     * @param {boolean} flag indicates whether preserve unsupport chart when import, the default value is false, if set true, it will be painted as paintCallBack.
                     * @param {Function} paintCallBack the display content function for unsupport chart.
                     * @returns {boolean} If no value is set, return the flag value, otherwise, return undefined;
                     * @example
                     * sheet.charts.preserveUnsupportedChart(true, function(chartHost, chart){
                     * var paintElement= document.createElement('div');
                     * paintElement.innerHTML = '<span>to be continue</span>';
                     * chartHost.appendChild(paintElement);
                     * })
                     */
                    preserveUnsupportedChart(flag: boolean,  paintCallBack?: GCTYPE.Spread.Sheets.Charts.IPaintCallBack): boolean | undefined;
                    /**
                     * Removes a chart from the sheet by the indicate name.
                     * @param {string} name The name of the chart.
                     * @example
                     * var dataRange = "A1:D4";
                     * activeSheet.charts.add('Chart1', GCTYPE.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 400, dataRange);
                     * //button
                     * $("#button1").click(function () {
                     *      activeSheet.resumePaint();
                     *      activeSheet.charts.remove("f2");
                     *      activeSheet.repaint();
                     * });
                     */
                    remove(name: string): void;
                    /**
                     * Gets or sets the z-index of chart.
                     * @param {string} name The name of the chart.
                     * @param {number} zIndex The z-index of the chart.
                     * @return {number | *} If the parameter 'zIndex' is null or undefined,it will return the z-index of the chart with the indicate name.
                     * @example
                     * var dataRange = "A1:D4";
                     * activeSheet.charts.add('Chart1', GCTYPE.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 180, dataRange);
                     * var dataRange2 = "A20:D24";
                     * activeSheet.charts.add('Chart2', GCTYPE.Spread.Sheets.Charts.ChartType.columnClustered, 250, 180, 600, 180, dataRange2);
                     * activeSheet.charts.zIndex('Chart1', 897);
                     * activeSheet.charts.zIndex('Chart2', 890);
                     */
                    zIndex(name: string,  zIndex?: number): any;
                }

                export class DataPoints{
                    /**
                     * Represents the dataPoint collection that managers all dataPoints in a chart series.
                     * @class
                     */
                    constructor();
                    /**
                     * Gets all dataPoints or a specified dataPoint from dataPoints collection.
                     * @param {number} index The index of the dataPoint.
                     * @return {Object | Object[]} The dataPoint of the chart series.
                     * @example
                     * // This example shows how to get a dataPoint.
                     * var dataRange = new GCTYPE.Spread.Sheets.Range(0, 0, 16, 4);
                     * var chart = activeSheet.charts.add('Chart1', GCTYPE.Spread.Sheets.Charts.ChartType.sunburst, 250, 20, 600, 400, dataRange);
                     * var dataPoints = chart.series().dataPoints();
                     * var dataPoint = dataPoints.get(0);
                     */
                    get(index?: number): any;
                    /**
                     * Updates the specified dataPoint's property.
                     * @param {number} index The index of the dataPoint.
                     * @param {Object} dataPoint The data point of the chart.
                     * @param {string | Object} dataPoint.fillColor The color of the data point.
                     * @param {GCTYPE.Spread.Sheets.Charts.PatternType} value.backColor.type The pattern fill backgroundColor type of the chart data point.
                     * @param {string} value.backColor.foregroundColor The pattern fill foreground color of the chart data point.
                     * @param {string} value.backColor.backgroundColor The pattern fill background color of the chart data point.
                     * @param {number} dataPoint.transparency The transparency of the data point color.
                     * @example
                     * // This example shows how to update the property of a dataPoint
                     * var dataRange = new GCTYPE.Spread.Sheets.Range(0, 0, 16, 4);
                     * var chart = activeSheet.charts.add('Chart1', GCTYPE.Spread.Sheets.Charts.ChartType.sunburst, 250, 20, 600, 400, dataRange);
                     * var dataPoints = chart.series().dataPoints();
                     * var dataPoint = {fillColor: 'rgba(255,255,0,0,7)'};
                     * dataPoints.set(0, dataPoint);
                     */
                    set(index: number,  dataPoint: GCTYPE.Spread.Sheets.Charts.IDataPointPart): void;
                }

                export class SeriesCollection{
                    /**
                     * Represents the series manager that managers all series in a chart.
                     * @class
                     */
                    constructor();
                    /**
                     * Adds a new series to series collection.
                     * @param {Object} seriesItem The series of the chart.
                     * @param {Object} seriesItem.symbol, seriesItem The symbol of the series.
                     * @param {string} seriesItem.symbol.fill The symbol fill color of the series.
                     * @param {number} seriesItem.symbol.fillColorTransparency The transparency of the symbol fill color.
                     * @param {number} seriesItem.symbol.size The symbol size of the series.
                     * @param {GCTYPE.Spread.Sheets.Charts.SymbolShape} seriesItem.symbol.shape The symbol shape of the series.
                     * @param {Object} seriesItem.symbol.border The symbol border of the series.
                     * @param {string} seriesItem.symbol.border.color The symbol border color of the series.
                     * @param {number} seriesItem.symbol.border.colorTransparency The transparency of the symbol border color.
                     * @param {number} seriesItem.symbol.border.width The symbol border width of the series.
                     * @param {GCTYPE.Spread.Sheets.Charts.LineType} seriesItem.symbol.border.lineType The symbol border line Type of the series.
                     * @param {Object} seriesItem.errorbars The error bars of the series.
                     * @param {Object} seriesItem.errorbars.vertical The vertical error bar of the series, each series may has different direction error bar(s) based on chart type.
                     * @param {GCTYPE.Spread.Sheets.Charts.ErrorBarType} seriesItem.errorbars.vertical.type The error bar type.
                     * @param {GCTYPE.Spread.Sheets.Charts.ErrorBarValueType} seriesItem.errorbars.vertical.valuetype The error bar value type.
                     * @param {boolean} seriesItem.errorbars.vertical.noEndCap The error bar has end cap or not.
                     * @param {number} seriesItem.errorbars.vertical.value The error bar value, just take effect on the FixedValue(1) / Percentage(2) / StandardDeviation(3) value type.
                     * @param {Object} seriesItem.errorbars.vertical.custom The error bar custom formulas, it contains positive formula and negative formula, just take effect on the Custom(0) value type.
                     * @param {string} seriesItem.errorbars.vertical.custom.positive The error bar custom positive formula.
                     * @param {string} seriesItem.errorbars.vertical.custom.negative The error bar custom negative formula.
                     * @param {Object} seriesItem.errorbars.vertical.style The error bar styles.
                     * @param {string} seriesItem.errorbars.vertical.style.color The error bar color.
                     * @param {number} seriesItem.errorbars.vertical.style.transparency The error bar transparency.
                     * @param {number} seriesItem.errorbars.vertical.style.width The error bar width.
                     * @param {Object} seriesItem.errorbars.horizontal The horizontal error bar of the series, each series may has different direction error bar(s) based on chart type.
                     * @param {GCTYPE.Spread.Sheets.Charts.ErrorBarType} seriesItem.errorbars.horizontal.type The error bar type.
                     * @param {GCTYPE.Spread.Sheets.Charts.ErrorBarValueType} seriesItem.errorbars.horizontal.valuetype The error bar value type.
                     * @param {boolean} seriesItem.errorbars.horizontal.noEndCap The error bar has end cap or not.
                     * @param {number} seriesItem.errorbars.horizontal.value The error bar value, just take effect on the FixedValue(1) / Percentage(2) / StandardDeviation(3) value type.
                     * @param {Object} seriesItem.errorbars.horizontal.custom The error bar custom formulas, it contains positive formula and negative formula, just take effect on the Custom(0) value type.
                     * @param {string} seriesItem.errorbars.horizontal.custom.positive The error bar custom positive formula.
                     * @param {string} seriesItem.errorbars.horizontal.custom.negative The error bar custom negative formula.
                     * @param {Object} seriesItem.errorbars.horizontal.style The error bar styles.
                     * @param {string} seriesItem.errorbars.horizontal.style.color The error bar color.
                     * @param {number} seriesItem.errorbars.horizontal.style.transparency The error bar transparency.
                     * @param {number} seriesItem.errorbars.horizontal.style.width The error bar width.
                     * @param {GCTYPE.Spread.Sheets.Charts.LineType} seriesItem.errorbars.horizontal.style.dashStyle The error bar dash style.
                     * @param {Object[]} seriesItem.trendlines The trendlines of the series.
                     * @param {GCTYPE.Spread.Sheets.Charts.TrendlineType} seriesItem.trendlines[0].type The type of the trendline.
                     * @param {number} seriesItem.trendlines[0].order The order of the polynomial trendline.
                     * @param {number} seriesItem.trendlines[0].period The period of the movingAverage trendline.
                     * @param {number} seriesItem.trendlines[0].intercept The intercept of the trendline.
                     * @param {number} seriesItem.trendlines[0].forward The forward of the trendline.
                     * @param {number} seriesItem.trendlines[0].backward The backward of the trendline.
                     * @param {boolean} seriesItem.trendlines[0].displayEquation Whether display the equation of the trendline.
                     * @param {boolean} seriesItem.trendlines[0].displayRSquared Whether display the R squared of the trendline.
                     * @param {string} seriesItem.trendlines[0].fontFamily The fontFamily of the trendline.
                     * @param {number} seriesItem.trendlines[0].fontSize The fontSize of the trendline.
                     * @param {string} seriesItem.trendlines[0].fontColor The fontColor of the trendline.
                     * @param {string} seriesItem.trendlines[0].name The name of the trendline.
                     * @param {Object} seriesItem.trendlines[0].style The line style of the trendline.
                     * @param {string} seriesItem.trendlines[0].style.color The color of the trendline.
                     * @param {number} seriesItem.trendlines[0].style.transparency The transparency of the trendline.
                     * @param {number} seriesItem.trendlines[0].style.width The width of the trendline.
                     * @param {GCTYPE.Spread.Sheets.Charts.LineType} seriesItem.trendlines[0].style.dashStyle The dash style of the trendline.
                     * @param {GCTYPE.Spread.Sheets.Charts.ChartType} seriesItem.chartType The chart type of the series.
                     * @param {GCTYPE.Spread.Sheets.Charts.AxisGroup} seriesItem.axisGroup The axis group of the series.
                     * @param {string | Object} seriesItem.backColor The background color of the series.
                     * @param {GCTYPE.Spread.Sheets.Charts.PatternType} seriesItem.backColor.type The pattern fill background color type of the chart series.
                     * @param {string} seriesItem.backColor.foregroundColor The pattern fill foreground color of the chart series.
                     * @param {string} seriesItem.backColor.backgroundColor The pattern fill background color of the chart series.
                     * @param {number} seriesItem.backColorTransparency The transparency of the series background color.
                     * @param {Object} seriesItem.border The border of the series.
                     * @param {string} seriesItem.border.color The border color of the series.
                     * @param {GCTYPE.Spread.Sheets.Charts.LineType} seriesItem.border.lineType The border line type of the series.
                     * @param {number} seriesItem.border.transparency The transparency of the series border color.
                     * @param {number} seriesItem.border.width The border width of the series.
                     * @param {number} seriesItem.startAngle The first slice angle of the chart whose chart type is pie. The default value is 0, which represents the 12 o'clock position.
                     * @param {string} seriesItem.name The name formula of the series.
                     * @param {string} seriesItem.xValues The x values formula of the series.
                     * @param {string} seriesItem.yValues The y values formula of the series.
                     * @param {string} seriesItem.bubbleSizes The bubble sizes formula of the series. This is used for bubble chart.
                     * @param {number} seriesItem.doughnutHoleSize The hole size of the doughnut chart. This is used for doughnut chart, The maximum value is 0.9, the minimum value is 0.
                     * @param {number} seriesItem.gapWidth The gap width of the bar and column chart group. The maximum value is 5, the minimum value is 0.
                     * @param {number} seriesItem.overlap The overlap of the bar and column chart group. The maximum value is 1, the minimum value is -1.
                     * @param {Array} seriesItem.trendlines The trendlines of the series.
                     * @param {Object} seriesItem.dataLabels The data labels of the series.
                     * @param {boolean} seriesItem.dataLabels.showValue Whether to show value in series data labels.
                     * @param {boolean} seriesItem.dataLabels.showSeriesName Whether to show series name in series data labels.
                     * @param {boolean} seriesItem.dataLabels.showCategoryName Whether to show category name in series data labels.
                     * @param {boolean} seriesItem.dataLabels.showPercentage Whether to show the percent value in series data labels.
                     * @param {string} seriesItem.dataLabels.separator the separator of the series data labels.
                     * @param {GCTYPE.Spread.Sheets.Charts.DataLabelPosition} seriesItem.dataLabels.position The position of the series data labels.
                     * @param {string} seriesItem.dataLabels.format The format of the series data labels.
                     * @param {string} seriesItem.dataLabels.color The text color of the series data labels.
                     * @param {number} seriesItem.dataLabels.transparency The text color transparency of the series data labels.
                     * @param {string | Object} seriesItem.dataLabels.backColor The background color of the series data labels.
                     * @param {GCTYPE.Spread.Sheets.Charts.PatternType} seriesItem.dataLabels.backColor.type The pattern fill background color type of the chart series dataLabels.
                     * @param {string} seriesItem.dataLabels.backColor.foregroundColor The pattern fill foreground color of the chart series dataLabels.
                     * @param {string} seriesItem.dataLabels.backColor.backgroundColor The pattern fill background color of the chart series dataLabels.
                     * @param {number} seriesItem.dataLabels.backColorTransparency The background color transparency of the series data labels.
                     * @param {string} seriesItem.dataLabels.borderColor The border color of the series data labels.
                     * @param {number} seriesItem.dataLabels.borderWidth The border width of the series data labels.
                     * @param {number} seriesItem.dataLabels.borderColorTransparency The border color transparency of the series data labels.
                     * @example
                     * // This example shows how to add a new series.
                     * var dataRange = "A1:D4";
                     * var chart = activeSheet.charts.add('Chart1', GCTYPE.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 400, dataRange);
                     * chart.series.add({
                     *     chartType: GCTYPE.Spread.Sheets.Charts.ChartType.columnClustered,
                     *     axisGroup: GCTYPE.Spread.Sheets.Charts.AxisGroup.primary,
                     *     backColor: {
                     *         color: "lightblue",
                     *         width: 2
                     *     },
                     *     xValues: "A2:A4",
                     *     yValues: "B2:B4"
                     * });
                     */
                    add(series: GCTYPE.Spread.Sheets.Charts.ISeries | GCTYPE.Spread.Sheets.Charts.ISeries[]): void;
                    /**
                     * Gets the dataPoints of the chart series.
                     * @returns {GCTYPE.Spread.Sheets.Charts.DataPoints} Returns the dataPoints of the chart series if exist.
                     */
                    dataPoints(): GCTYPE.Spread.Sheets.Charts.DataPoints;
                    /**
                     * Gets all series or a specified series from series collection.
                     * @param {number} index The index of the series.
                     * @return {Object | Object[]} The series of the chart.
                     * @example
                     * // This example shows how to get a series.
                     * var dataRange = "A1:D4";
                     * var chart = activeSheet.charts.add('Chart1', GCTYPE.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 400, dataRange);
                     * var series1 = chart.series().get(0);
                     */
                    get(index?: number): any;
                    /**
                     * Removes a specified series from series collection.
                     * @param {number} index The index of the series.
                     * @example
                     * // This example shows how to remove a specified series.
                     * var dataRange = "A1:D4";
                     * var chart = activeSheet.charts.add('Chart1', GCTYPE.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 400, dataRange);
                     * chart.series.remove(0);
                     */
                    remove(index: number): void;
                    /**
                     * Updates the specified series's property.
                     * @param {number} index The index of the series.
                     * @param {Object} seriesItem The series of the chart.
                     * @param {Object} seriesItem.symbol, seriesItem The symbol of the series.
                     * @param {string} seriesItem.symbol.fill The symbol fill color of the series.
                     * @param {number} seriesItem.symbol.fillColorTransparency The transparency of the symbol fill color.
                     * @param {number} seriesItem.symbol.size The symbol size of the series.
                     * @param {GCTYPE.Spread.Sheets.Charts.SymbolShape} seriesItem.symbol.shape The symbol shape of the series.
                     * @param {Object} seriesItem.symbol.border The symbol border of the series.
                     * @param {string} seriesItem.symbol.border.color The symbol border color of the series.
                     * @param {number} seriesItem.symbol.border.colorTransparency The transparency of the symbol border color.
                     * @param {number} seriesItem.symbol.border.width The symbol border width of the series.
                     * @param {GCTYPE.Spread.Sheets.Charts.LineType} seriesItem.symbol.border.lineType The symbol border line Type of the series.
                     * @param {Object} seriesItem.errorbars The error bars of the series.
                     * @param {Object} seriesItem.errorbars.vertical The vertical error bar of the series, each series may has different direction error bar(s) based on chart type.
                     * @param {GCTYPE.Spread.Sheets.Charts.ErrorBarType} seriesItem.errorbars.vertical.type The error bar type.
                     * @param {GCTYPE.Spread.Sheets.Charts.ErrorBarValueType} seriesItem.errorbars.vertical.valuetype The error bar value type.
                     * @param {boolean} seriesItem.errorbars.vertical.noEndCap The error bar has end cap or not.
                     * @param {number} seriesItem.errorbars.vertical.value The error bar value, just take effect on the FixedValue(1) / Percentage(2) / StandardDeviation(3) value type.
                     * @param {Object} seriesItem.errorbars.vertical.custom The error bar custom formulas, it contains positive formula and negative formula, just take effect on the Custom(0) value type.
                     * @param {string} seriesItem.errorbars.vertical.custom.positive The error bar custom positive formula.
                     * @param {string} seriesItem.errorbars.vertical.custom.negative The error bar custom negative formula.
                     * @param {Object} seriesItem.errorbars.vertical.style The error bar styles.
                     * @param {string} seriesItem.errorbars.vertical.style.color The error bar color.
                     * @param {number} seriesItem.errorbars.vertical.style.transparency The error bar transparency.
                     * @param {number} seriesItem.errorbars.vertical.style.width The error bar width.
                     * @param {Object} seriesItem.errorbars.horizontal The horizontal error bar of the series, each series may has different direction error bar(s) based on chart type.
                     * @param {GCTYPE.Spread.Sheets.Charts.ErrorBarType} seriesItem.errorbars.horizontal.type The error bar type.
                     * @param {GCTYPE.Spread.Sheets.Charts.ErrorBarValueType} seriesItem.errorbars.horizontal.valuetype The error bar value type.
                     * @param {boolean} seriesItem.errorbars.horizontal.noEndCap The error bar has end cap or not.
                     * @param {number} seriesItem.errorbars.horizontal.value The error bar value, just take effect on the FixedValue(1) / Percentage(2) / StandardDeviation(3) value type.
                     * @param {Object} seriesItem.errorbars.horizontal.custom The error bar custom formulas, it contains positive formula and negative formula, just take effect on the Custom(0) value type.
                     * @param {string} seriesItem.errorbars.horizontal.custom.positive The error bar custom positive formula.
                     * @param {string} seriesItem.errorbars.horizontal.custom.negative The error bar custom negative formula.
                     * @param {Object} seriesItem.errorbars.horizontal.style The error bar styles.
                     * @param {string} seriesItem.errorbars.horizontal.style.color The error bar color.
                     * @param {number} seriesItem.errorbars.horizontal.style.transparency The error bar transparency.
                     * @param {number} seriesItem.errorbars.horizontal.style.width The error bar width.
                     * @param {GCTYPE.Spread.Sheets.Charts.LineType} seriesItem.errorbars.horizontal.style.dashStyle The error bar dash style.
                     * @param {Object[]} seriesItem.trendlines The trendlines of the series.
                     * @param {GCTYPE.Spread.Sheets.Charts.TrendlineType} seriesItem.trendlines[0].type The type of the trendline.
                     * @param {number} seriesItem.trendlines[0].order The order of the polynomial trendline.
                     * @param {number} seriesItem.trendlines[0].period The period of the movingAverage trendline.
                     * @param {number} seriesItem.trendlines[0].intercept The intercept of the trendline.
                     * @param {number} seriesItem.trendlines[0].forward The forward of the trendline.
                     * @param {number} seriesItem.trendlines[0].backward The backward of the trendline.
                     * @param {boolean} seriesItem.trendlines[0].displayEquation Whether display the equation of the trendline.
                     * @param {boolean} seriesItem.trendlines[0].displayRSquared Whether display the R squared of the trendline.
                     * @param {string} seriesItem.trendlines[0].fontFamily The fontFamily of the trendline.
                     * @param {number} seriesItem.trendlines[0].fontSize The fontSize of the trendline.
                     * @param {string} seriesItem.trendlines[0].fontColor The fontColor of the trendline.
                     * @param {string} seriesItem.trendlines[0].name The name of the trendline.
                     * @param {Object} seriesItem.trendlines[0].style The line style of the trendline.
                     * @param {string} seriesItem.trendlines[0].style.color The color of the trendline.
                     * @param {number} seriesItem.trendlines[0].style.transparency The transparency of the trendline.
                     * @param {number} seriesItem.trendlines[0].style.width The width of the trendline.
                     * @param {GCTYPE.Spread.Sheets.Charts.LineType} seriesItem.trendlines[0].style.dashStyle The dash style of the trendline.
                     * @param {GCTYPE.Spread.Sheets.Charts.ChartType} seriesItem.chartType The chart type of the series.
                     * @param {GCTYPE.Spread.Sheets.Charts.AxisGroup} seriesItem.axisGroup The axis group of the series.
                     * @param {string | Object} seriesItem.backColor The background color of the series.
                     * @param {GCTYPE.Spread.Sheets.Charts.PatternType} seriesItem.backColor.type The pattern fill background color type of the chart series.
                     * @param {string} seriesItem.backColor.foregroundColor The pattern fill foreground color of the chart series.
                     * @param {string} seriesItem.backColor.backgroundColor The pattern fill background color of the chart series.
                     * @param {number} seriesItem.backColorTransparency The transparency of the series background color.
                     * @param {Object} seriesItem.border The border of the series.
                     * @param {string} seriesItem.border.color The border color of the series.
                     * @param {GCTYPE.Spread.Sheets.Charts.LineType} seriesItem.border.lineType The border line type of the series.
                     * @param {number} seriesItem.border.transparency The transparency of the series border color.
                     * @param {number} seriesItem.border.width The border width of the series.
                     * @param {number} seriesItem.startAngle The first slice angle of the chart whose chart type is pie. The default value is 0, which represents the 12 o'clock position.
                     * @param {string} seriesItem.name The name formula of the series.
                     * @param {string} seriesItem.xValues The x values formula of the series.
                     * @param {string} seriesItem.yValues The y values formula of the series.
                     * @param {string} seriesItem.bubbleSizes The bubble sizes formula of the series. This is used for bubble chart.
                     * @param {number} seriesItem.doughnutHoleSize The hole size of the doughnut chart. This is used for doughnut chart, The maximum value is 0.9, the minimum value is 0.
                     * @param {number} seriesItem.gapWidth The gap width of the bar and column chart group. The maximum value is 5, the minimum value is 0.
                     * @param {number} seriesItem.overlap The overlap of the bar and column chart group. The maximum value is 1, the minimum value is -1.
                     * @param {Array} seriesItem.trendlines The trendlines of the series.
                     * @param {Object} seriesItem.dataLabels The data labels of the series.
                     * @param {boolean} seriesItem.dataLabels.showValue Whether to show value in series data labels.
                     * @param {boolean} seriesItem.dataLabels.showSeriesName Whether to show series name in series data labels.
                     * @param {boolean} seriesItem.dataLabels.showCategoryName Whether to show category name in series data labels.
                     * @param {boolean} seriesItem.dataLabels.showPercentage Whether to show the percent value in series data labels.
                     * @param {string} seriesItem.dataLabels.separator the separator of the series data labels.
                     * @param {GCTYPE.Spread.Sheets.Charts.DataLabelPosition} seriesItem.dataLabels.position The position of the series data labels.
                     * @param {string} seriesItem.dataLabels.format The format of the series data labels.
                     * @param {string} seriesItem.dataLabels.color The text color of the series data labels.
                     * @param {number} seriesItem.dataLabels.transparency The text color transparency of the series data labels.
                     * @param {string | Object} seriesItem.dataLabels.backColor The background color of the series data labels.
                     * @param {GCTYPE.Spread.Sheets.Charts.PatternType} seriesItem.dataLabels.backColor.type The pattern fill background color type of the chart series dataLabels.
                     * @param {string} seriesItem.dataLabels.backColor.foregroundColor The pattern fill foreground color of the chart series dataLabels.
                     * @param {string} seriesItem.dataLabels.backColor.backgroundColor The pattern fill background color of the chart series dataLabels.
                     * @param {number} seriesItem.dataLabels.backColorTransparency The background color transparency of the series data labels.
                     * @param {string} seriesItem.dataLabels.borderColor The border color of the series data labels.
                     * @param {number} seriesItem.dataLabels.borderWidth The border width of the series data labels.
                     * @param {number} seriesItem.dataLabels.borderColorTransparency The border color transparency of the series data labels.
                     * @example
                     * // This example shows how to update the property of a series.
                     * var dataRange = "A1:D4";
                     * var chart = activeSheet.charts.add('Chart1', GCTYPE.Spread.Sheets.Charts.ChartType.columnClustered, 250, 20, 600, 400, dataRange);
                     * var series1 = chart.series().get(0);
                     * series1.backColor = "red";
                     * chart.series().set(0, series1);
                     */
                    set(index: number,  series: GCTYPE.Spread.Sheets.Charts.ISeries): void;
                }
            }

            module Commands{
                /**
                 * Represents the command used to automatically resize the column in a sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.columns {Array} The resize columns; each item is an object which has a col.<br />
                 * options.rowHeader {boolean} Whether the resized columns are in the row header area.<br />
                 * options.autoFitType {GCTYPE.Spread.Sheets.AutoFitType} Whether the auto-fit action includes the header text.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * var columns = [ { col: 3 } ];
                 * spread.options.allowUndo = true;
                 * spread.commandManager().execute({cmd: "autoFitColumn", sheetName: "Sheet1", columns: columns, rowHeader: false, autoFitType: GCTYPE.Spread.Sheets.AutoFitType.cell});
                 */
                var autoFitColumn: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, columns: Object[], rowHeader: boolean, autoFitType: GCTYPE.Spread.Sheets.AutoFitType}, isUndo: boolean): any};
                /**
                 * Represents the command used to automatically resize the row in a sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.rows {Array} The resize rows; each item is an object which has a row.<br />
                 * options.columnHeader {boolean} Whether the resized rows are in the column header area.<br />
                 * options.autoFitType {GCTYPE.Spread.Sheets.AutoFitType} Whether the auto-fit action includes the header text.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * spread.options.allowUndo = true;
                 * var rows = [ { row: 3 } ];
                 * spread.commandManager().execute({cmd: "autoFitRow", sheetName: "Sheet1", rows: rows, columnHeader: false, autoFitType: GCTYPE.Spread.Sheets.AutoFitType.cell});
                 */
                var autoFitRow: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, rows: Object[], columnHeader: boolean, autoFitType: GCTYPE.Spread.Sheets.AutoFitType}, isUndo: boolean): any};
                /**
                 * Represents the command used to stop cell editing and cancel input.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var cancelInput: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to switch the formula reference between relative, absolute, and mixed when editing formulas.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var changeFormulaReference: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to clear the cell value.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * // clear selected cells with the tab key
                 * spread.commandManager().setShortcutKey('clear', GCTYPE.Spread.Commands.Key.tab, false, false, false, false); // Tab key
                 */
                var clear: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to clear the active cell value and enters edit mode.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var clearAndEditing: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to clear cell values on a worksheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.ranges {Array} The clear cell value ranges whose item type is GCTYPE.Spread.Sheets.Range.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * spread.options.allowUndo = true;
                 * spread.commandManager().execute({cmd: "clearValues", sheetName: "Sheet1", ranges: [new GCTYPE.Spread.Sheets.Range(8, 5, 2, 1)]});
                 */
                var clearValues: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, ranges:GCTYPE.Spread.Sheets.Range[]}, isUndo: boolean): any};
                /**
                 * Represents the command used for a Clipboard paste on the worksheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.fromSheet {GCTYPE.Spread.Sheets.Worksheet} The source sheet.<br />
                 * options.fromRanges {Array} The source range array which item type is GCTYPE.Spread.Sheets.Range.<br />
                 * options.pastedRanges {Array} The target range array which item type is GCTYPE.Spread.Sheets.Range.<br />
                 * options.isCutting {boolean} Whether the operation is cutting or copying.<br />
                 * options.clipboardText {string} The text on the clipboard.<br />
                 * options.pasteOption {GCTYPE.Spread.Sheets.ClipboardPasteOptions} The Clipboard pasting option that indicates which content to paste.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the clipboardPaste method.
                 * activeSheet.setValue(0, 0, 1, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.setValue(1, 0, 2, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.setFormula(2, 0, "=A1+A2", GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.setValue(0, 1, 3, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.setValue(1, 1, 4, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * activeSheet.setFormula(2, 1, "=B1+B2", GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * var fromRange = [new GCTYPE.Spread.Sheets.Range(0, 0, 3, 2)];
                 * var toRanges = [new GCTYPE.Spread.Sheets.Range(5, 0, 3, 2)];
                 * $("#button1").click(function () {
                 *     //Cut Paste Action
                 *     spread.commandManager().execute({cmd: "clipboardPaste", sheetName: "Sheet1", fromSheet: activeSheet, fromRanges: fromRange, pastedRanges: toRanges, isCutting: true, clipboardText: "", pasteOption: GCTYPE.Spread.Sheets.ClipboardPasteOptions.all});
                 * });
                 * $("#button2").click(function () {
                 *     spread.commandManager().execute({cmd: "clipboardPaste", sheetName: "Sheet1", fromSheet: activeSheet, fromRanges: fromRange, pastedRanges: toRanges, isCutting: false, clipboardText: "", pasteOption: GCTYPE.Spread.Sheets.ClipboardPasteOptions.all});
                 * });
                 * //Add button controls to page
                 * &lt;input type="button" id="button1" value="button1"/&gt;
                 * &lt;input type="button" id="button2" value="button2"/&gt;
                 */
                var clipboardPaste: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, fromSheet: GCTYPE.Spread.Sheets.Worksheet, fromRanges: GCTYPE.Spread.Sheets.Range[], pastedRanges: GCTYPE.Spread.Sheets.Range[], isCutting: boolean, clipboardText: string, pasteOption: GCTYPE.Spread.Sheets.ClipboardPasteOptions}, isUndo: boolean): any};
                /**
                 * Represents the command used to commit the cell editing and sets the array formula to the active range.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var commitArrayFormula: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to stop cell editing and moves the active cell to the next row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var commitInputNavigationDown: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to stop cell editing and moves the active cell to the previous row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var commitInputNavigationUp: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to copy the selected item text to the Clipboard.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var copy: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to copy sheet.
                 * @param context The context of the operation.
                 * @param options The options of the operation.
                 * The arguments of the execute method are as follows.
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.
                 * options {Object} The options of the operation.
                 * options.sheetName {string} The clone sheet name.
                 * options.targetIndex {number} The target index.
                 * options.newName {number} The new sheet name.
                 * options.includeBindingSource {boolean} Whether to bind data source to clone sheet
                 * @example
                 * //This example copy a sheet.
                 * spread.commandManager().execute({cmd: "copySheet", sheetName: "Sheet1", targetIndex: targetIndex, newName: "Sheet1 (2)", includeBindingSource: true});
                 */
                var copySheet: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, targetIndex: number, newName: string, includeBindingSource: boolean}): void};
                /**
                 * Represents the command used to cut the selected item text to the Clipboard.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 ** options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var cut: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command for deleting the floating objects.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var deleteFloatingObjects: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): boolean};
                /**
                 * Represents the command used to drag and copy the floating objects on the sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.floatingObjects {Array} The names array of floating objects.<br />
                 * options.offsetX The horizontal offset.<br />
                 * options.offsetY The vertical offset.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise <c>false</c>.
                 */
                var dragCopyFloatingObjects: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, floatingObjects: string[], offsetX: number, offsetY: number}, isUndo: boolean): boolean};
                /**
                 * Represents the command used to drag a range and drop it onto another range on the worksheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * commandOptions {Object} The options of the operation.<br />
                 * commandOptions.sheetName {string} The sheet name.<br />
                 * commandOptions.fromRow {number} The source row index for the drag drop.<br />
                 * commandOptions.fromColumn {number} The source column index for the drag drop.<br />
                 * commandOptions.toRow {number} The destination row index for the drag drop.<br />
                 * commandOptions.toColumn {number} The destination column index for the drag drop.<br />
                 * commandOptions.rowCount {number} The row count for the drag drop.<br />
                 * commandOptions.columnCount {number} The column count for the drag drop.<br />
                 * commandOptions.copy {boolean} If set to <c>true</c> copy; otherwise, cut if <c>false</c>.<br />
                 * commandOptions.insert {boolean} If set to <c>true</c> inserts the drag data in the drop row or column.<br />
                 * commandOptions.option {GCTYPE.Spread.Sheets.CopyToOptions} Indicates the content type to drag and drop.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * spread.options.allowUndo = true;
                 * spread.commandManager().execute({cmd: "dragDrop",  sheetName: "Sheet1", fromRow:2, fromColumn:1, toRow:12, toColumn:2, rowCount:2, columnCount:2, copy: true, insert: false, option: GCTYPE.Spread.Sheets.CopyToOptions.value});
                 */
                var dragDrop: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, fromRow: number, fromColumn: number, toRow: number, toColumn: number, rowCount: number, columnCount: number, copy: boolean, insert: boolean, option: GCTYPE.Spread.Sheets.CopyToOptions}, isUndo: boolean): boolean};
                /**
                 * Represents the command used to apply a new value to a cell on the worksheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.row {number} The row index of the cell.<br />
                 * options.col {number} The column index of the cell.<br />
                 * options.newValue {Object} The new value of the cell.<br />
                 * options.autoFormat {boolean} Whether to format the new value automatically.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var editCell: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, row: number, col: number, newValue: any, autoFormat: boolean}, isUndo: boolean): any};
                /**
                 * Represents the command to expand or collapse a column range group.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.index {number} The outline summary index.<br />
                 * options.level {number} The outline level.<br />
                 * options.collapsed {boolean} Whether to make the outline collapsed or expanded.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var expandColumnOutline: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, index: number, level: number, collapsed: boolean}, isUndo: boolean): boolean};
                /**
                 * Represents the command used to expand or collapse column range groups on the same level.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.level {number} The outline level.<br />
                 * isUndo {boolean} <c>true</c> if this an undo operation; otherwise, <c>false</c>.
                 */
                var expandColumnOutlineForLevel: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, level: number}, isUndo: boolean): boolean};
                /**
                 * Represents the command to expand or collapse a row range group.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.index {number} The outline summary index.<br />
                 * options.level {number} The outline level.<br />
                 * options.collapsed {boolean} Whether to make the outline collapsed or expanded.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var expandRowOutline: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, index: number, level: number, collapsed: boolean}, isUndo: boolean): boolean};
                /**
                 * Represents the command used to expand or collapse row range groups on the same level.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.level {number} The outline level.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var expandRowOutlineForLevel: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, level: number}, isUndo: boolean): boolean};
                /**
                 * Represents the command used to drag and fill a range on the sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.startRange {GCTYPE.Spread.Sheets.Range} The start range.<br />
                 * options.fillRange {GCTYPE.Spread.Sheets.Range} The fill range.<br />
                 * options.autoFillType {GCTYPE.Spread.Sheets.Fill.AutoFillType} The auto fill type.<br />
                 * options.fillDirection {GCTYPE.Spread.Sheets.Fill.FillDirection} The fill direction.<br />
                 * isUndo {boolean} <c>true</c> if an undo operation; otherwise, <c>false</c>.
                 * @example
                 * spread.options.allowUndo = true;
                 * var srange = new GCTYPE.Spread.Sheets.Range(10, 5, 1, 1);
                 * var frange = new GCTYPE.Spread.Sheets.Range(11, 5, 5, 1);
                 * spread.commandManager().execute({cmd: "fill", sheetName: "Sheet1", startRange: srange, fillRange: frange, autoFillType: GCTYPE.Spread.Sheets.Fill.AutoFillType.fillSeries, fillDirection: GCTYPE.Spread.Sheets.Fill.FillDirection.down });
                 */
                var fill: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, startRange: GCTYPE.Spread.Sheets.Range, fillRange: GCTYPE.Spread.Sheets.Range, autoFillType: GCTYPE.Spread.Sheets.Fill.AutoFillType, fillDirection: GCTYPE.Spread.Sheets.Fill.FillDirection}, isUndo: boolean): boolean};
                /**
                 * Represents the command for moving floating objects.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.floatingObjects {Array} The names array of floating objects.<br />
                 * options.offsetX The horizontal offset.<br />
                 * options.offsetY The vertical offset.
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var moveFloatingObjects: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, floatingObjects: string[], offsetX: number, offsetY: number}, isUndo: boolean): boolean};
                /**
                 * Represents the command used to move sheet.
                 * @param context The context of the operation.
                 * @param options The options of the operation.
                 * The arguments of the execute method are as follows.
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.
                 * options {Object} The options of the operation.
                 * options.sheetName {string} The sheet name.
                 * options.targetIndex {number} The target index.
                 * @example
                 * //This example move a sheet.
                 * spread.commandManager().execute({cmd: "moveSheet", sheetName: "Sheet1", targetIndex: targetIndex});
                 */
                var moveSheet: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, targetIndex: number}): boolean};
                /**
                 * Represents the command used to move the active cell to the next cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example maps the moveToNextCell action.
                 * spread.focus();
                 * spread.commandManager().setShortcutKey('moveToNextCell', GCTYPE.Spread.Commands.Key.a, false, false, false, false); // a
                 */
                var moveToNextCell: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to select the next control if the active cell is the last visible cell; otherwise, move the active cell to the next cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example maps the moveToNextCellThenControl action.
                 * spread.commandManager().setShortcutKey('moveToNextCellThenControl', GCTYPE.Spread.Commands.Key.tab, false, false, false, false); // Tab key
                 * spread.commandManager().setShortcutKey('moveToPreviousCellThenControl', GCTYPE.Spread.Commands.Key.tab, false, true, false, false); // Shift key and Tab key
                 */
                var moveToNextCellThenControl: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to move the active cell to the previous cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the moveToPreviousCell action.
                 * spread.commandManager().setShortcutKey('moveToPreviousCell', GCTYPE.Spread.Commands.Key.a, false, false, false, false); // a
                 */
                var moveToPreviousCell: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to select the previous control if the active cell is the first visible cell; otherwise, move the active cell to the previous cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example maps the moveToPreviousCellThenControl action.
                 * spread.commandManager().setShortcutKey('moveToNextCellThenControl', GCTYPE.Spread.Commands.Key.tab, false, false, false, false); // Tab key
                 * spread.commandManager().setShortcutKey('moveToPreviousCellThenControl', GCTYPE.Spread.Commands.Key.tab, false, true, false, false); // Shift key and Tab key
                 */
                var moveToPreviousCellThenControl: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to move the active cell to the last row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example maps the navigationBottom action to the Tab key.
                 * spread.commandManager().setShortcutKey('navigationDown', GCTYPE.Spread.Commands.Key.tab, false, false, false, false); // Tab key
                 * spread.commandManager().setShortcutKey('navigationBottom', GCTYPE.Spread.Commands.Key.tab, false, true, false, false); // Shift key and Tab key
                 */
                var navigationBottom: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to move the active cell to the next row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example maps the navigationDown key.
                 * spread.commandManager().setShortcutKey('navigationDown', GCTYPE.Spread.Commands.Key.tab, false, false, false, false); // Tab key
                 * spread.commandManager().setShortcutKey('navigationBottom', GCTYPE.Spread.Commands.Key.tab, false, true, false, false); // Shift key and Tab key
                 */
                var navigationDown: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to move the active cell to the last column.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationEnd method.
                 * spread.commandManager().setShortcutKey('navigationEnd', GCTYPE.Spread.Commands.Key.tab,  false, false, false, false); // Tab key
                 */
                var navigationEnd: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to move the active cell to the last column without regard to frozen trailing columns.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationEnd2 action.
                 * spread.commandManager().setShortcutKey("navigationEnd2", GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationEnd2: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to move the active cell to the first cell in the sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationFirst action.
                 * spread.commandManager().setShortcutKey("navigationFirst", GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationFirst: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to move the active cell to the first column.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationHome action.
                 * spread.commandManager().setShortcutKey("navigationHome", GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationHome: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to move the active cell to the first column without regard to frozen columns.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 ** options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationHome2 action.
                 * spread.commandManager().setShortcutKey("navigationHome2", GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationHome2: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to move the active cell to the last cell in the sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationLast action.
                 * spread.commandManager().setShortcutKey("navigationLast", GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationLast: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to move the active cell to the previous column.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationLeft action.
                 * spread.commandManager().setShortcutKey("navigationLeft", GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationLeft: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to move the active sheet to the next sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationNextSheet action.
                 * spread.commandManager().setShortcutKey("navigationNextSheet", GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationNextSheet: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to move the active cell down one page of rows.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationPageDown action.
                 * spread.commandManager().setShortcutKey("navigationPageDown", GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationPageDown: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to move the active cell up one page of rows.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationPageUp action.
                 * spread.commandManager().setShortcutKey("navigationPageUp", GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationPageUp: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to move the active sheet to the previous sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationPreviousSheet action.
                 * spread.commandManager().setShortcutKey("navigationNextSheet", GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 * spread.commandManager().setShortcutKey("navigationPreviousSheet", GCTYPE.Spread.Commands.Key.c, false, false, false, false);
                 */
                var navigationPreviousSheet: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to move the active cell to the next column.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationRight action.
                 * spread.commandManager().setShortcutKey("navigationRight", GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationRight: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to move the active cell to the first row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the navigationTop action.
                 * spread.commandManager().setShortcutKey("navigationTop", GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var navigationTop: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to move the active cell to the previous row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example maps the navigationUp action to a.
                 * spread.commandManager().setShortcutKey('navigationUp', GCTYPE.Spread.Commands.Key.a, false, false, false, false); // a
                 */
                var navigationUp: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to open a calculator picker in specified cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.sheetArea {GCTYPE.Spread.Sheets.SheetArea} The sheet area.<br />
                 * options.row {number} The rowIndex.<br />
                 * options.col {number} The columnIndex.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var openCalculator: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, row: number, col: number, sheetArea: GCTYPE.Spread.Sheets.SheetArea}, isUndo: boolean): any};
                /**
                 * Represents the command used to open a color picker in specified cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.sheetArea {GCTYPE.Spread.Sheets.SheetArea} The sheet area.<br />
                 * options.row {number} The rowIndex.<br />
                 * options.col {number} The columnIndex.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var openColorPicker: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, row: number, col: number, sheetArea: GCTYPE.Spread.Sheets.SheetArea}, isUndo: boolean): any};
                /**
                 * Represents the command used to open a datetime picker in specified cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.sheetArea {GCTYPE.Spread.Sheets.SheetArea} The sheet area.<br />
                 * options.row {number} The rowIndex.<br />
                 * options.col {number} The columnIndex.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var openDateTimePicker: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, row: number, col: number, sheetArea: GCTYPE.Spread.Sheets.SheetArea}, isUndo: boolean): any};
                /**
                 * Represents the command used to open a list picker in specified cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.sheetArea {GCTYPE.Spread.Sheets.SheetArea} The sheet area.<br />
                 * options.row {number} The rowIndex.<br />
                 * options.col {number} The columnIndex.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var openList: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, row: number, col: number, sheetArea: GCTYPE.Spread.Sheets.SheetArea}, isUndo: boolean): any};
                /**
                 * Represents the command used to open a month picker in specified cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.sheetArea {GCTYPE.Spread.Sheets.SheetArea} The sheet area.<br />
                 * options.row {number} The rowIndex.<br />
                 * options.col {number} The columnIndex.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var openMonthPicker: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, row: number, col: number, sheetArea: GCTYPE.Spread.Sheets.SheetArea}, isUndo: boolean): any};
                /**
                 * Represents the command used to open a multi-column list picker in specified cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.sheetArea {GCTYPE.Spread.Sheets.SheetArea} The sheet area.<br />
                 * options.row {number} The rowIndex.<br />
                 * options.col {number} The columnIndex.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var openMultiColumn: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, row: number, col: number, sheetArea: GCTYPE.Spread.Sheets.SheetArea}, isUndo: boolean): any};
                /**
                 * Represents the command used to open a slider picker in specified cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.sheetArea {GCTYPE.Spread.Sheets.SheetArea} The sheet area.<br />
                 * options.row {number} The rowIndex.<br />
                 * options.col {number} The columnIndex.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var openSlider: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, row: number, col: number, sheetArea: GCTYPE.Spread.Sheets.SheetArea}, isUndo: boolean): any};
                /**
                 * Represents the command used to open a time picker in specified cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.sheetArea {GCTYPE.Spread.Sheets.SheetArea} The sheet area.<br />
                 * options.row {number} The rowIndex.<br />
                 * options.col {number} The columnIndex.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var openTimePicker: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, row: number, col: number, sheetArea: GCTYPE.Spread.Sheets.SheetArea}, isUndo: boolean): any};
                /**
                 * Represents the command used to open the url of the hyperlink cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.url {string} The url string.<br />
                 * options.target {HyperlinkTargetType} The target type, it's default is blank.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var openUrl: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: { sheetName: string, url: string, target?: GCTYPE.Spread.Sheets.Hyperlink.HyperlinkTargetType }, isUndo: boolean): any};
                /**
                 * Represents the command used to open a workflow list picker in specified cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.sheetArea {GCTYPE.Spread.Sheets.SheetArea} The sheet area.<br />
                 * options.row {number} The rowIndex.<br />
                 * options.col {number} The columnIndex.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var openWorkflowList: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, row: number, col: number, sheetArea: GCTYPE.Spread.Sheets.SheetArea}, isUndo: boolean): any};
                /**
                 * Represents the command for grouping a column outline (range group) on a sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.index {number} The outline starting index.<br />
                 * options.count {number} The number of rows or columns to group or ungroup in the outline.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example creates a group.
                 * spread.options.allowUndo = true;
                 * spread.commandManager().execute({cmd: "outlineColumn", sheetName: "Sheet1", index: 3, count: 5});
                 */
                var outlineColumn: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, index: number, count: number}, isUndo: boolean): boolean};
                /**
                 * Represents the command for grouping a row outline (range group) on a sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.index {number} The outline starting index.<br />
                 * options.count {number} The number of rows or columns to group or ungroup in the outline.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example undoes an action.
                 * spread.options.allowUndo = true;
                 * spread.commandManager().execute({cmd: "outlineRow", sheetName: "Sheet1", index: 3, count: 5});
                 */
                var outlineRow: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, index: number, count: number}, isUndo: boolean): boolean};
                /**
                 * Represents the command used to paste the selected items from the Clipboard to the current sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.shiftCells {GCTYPE.Spread.Sheets.InsertShiftCell} The inserted data needs to be moved in the direction.<br />
                 * options.pasteOption {GCTYPE.Spread.Sheets.ClipboardPasteOptions} The option of paste.
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var paste: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, shiftCells?: GCTYPE.Spread.Sheets.InsertShiftCell}): any};
                /**
                 * Represents the command for pasting the floating objects on the sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var pasteFloatingObjects: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): boolean};
                /**
                 * Represents the command used to perform a redo of the most recently undone edit or action.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the undo or redo action.
                 * $("#button1").click(function () {
                 *    if(spread.undoManager().canUndo()){
                 *        spread.undoManager().undo();
                 *    }
                 * });
                 * $("#button2").click(function () {
                 *     if(spread.undoManager().canRedo()){
                 *         spread.undoManager().redo();
                 *     }
                 * });
                 */
                var redo: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command for ungrouping a column outline (range group) on a sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.index {number} The outline starting index.<br />
                 * options.count {number} The number of rows or columns to group or ungroup in the outline.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var removeColumnOutline: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, index: number, count: number}, isUndo: boolean): boolean};
                /**
                 * Represents the command for ungrouping a row outline (range group) on a sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.index {number} The outline starting index.<br />
                 * options.count {number} The number of rows or columns to group or ungroup in the outline.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var removeRowOutline: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, index: number, count: number}, isUndo: boolean): boolean};
                /**
                 * Represents the command used to rename a worksheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.name {string} The sheet's new name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example renames a sheet.
                 * spread.commandManager().execute({cmd: "renameSheet", sheetName: "Sheet1", name: "SheetName"});
                 */
                var renameSheet: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, name: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to resize the column on a worksheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.columns {Array} The resize columns; each item is an object which has firstCol and lastCol.<br />
                 * options.size {number} The size of the column that is being resized.<br />
                 * options.rowHeader {boolean} Whether the column being resized is in the row header area.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var resizeColumn: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, columns: Object[], size: number, rowHeader: boolean}, isUndo: boolean): any};
                /**
                 * Represents the command for resizing floating objects.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.floatingObjects {Array} The names array of floating objects.<br />
                 * options.offsetX The offset left.<br />
                 * options.offsetY The offset top.<br />
                 * options.offsetWidth The offset width.<br />
                 * options.offsetHeight The offset height.
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var resizeFloatingObjects: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, floatingObjects: string[], offsetX: number, offsetY: number, offsetWidth: number, offsetHeight: number}, isUndo: boolean): boolean};
                /**
                 * Represents the command used to resize the row on a worksheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.rows {Array} The resize rows; each item is an object which has firstRow and lastRow.<br />
                 * options.size {number} The size of the row that is being resized.<br />
                 * options.columnHeader {boolean} Whether the row being resized is in the column header area.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var resizeRow: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, rows: Object[], size: number, columnHeader: boolean}, isUndo: boolean): any};
                /**
                 * Represents the command used to extend the selection to the last row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionBottom action.
                 * spread.commandManager().setShortcutKey('selectionBottom', GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionBottom: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to extend the selection down one row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionDown action.
                 * spread.commandManager().setShortcutKey('selectionDown', GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionDown: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to extend the selection to the last column.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionEnd action.
                 * spread.focus();
                 * spread.commandManager().setShortcutKey('selectionEnd', GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionEnd: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to extend the selection to the first cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionFirst action.
                 * spread.focus();
                 * spread.commandManager().setShortcutKey('selectionFirst', GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionFirst: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to extend the selection to the first column.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionHome action.
                 * spread.focus();
                 * spread.commandManager().setShortcutKey('selectionHome', GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionHome: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to extend the selection to the last cell.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionLast action.
                 * spread.focus();
                 * spread.commandManager().setShortcutKey('selectionLast', GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionLast: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to extend the selection one column to the left.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionLeft action.
                 * spread.commandManager().setShortcutKey('selectionLeft', GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionLeft: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}, isUndo: boolean): any};
                /**
                 * Represents the command used to extend the selection down to include one page of rows.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionPageDown action.
                 * spread.commandManager().setShortcutKey('selectionPageDown', GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionPageDown: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to extend the selection up to include one page of rows.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionPageUp action.
                 * spread.commandManager().setShortcutKey('selectionPageUp', GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionPageUp: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to extend the selection one column to the right.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionRight action.
                 * spread.commandManager().setShortcutKey("selectionRight", GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionRight: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to extend the selection to the first row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionTop action.
                 * spread.commandManager().setShortcutKey("selectionTop", GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionTop: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to extend the selection up one row.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the selectionUp action.
                 * spread.commandManager().setShortcutKey("selectionUp", GCTYPE.Spread.Commands.Key.a, false, false, false, false);
                 */
                var selectionUp: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to select the next control.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example maps the selectNextControl action to the Tab key.
                 * spread.commandManager().setShortcutKey('selectNextControl', GCTYPE.Spread.Commands.Key.tab, false, false, false, false); // Tab key
                 * spread.commandManager().setShortcutKey('selectPreviousControl', GCTYPE.Spread.Commands.Key.tab, false, true, false, false); // Shift key and Tab key
                 */
                var selectNextControl: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to select the previous control.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 ** options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example maps the selectPreviousControl action to the Shift + Tab key combination.
                 * spread.commandManager().setShortcutKey('selectNextControl', GCTYPE.Spread.Commands.Key.tab, false, false, false, false); // Tab key
                 * spread.commandManager().setShortcutKey('selectPreviousControl', GCTYPE.Spread.Commands.Key.tab, false, true, false, false); // Shift key and Tab key
                 */
                var selectPreviousControl: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to split resize the column on a worksheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.columns {Array} The resize columns; each item is an object which has firstCol and lastCol.<br />
                 * options.size {number} The size of the column that is being resized.<br />
                 * options.rowHeader {boolean} Whether the column being resized is in the row header area.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var splitResizeColumn: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: { sheetName: string, columns: Object[], size: number, rowHeader: boolean }, isUndo: boolean): any};
                /**
                 * Represents the command used to split resize the row on a worksheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.rows {Array} The resize rows; each item is an object which has firstRow and lastRow.<br />
                 * options.size {number} The size of the row that is being resized.<br />
                 * options.columnHeader {boolean} Whether the row being resized is in the column header area.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var splitResizeRow: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: { sheetName: string, rows: Object[], size: number, columnHeader: boolean }, isUndo: boolean): any};
                /**
                 * Represents the command used to delete columns for table.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.tableName {string} The table name.<br />
                 * options.col {number} The index of the starting column to delete, the col index is based on table index.<br />
                 * options.count {number} The number of columns to delete.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var tableDeleteColumns: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, tableName: string, col: number, count: number}, isUndo: boolean): boolean};
                /**
                 * Represents the command used to delete rows for table.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.tableName {string} The table name.<br />
                 * options.row {number} The index of the starting row to delete, the row index is based on table index.<br />
                 * options.count {number} The number of rows to delete.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var tableDeleteRows: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, tableName: string, row: number, count: number}, isUndo: boolean): boolean};
                /**
                 * Represents the command used to insert columns for table.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.tableName {string} The table name.<br />
                 * options.col {number} The index of the starting column to insert, the col index is based on table index.<br />
                 * options.count {number} The number of columns to insert.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var tableInsertColumns: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, tableName: string, col: number, count: number}, isUndo: boolean): boolean};
                /**
                 * Represents the command used to insert rows for table.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.tableName {string} The table name.<br />
                 * options.row {number} The index of the starting row to insert, the row index is based on table index.<br />
                 * options.count {number} The number of rows to insert.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var tableInsertRows: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, tableName: string, row: number, count: number}, isUndo: boolean): boolean};
                /**
                 * Represents the command used to resize table.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.tableName {string} The table name.<br />
                 * options.resizeToRange {GCTYPE.Spread.Sheets.Range} The resized table range.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var tableResize: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, tableName: string, resizeToRange: GCTYPE.Spread.Sheets.Range}, isUndo: boolean): boolean};
                /**
                 * Represents the command used to perform an undo of the most recent edit or action.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 * @example
                 * //This example uses the undo or redo action.
                 * $("#button1").click(function () {
                 *      if(spread.undoManager().canUndo()){
                 *          spread.undoManager().undo();
                 *      }
                 *  });
                 * $("#button2").click(function() {
                 *      if(spread.undoManager().canRedo()){
                 *          spread.undoManager().redo();
                 *      }
                 * });
                 */
                var undo: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string}): any};
                /**
                 * Represents the command used to zoom the sheet.
                 * @property {boolean} canUndo - indicates whether the command supports undo and redo operations.
                 * @property {function} execute - performs an execute or undo operation.<br />
                 * The arguments of the execute method are as follows.<br />
                 * context {GCTYPE.Spread.Sheets.Workbook} The context of the operation.<br />
                 * options {Object} The options of the operation.<br />
                 * options.sheetName {string} The sheet name.<br />
                 * options.zoomFactor {number} The zoom factor.<br />
                 * isUndo {boolean} <c>true</c> if this is an undo operation; otherwise, <c>false</c>.
                 */
                var zoom: { canUndo: boolean, execute(context: GCTYPE.Spread.Sheets.Workbook, options: {sheetName: string, zoomFactor: number}, isUndo: boolean): any};
                /**
                 * Ends a transaction. During the transaction, the changes of the data model will be saved.
                 * @param {GCTYPE.Spread.Sheets.Workbook} context The context of the operation.
                 * @param {Object} options The options of the operation.<br />
                 *  @param  {string|Array<string>} [options.sheetName] The sheet name. If the current transaction need change multiple worksheets, the sheetName could be a string Array.
                 */
                function endTransaction(context: GCTYPE.Spread.Sheets.Workbook,  options: any): void;
                /**
                 * Starts a transaction. During the transaction, the changes of the data model will be saved.
                 * @param {GCTYPE.Spread.Sheets.Workbook} context The context of the operation.
                 * @param {Object} options The options of the operation.
                 * @param {string|Array<string>} [options.sheetName] The sheet name. If the current transaction need change multiple worksheets, the sheetName could be a string Array.
                 */
                function startTransaction(context: GCTYPE.Spread.Sheets.Workbook,  options: any): void;
                /**
                 * Undo the changes made in a transaction.
                 * @param {GCTYPE.Spread.Sheets.Workbook} context The context of the operation.
                 * @param {Object} options The options of the operation.<br />
                 * @param {string|Array<string>} [options.sheetName] The sheet name. If the current transaction need change multiple worksheets, the sheetName could be a string Array.
                 */
                function undoTransaction(context: GCTYPE.Spread.Sheets.Workbook,  options: any): void;
            }

            module Comments{
                /**
                 * Defines the comment state.
                 * @enum {number}
                 * @example
                 * //This example gets the comment state.
                 * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                 * comment.text("new comment!");
                 * comment.backColor("yellow");
                 * comment.foreColor("green");
                 * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                 * activeSheet.getCell(5,5).comment(comment);
                 * alert(comment.commentState());
                 */
                export enum CommentState{
                    /**
                     * Specifies that the comment is in an active state.
                     */
                    active= 1,
                    /**
                     *Specifies that the comment is in an editing state.
                     */
                    edit= 2,
                    /**
                     * Specifies that the comment is in a normal state.
                     */
                    normal= 3
                }

                /**
                 * Defines when the comment is displayed.
                 * @enum {number}
                 * @example
                 * //This example uses the DisplayMode enumeration.
                 * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                 * comment.text("new comment!");
                 * comment.backColor("yellow");
                 * comment.foreColor("green");
                 * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                 * activeSheet.getCell(5,5).comment(comment);
                 */
                export enum DisplayMode{
                    /**
                     *  Specifies that the comment is always displayed.
                     */
                    alwaysShown= 1,
                    /**
                     *  Specifies that the comment is displayed only when the pointer hovers over the comment's owner cell.
                     */
                    hoverShown= 2
                }


                export class Comment{
                    /**
                     * Represents a comment.
                     * @class
                     * @param {string} [text] The text of the comment.
                     * @example
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.autoSize(true);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    constructor(text?: string);
                    /**
                     * Gets or sets whether the comment automatically sizes based on its content.
                     * @param {boolean} value Whether the comment automatically sizes.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns whether the comment automatically sizes; otherwise, returns the comment.
                     * @example
                     * //This example uses the autoSize method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.autoSize(true);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    autoSize(value?: boolean): any;
                    /**
                     * Gets or sets the background color of the comment.
                     * @param {string} value The background color of the comment.
                     * @returns {string | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the background color of the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the backColor method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    backColor(value?: string): any;
                    /**
                     * Gets or sets the border color for the comment.
                     * @param {string} value The border color for the comment.
                     * @returns {string | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the border color for the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the borderColor method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.borderWidth(2);
                     * comment.borderStyle("dotted");
                     * comment.borderColor("red");
                     * activeSheet.getCell(5,5).comment(comment);
                     * activeSheet.suspendPaint();
                     * activeSheet.resumePaint();
                     */
                    borderColor(value?: string): any;
                    /**
                     * Gets or sets the border style for the comment.
                     * @param {string} value The border style for the comment.
                     * @returns {string | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the border style for the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the borderStyle method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.borderWidth(2);
                     * comment.borderStyle("dotted");
                     * comment.borderColor("red");
                     * activeSheet.getCell(5,5).comment(comment);
                     * activeSheet.suspendPaint();
                     * activeSheet.resumePaint();
                     */
                    borderStyle(value?: string): any;
                    /**
                     * Gets or sets the border width for the comment.
                     * @param {number} value The border width for the comment.
                     * @returns {number | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the border width for the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the borderWidth method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.borderWidth(2);
                     * comment.borderStyle("dotted");
                     * comment.borderColor("red");
                     * activeSheet.getCell(5,5).comment(comment);
                     * activeSheet.suspendPaint();
                     * activeSheet.resumePaint();
                     */
                    borderWidth(value?: number): any;
                    /**
                     * Gets or sets the state of the comment.
                     * @param {GCTYPE.Spread.Sheets.Comments.CommentState} value The state of the comment.
                     * @returns {GCTYPE.Spread.Sheets.Comments.CommentState | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the state of the comment; otherwise, returns the comment.
                     * @example
                     * //This example gets the comment state.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * activeSheet.getCell(5,5).comment(comment);
                     * alert(comment.commentState());
                     */
                    commentState(value?: GCTYPE.Spread.Sheets.Comments.CommentState): any;
                    /**
                     * Gets or sets the display mode for the comment.
                     * @param {GCTYPE.Spread.Sheets.Comments.DisplayMode} value The display mode for the comment.
                     * @returns {GCTYPE.Spread.Sheets.Comments.DisplayMode | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the display mode for the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the displayMode method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    displayMode(value?: GCTYPE.Spread.Sheets.Comments.DisplayMode): any;
                    /**
                     * Gets or sets whether the comment dynamically moves.
                     * @param {boolean} value Whether the comment dynamically moves.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns whether the comment dynamically moves; otherwise, returns the comment.
                     * @example
                     * //This example uses the dynamicMove method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.dynamicMove(true);
                     * comment.dynamicSize(true);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    dynamicMove(value?: boolean): any;
                    /**
                     * Gets or sets whether the comment is dynamically sized.
                     * @param {boolean} value Whether the comment is dynamically sized.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns whether the comment is dynamically sized; otherwise, returns the comment.
                     * @example
                     * //This example uses the dynamicSize method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.dynamicMove(true);
                     * comment.dynamicSize(true);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    dynamicSize(value?: boolean): any;
                    /**
                     * Gets or sets the font family for the comment.
                     * @param {string} value The font family for the comment.
                     * @returns {string | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the font family for the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the fontFamily method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.fontFamily("Comic Sans MS");
                     * comment.fontSize("10pt");
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    fontFamily(value?: string): any;
                    /**
                     * Gets or sets the font size for the comment. Valid value is numbers followed by "pt" (required), such as "12pt".
                     * @param {string} value The font size for the comment.
                     * @returns {string | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the font size for the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the fontSize method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.fontFamily("Comic Sans MS");
                     * comment.fontSize("10pt");
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    fontSize(value?: string): any;
                    /**
                     * Gets or sets the font style of the comment.
                     * @param {string} value The font style of the comment.
                     * @returns {string | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the font style of the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the fontStyle method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.fontFamily("Comic Sans MS");
                     * comment.fontStyle("normal");
                     * comment.fontWeight("normal");
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    fontStyle(value?: string): any;
                    /**
                     * Gets or sets the font weight for the comment.
                     * @param {string} value The font weight for the comment.
                     * @returns {string | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the font weight for the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the fontWeight method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.fontFamily("Comic Sans MS");
                     * comment.fontStyle("normal");
                     * comment.fontWeight("normal");
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    fontWeight(value?: string): any;
                    /**
                     * Gets or sets the text color for the comment.
                     * @param {string} value The text color for the comment.
                     * @returns {string | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the text color for the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the foreColor method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    foreColor(value?: string): any;
                    /**
                     * Gets or sets the height of the comment.
                     * @param {number} value The height of the comment.
                     * @returns {number | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the height of the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the height method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.height(50);
                     * comment.width(90);
                     * activeSheet.getCell(5,5).comment(comment);
                     * activeSheet.suspendPaint();
                     * activeSheet.resumePaint();
                     */
                    height(value?: number): any;
                    /**
                     * Gets or sets the horizontal alignment of the comment.
                     * @param {GCTYPE.Spread.Sheets.HorizontalAlign} value The horizontal alignment of the comment.
                     * @returns {GCTYPE.Spread.Sheets.HorizontalAlign | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the horizontal alignment of the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the horizontalAlign method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.horizontalAlign(GCTYPE.Spread.Sheets.HorizontalAlign.center);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    horizontalAlign(value?: GCTYPE.Spread.Sheets.HorizontalAlign): any;
                    /**
                     * Gets or sets the indicatorColor for the comment.
                     * @param {string} value The indicatorColor for the comment.
                     * @returns {string | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the color for the commentAdorner; otherwise, returns the comment.
                     * @example
                     * //This example uses the indicatorColor method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * var color1 = "red";
                     * var color2 = "#FFFFFF";
                     * var color2 = "rgba(255, 255, 255, 0.01)";
                     * comment.indicatorColor(color1);
                     * activeSheet.comments.add(5, 5, comment);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    indicatorColor(value?: string): any;
                    /**
                     * Gets or sets the indicatorColor for the comment.
                     * @param {number} value The indicatorColor for the comment.
                     * @returns {number | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the size for the commentAdorner; otherwise, returns the comment.
                     * @example
                     * //This example uses the indicatorColor method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.indicatorSize(6);
                     * activeSheet.comments.add(5, 5, comment);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    indicatorSize(value?: number): any;
                    /**
                     * Gets or sets the location of the comment.
                     * @param {GCTYPE.Spread.Sheets.Point} value The location of the comment.
                     * @returns {GCTYPE.Spread.Sheets.Point | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the location of the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the location method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.location(new GCTYPE.Spread.Sheets.Point(10, 10));
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    location(value?: GCTYPE.Spread.Sheets.Point): any;
                    /**
                     * Gets or sets the locked setting for the comment.
                     * @param {boolean} value The locked setting for the comment.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the locked setting for the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the locked method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.lockText(false);
                     * comment.locked(false);
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * activeSheet.options.isProtected = true;
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    locked(value?: boolean): any;
                    /**
                     * Gets or sets the locked text for the comment.
                     * @param {boolean} value The locked text for the comment.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the locked text for the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the lockText method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.lockText(false);
                     * comment.locked(false);
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * activeSheet.options.isProtected = true;
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    lockText(value?: boolean): any;
                    /**
                     * Gets or sets the opacity of the comment.
                     * @param {number} value The opacity of the comment.
                     * @returns {number | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the opacity of the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the opacity.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.opacity(10);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    opacity(value?: number): any;
                    /**
                     * Gets or sets the padding for the comment.
                     * @param {GCTYPE.Spread.Sheets.Comments.Padding} value The padding for the comment.
                     * @returns {GCTYPE.Spread.Sheets.Comments.Padding | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the padding for the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the padding method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.padding(new GCTYPE.Spread.Sheets.Comments.Padding(2, 2, 2, 2));
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    padding(value?: GCTYPE.Spread.Sheets.Comments.Padding): any;
                    /**
                     * Gets or sets whether the comment displays a shadow.
                     * @param {boolean} value Whether the comment displays a shadow.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns whether the comment displays a shadow; otherwise, returns the comment.
                     * @example
                     * //This example uses the showShadow method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.borderWidth(2);
                     * comment.borderStyle("dotted");
                     * comment.borderColor("red");
                     * comment.showShadow(true);
                     * activeSheet.getCell(5,5).comment(comment);
                     * activeSheet.suspendPaint();
                     * activeSheet.resumePaint();
                     */
                    showShadow(value?: boolean): any;
                    /**
                     * Gets or sets the text of the comment.
                     * @param {string} value The text of the comment.
                     * @returns {string | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the text of the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the text method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * activeSheet.getCell(5,5).comment(comment);
                     */
                    text(value?: string): any;
                    /**
                     * Gets or sets the text decoration for the comment.
                     * @param {GCTYPE.Spread.Sheets.TextDecorationType} value The text decoration for the comment.
                     * @returns {GCTYPE.Spread.Sheets.TextDecorationType | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the text decoration for the comment; otherwise, returns the comment.
                     * @example
                     * //This example uses the textDecoration method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.textDecoration(GCTYPE.Spread.Sheets.TextDecorationType.underline);
                     * activeSheet.getCell(5,5).comment(comment);
                     * activeSheet.suspendPaint();
                     * activeSheet.resumePaint();
                     */
                    textDecoration(value?: GCTYPE.Spread.Sheets.TextDecorationType): any;
                    /**
                     * Gets or sets the width of the comment.
                     * @param {number} value The width of the comment.
                     * @returns {number | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the width of the comment; otherwise, returns the comment.
                     * @example
                     * //This example sets the width method.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * comment.height(50);
                     * comment.width(90);
                     * activeSheet.getCell(5,5).comment(comment);
                     * activeSheet.suspendPaint();
                     * activeSheet.resumePaint();
                     */
                    width(value?: number): any;
                    /**
                     * Gets or sets the z-index of the comment.
                     * @param {number} value The z-index of the comment.
                     * @returns {number | GCTYPE.Spread.Sheets.Comments.Comment} If no value is set, returns the z-index of the comment; otherwise, returns the comment.
                     * @example
                     * //This example gets the index.
                     * var comment = new GCTYPE.Spread.Sheets.Comments.Comment();
                     * comment.text("new comment!");
                     * comment.backColor("yellow");
                     * comment.foreColor("green");
                     * comment.displayMode(GCTYPE.Spread.Sheets.Comments.DisplayMode.alwaysShown);
                     * activeSheet.getCell(5,5).comment(comment);
                     * alert(comment.zIndex());
                     */
                    zIndex(value?: number): any;
                }

                export class CommentManager{
                    /**
                     * Represents a comment manager that can manage all comments in a sheet.
                     * @class
                     * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The worksheet.
                     */
                    constructor(sheet: GCTYPE.Spread.Sheets.Worksheet);
                    /**
                     * Adds a comment to the cell for the indicated row and column.
                     * @param {number} row The row index of the cell.
                     * @param {number} col The column index of the cell.
                     * @param {string} text The text of the comment.
                     * @returns {GCTYPE.Spread.Sheets.Comments.Comment} The comment that has been added to the cell.
                     */
                    add(row: number,  col: number,  text: string): GCTYPE.Spread.Sheets.Comments.Comment;
                    /**
                     * Gets all comments in the sheet.
                     * @returns {Array.<GCTYPE.Spread.Sheets.Comments.Comment>}
                     */
                    all(): GCTYPE.Spread.Sheets.Comments.Comment[];
                    /**
                     * Clears all of the comments in the indicated range on the sheet. When the range is not specified, it clears all the comments in the sheet.
                     * @param {GCTYPE.Spread.Sheets.Range} range The range that you want clear all comments from.
                     */
                    clear(range: GCTYPE.Spread.Sheets.Range): void;
                    /**
                     * Gets the comment in the cell with the indicated row and column.
                     * @param {number} row The row index of the cell.
                     * @param {number} col The column index of the cell.
                     * @returns {GCTYPE.Spread.Sheets.Comments.Comment} The comment in the indicated cell.
                     */
                    get(row: number,  col: number): GCTYPE.Spread.Sheets.Comments.Comment;
                    /**
                     *Removes the comment from the cell for the indicated row and column.
                     * @param {number} row The row index of the cell.
                     * @param {number} col The column index of the cell.
                     */
                    remove(row: number,  col: number): void;
                }

                export class Padding{
                    /**
                     * Represents the padding information.
                     * @class
                     * @param {number} top The top padding.
                     * @param {number} right The right padding.
                     * @param {number} bottom The bottom padding.
                     * @param {number} left The left padding.
                     */
                    constructor(top?: number,  right?: number,  bottom?: number,  left?: number);
                }
            }

            module ConditionalFormatting{

                export interface IIconInfo{
                    iconSetType:GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType;
                    iconIndex:number;
                }

                /**
                 * Specifies the average condition type.
                 * @enum {number}
                 * @example
                 * //This example creates an average rule.
                 * activeSheet.setValue(0,0, 1,3);
                 * activeSheet.setValue(1,0, 50,3);
                 * activeSheet.setValue(2,0, 100,3);
                 * activeSheet.setValue(3,0, 2,3);
                 * activeSheet.setValue(4,0, 60,3);
                 * activeSheet.setValue(5,0, 90,3);
                 * activeSheet.setValue(6,0, 3,3);
                 * activeSheet.setValue(7,0, 40,3);
                 * activeSheet.setValue(8,0, 70,3);
                 * activeSheet.setValue(9,0, 5,3);
                 * activeSheet.setValue(10,0, 35,3);
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * style.borderLeft =new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderTop = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderRight = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * style.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                 * var rule = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                 * rule.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.averageRule);
                 * rule.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 3)]);
                 * rule.style(style);
                 * rule.type(GCTYPE.Spread.Sheets.ConditionalFormatting.AverageConditionType.above);
                 * activeSheet.conditionalFormats.addRule(rule);
                 */
                export enum AverageConditionType{
                    /** Specifies the above average condition.
                     * @type {number}
                     */
                    above= 0,
                    /** Specifies the below average condition.
                     * @type {number}
                     */
                    below= 1,
                    /** Specifies the above average or equal average condition.
                     * @type {number}
                     */
                    equalOrAbove= 2,
                    /** Specifies the below average or equal average condition.
                     * @type {number}
                     */
                    equalOrBelow= 3,
                    /** Specifies the above standard deviation condition.
                     * @type {number}
                     */
                    above1StdDev= 4,
                    /** Specifies the below standard deviation condition.
                     * @type {number}
                     */
                    below1StdDev= 5,
                    /** Specifies above the two standard deviation condition.
                     * @type {number}
                     */
                    above2StdDev= 6,
                    /** Specifies below the two standard deviation condition.
                     * @type {number}
                     */
                    below2StdDev= 7,
                    /** Specifies above the three standard deviation condition.
                     * @type {number}
                     */
                    above3StdDev= 8,
                    /** Specifies below the three standard deviation condition.
                     * @type {number}
                     */
                    below3StdDev= 9
                }

                /**
                 * Specifies the data bar direction.
                 * @enum {number}
                 * @example
                 * //This example creates a data bar rule.
                 * activeSheet.setValue(0,0,1,3);
                 * activeSheet.setValue(1,0,15,3);
                 * activeSheet.setValue(2,0,25,3);
                 * activeSheet.setValue(3,0,-1,3);
                 * var dataBarRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule();
                 * dataBarRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                 * dataBarRule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * dataBarRule.minValue(-1);
                 * dataBarRule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * dataBarRule.maxValue(40);
                 * dataBarRule.color("green");
                 * dataBarRule.showBorder(true);
                 * dataBarRule.borderColor("orange");
                 * dataBarRule.dataBarDirection(GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                 * dataBarRule.negativeFillColor("yellow");
                 * dataBarRule.useNegativeFillColor(true);
                 * dataBarRule.negativeBorderColor("red");
                 * dataBarRule.useNegativeBorderColor(true);
                 * dataBarRule.axisPosition(GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                 * dataBarRule.axisColor("blue");
                 * dataBarRule.showBarOnly(false);
                 * activeSheet.conditionalFormats.addRule(dataBarRule);
                 */
                export enum BarDirection{
                    /** Specifies whether to display the data bar from left to right.
                     * @type {number}
                     */
                    leftToRight= 0,
                    /** Specifies whether to display the data bar from right to left.
                     * @type {number}
                     */
                    rightToLeft= 1
                }

                /**
                 * Specifies the color compare type.
                 * @enum {number}
                 * @example
                 * //This example filters using colors.
                 * activeSheet.suspendPaint();
                 * var rowFilter = new GCTYPE.Spread.Sheets.Filter.HideRowFilter(new GCTYPE.Spread.Sheets.Range(-1, 0, -1, 1));
                 * activeSheet.rowFilter(rowFilter);
                 * activeSheet.getCell(0, 0).value("A1").backColor("blue");
                 * activeSheet.getCell(1, 0).value("A2").backColor("yellow");
                 * activeSheet.getCell(2, 0).value("A3").backColor("red");
                 * activeSheet.getCell(3, 0).value("A4").backColor("green");
                 * activeSheet.getCell(4, 0).value("A5").backColor("yellow");
                 * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.colorCondition, {compareType: GCTYPE.Spread.Sheets.ConditionalFormatting.ColorCompareType.backgroundColor, expected: "yellow"});
                 * var filter = activeSheet.rowFilter();
                 * filter.addFilterItem(0, nCondition);
                 * filter.filter(0);
                 * activeSheet.resumePaint();
                 */
                export enum ColorCompareType{
                    /** Indicates whether the cell background color is equal to a specified color.
                     * @type {number}
                     */
                    backgroundColor= 0,
                    /** Indicates whether the cell foreground color is equal to a specified color.
                     * @type {number}
                     */
                    foregroundColor= 1
                }

                /**
                 * Specifies the comparison operator.
                 * @enum {number}
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GCTYPE.Spread.Sheets.DataValidation.createDateValidator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between, new Date(2012, 11, 31), new Date(2013, 11, 31));
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Enter a date between 12/31/2012 and 12/31/2013.");
                 * dv.inputTitle("Tip");
                 * activeSheet.getCell(1, -1).validator(dv);
                 */
                export enum ComparisonOperators{
                    /** Determines whether a cell value is equal to the parameter value.
                     * @type {number}
                     */
                    equalsTo= 0,
                    /** Determines whether a cell value is not equal to the parameter value.
                     * @type {number}
                     */
                    notEqualsTo= 1,
                    /** Determines whether a cell value is greater than the parameter value.
                     * @type {number}
                     */
                    greaterThan= 2,
                    /** Determines whether a cell value is greater than or equal to the parameter value.
                     * @type {number}
                     */
                    greaterThanOrEqualsTo= 3,
                    /** Determines whether a cell value is less than the parameter value.
                     * @type {number}
                     */
                    lessThan= 4,
                    /** Determines whether a cell value is less than or equal to the parameter value.
                     * @type {number}
                     */
                    lessThanOrEqualsTo= 5,
                    /** Determines whether a cell value is between the two parameter values.
                     * @type {number}
                     */
                    between= 6,
                    /** Determines whether a cell value is not between the two parameter values.
                     * @type {number}
                     */
                    notBetween= 7
                }

                /**
                 * Specifies the condition type.
                 * @enum {number}
                 */
                export enum ConditionType{
                    /** Specifies the relation condition.
                     * @type {number}
                     */
                    relationCondition= 0,
                    /** Specifies the number condition.
                     * @type {number}
                     */
                    numberCondition= 1,
                    /** Specifies the text condition.
                     * @type {number}
                     */
                    textCondition= 2,
                    /** Specifies the color condition.
                     * @type {number}
                     */
                    colorCondition= 3,
                    /** Specifies the formula condition.
                     * @type {number}
                     */
                    formulaCondition= 4,
                    /** Specifies the date condition.
                     * @type {number}
                     */
                    dateCondition= 5,
                    /** Specifies the dateex condition.
                     * @type {number}
                     */
                    dateExCondition= 6,
                    /** Specifies the text length condition.
                     * @type {number}
                     */
                    textLengthCondition= 7,
                    /** Specifies the top 10 condition.
                     * @type {number}
                     */
                    top10Condition= 8,
                    /** Specifies the unique condition.
                     * @type {number}
                     */
                    uniqueCondition= 9,
                    /** Specifies the average condition.
                     * @type {number}
                     */
                    averageCondition= 10,
                    /** Specifies the cell value condition.
                     * @type {number}
                     */
                    cellValueCondition= 11,
                    /** Specifies the area condition.
                     * @type {number}
                     */
                    areaCondition= 12
                }

                /**
                 * Specifies the custom value type.
                 * @enum {number}
                 * @example
                 * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.formulaCondition, {compareType: GCTYPE.Spread.Sheets.ConditionalFormatting.CustomValueType.nonEmpty});
                 * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                 * validator.ignoreBlank(false);
                 * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                 * spread.options.highlightInvalidData = true;
                 */
                export enum CustomValueType{
                    /** Indicates whether the cell value is empty or null.
                     * @type {number}
                     */
                    empty= 0,
                    /** Indicates whether the cell value is not empty or null.
                     * @type {number}
                     */
                    nonEmpty= 1,
                    /** Indicates whether the cell value contains a calculation error.
                     * @type {number}
                     */
                    error= 2,
                    /** Indicates whether the cell value does not contain a calculation error.
                     * @type {number}
                     */
                    nonError= 3,
                    /** Indicates whether the cell value is a formula.
                     * @type {number}
                     */
                    formula= 4
                }

                /**
                 * Specifies the position of the data bar's axis.
                 * @enum {number}
                 * @example
                 * //This example creates a data bar rule.
                 * activeSheet.setValue(0,0,1,3);
                 * activeSheet.setValue(1,0,15,3);
                 * activeSheet.setValue(2,0,25,3);
                 * activeSheet.setValue(3,0,-1,3);
                 * var dataBarRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule();
                 * dataBarRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                 * dataBarRule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * dataBarRule.minValue(-1);
                 * dataBarRule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * dataBarRule.maxValue(40);
                 * dataBarRule.color("green");
                 * dataBarRule.showBorder(true);
                 * dataBarRule.borderColor("orange");
                 * dataBarRule.dataBarDirection(GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                 * dataBarRule.negativeFillColor("yellow");
                 * dataBarRule.useNegativeFillColor(true);
                 * dataBarRule.negativeBorderColor("red");
                 * dataBarRule.useNegativeBorderColor(true);
                 * dataBarRule.axisPosition(GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                 * dataBarRule.axisColor("blue");
                 * dataBarRule.showBarOnly(false);
                 * activeSheet.conditionalFormats.addRule(dataBarRule);
                 */
                export enum DataBarAxisPosition{
                    /** Specifies whether to display at a variable position based on negative values.
                     * @type {number}
                     */
                    automatic= 0,
                    /** Specifies whether to display at the cell midpoint.
                     * @type {number}
                     */
                    cellMidPoint= 1,
                    /** Specifies whether to display value bars in the same direction as positive values.
                     * @type {number}
                     */
                    none= 2
                }

                /**
                 * Specifies the date compare type.
                 * @enum {number}
                 * @example
                 * //This example validates cell data.
                 * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.dateCondition, {compareType: GCTYPE.Spread.Sheets.ConditionalFormatting.DateCompareType.before, expected: new Date(2012, 11, 31)});
                 * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                 * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                 * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                 * spread.options.highlightInvalidData = true;
                 * activeSheet.setValue(0, 0, new Date(2012, 12, 12));
                 */
                export enum DateCompareType{
                    /** Indicates whether the date time is equal to a certain time.
                     * @type {number}
                     */
                    equalsTo= 0,
                    /** Indicates whether the date time is not equal to a certain time.
                     * @type {number}
                     */
                    notEqualsTo= 1,
                    /** Indicates whether the date time is before a certain time.
                     * @type {number}
                     */
                    before= 2,
                    /** Indicates whether the date time is before or equal to a certain time.
                     * @type {number}
                     */
                    beforeEqualsTo= 3,
                    /** Indicates whether the date time is after a certain time.
                     * @type {number}
                     */
                    after= 4,
                    /** Indicates whether the date time is after or equal to a certain time.
                     * @type {number}
                     */
                    afterEqualsTo= 5
                }

                /**
                 * Specifies the date occurring type.
                 * @enum {number}
                 * @example
                 * //This example creates a rule.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * var rule = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.dateOccurringRule, [new GCTYPE.Spread.Sheets.Range(0,0,10,1)], style, null, null, null, null, null, GCTYPE.Spread.Sheets.ConditionalFormatting.DateOccurringType.nextWeek);
                 * activeSheet.conditionalFormats.addRule(rule);
                 * var d = new Date();
                 * activeSheet.setValue(0, 0, d);
                 * activeSheet.setValue(1, 0, new Date(d.setDate(d.getDate()+1)));
                 * activeSheet.setValue(2, 0, new Date(d.setDate(d.getDate()+5)));
                 * activeSheet.setValue(3, 0,new Date(d.setDate(d.getDate()+6)));
                 * activeSheet.setValue(4, 0,new Date(d.setDate(d.getDate()+7)));
                 * activeSheet.setValue(5, 0, new Date(d.setDate(d.getDate()+8)));
                 */
                export enum DateOccurringType{
                    /** Specifies today.
                     * @type {number}
                     */
                    today= 0,
                    /** Specifies yesterday.
                     * @type {number}
                     */
                    yesterday= 1,
                    /** Specifies tomorrow.
                     * @type {number}
                     */
                    tomorrow= 2,
                    /** Specifies the last seven days.
                     * @type {number}
                     */
                    last7Days= 3,
                    /** Specifies this month.
                     * @type {number}
                     */
                    thisMonth= 4,
                    /** Specifies last month.
                     * @type {number}
                     */
                    lastMonth= 5,
                    /** Specifies next month.
                     * @type {number}
                     */
                    nextMonth= 6,
                    /** Specifies this week.
                     * @type {number}
                     */
                    thisWeek= 7,
                    /** Specifies last week.
                     * @type {number}
                     */
                    lastWeek= 8,
                    /** Specifies next week.
                     * @type {number}
                     */
                    nextWeek= 9,
                    /** Specifies next Quarter.
                     * @type {number}
                     */
                    nextQuarter= 10,
                    /** Specifies this Quarter.
                     * @type {number}
                     */
                    thisQuarter= 11,
                    /** Specifies last Quarter.
                     * @type {number}
                     */
                    lastQuarter= 12,
                    /** Specifies next Year.
                     * @type {number}
                     */
                    nextYear= 13,
                    /** Specifies this Year.
                     * @type {number}
                     */
                    thisYear= 14,
                    /** Specifies last Year.
                     * @type {number}
                     */
                    lastYear= 15
                }

                /**
                 * Specifies the general operator.
                 * @enum {number}
                 * @example
                 * //This example validates a cell value.
                 * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.cellValueCondition);
                 * nCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators.equalsTo);
                 * nCondition.expected(0);
                 * //When the option is false, the validation fails and the red alert is displayed.
                 * //When the option is true, the blank cell is treated as zero and the validation is successful.
                 * nCondition.treatNullValueAsZero(false);
                 * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                 * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                 * validator.ignoreBlank(false);
                 * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                 * spread.options.highlightInvalidData = true;
                 * activeSheet.setValue(0, 0, null);
                 * alert(validator.value2());
                 */
                export enum GeneralComparisonOperators{
                    /** Indicates whether the number is equal to a specified number.
                     * @type {number}
                     */
                    equalsTo= 0,
                    /** Indicates whether the number is not equal to a specified number.
                     * @type {number}
                     */
                    notEqualsTo= 1,
                    /** Indicates whether the number is greater than a specified number.
                     * @type {number}
                     */
                    greaterThan= 2,
                    /** Indicates whether the number is greater than or equal to a specified number.
                     * @type {number}
                     */
                    greaterThanOrEqualsTo= 3,
                    /** Indicates whether the number is less than a specified number.
                     * @type {number}
                     */
                    lessThan= 4,
                    /** Indicates whether the number is less than or equal to a specified number.
                     * @type {number}
                     */
                    lessThanOrEqualsTo= 5
                }

                /**
                 * Specifies the icon set.
                 * @enum {number}
                 * @example
                 * //This example creates a rule.
                 * activeSheet.setValue(0,0,1,3);
                 * activeSheet.setValue(1,0,15,3);
                 * activeSheet.setValue(2,0,25,3);
                 * activeSheet.setValue(3,0,-1,3);
                 * var iconSetRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetRule();
                 * iconSetRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                 * iconSetRule.iconSetType(GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                 * var iconCriteria = iconSetRule.iconCriteria();
                 * iconCriteria[0] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                 * iconCriteria[1] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                 * iconCriteria[2] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                 * iconSetRule.reverseIconOrder(false);
                 * iconSetRule.showIconOnly(false);
                 * activeSheet.conditionalFormats.addRule(iconSetRule);
                 */
                export enum IconSetType{
                    /** Specifies three colored arrows.
                     * @type {number}
                     */
                    threeArrowsColored= 0,
                    /** Specifies three gray arrows.
                     * @type {number}
                     */
                    threeArrowsGray= 1,
                    /** Specifies three trangles.
                     * @type {number}
                     */
                    threeTriangles= 2,
                    /** Specifies three stars.
                     * @type {number}
                     */
                    threeStars= 3,
                    /** Specifies three flags.
                     * @type {number}
                     */
                    threeFlags= 4,
                    /** Specifies three traffic lights (unrimmed).
                     * @type {number}
                     */
                    threeTrafficLightsUnrimmed= 5,
                    /** Specifies three traffic lights (rimmed).
                     * @type {number}
                     */
                    threeTrafficLightsRimmed= 6,
                    /** Specifies three signs.
                     * @type {number}
                     */
                    threeSigns= 7,
                    /** Specifies three symbols (circled).
                     * @type {number}
                     */
                    threeSymbolsCircled= 8,
                    /** Specifies three symbols (uncircled).
                     * @type {number}
                     */
                    threeSymbolsUncircled= 9,
                    /** Specifies four colored arrows.
                     * @type {number}
                     */
                    fourArrowsColored= 10,
                    /** Specifies four gray arrows.
                     * @type {number}
                     */
                    fourArrowsGray= 11,
                    /** Specifies four red to black icons.
                     * @type {number}
                     */
                    fourRedToBlack= 12,
                    /** Specifies four ratings.
                     * @type {number}
                     */
                    fourRatings= 13,
                    /** Specifies four traffic lights.
                     * @type {number}
                     */
                    fourTrafficLights= 14,
                    /** Specifies five colored arrows.
                     * @type {number}
                     */
                    fiveArrowsColored= 15,
                    /** Specifies five gray arrows.
                     * @type {number}
                     */
                    fiveArrowsGray= 16,
                    /** Specifies five ratings.
                     * @type {number}
                     */
                    fiveRatings= 17,
                    /** Specifies five quarters.
                     * @type {number}
                     */
                    fiveQuarters= 18,
                    /** Specifies five boxes.
                     * @type {number}
                     */
                    fiveBoxes= 19,
                    /** Specifies no cell icon.
                     * @type {number}
                     */
                    noIcons= 20
                }

                /**
                 * Specifies the icon value type.
                 * @enum {number}
                 * @example
                 * //This example creates a rule.
                 * activeSheet.setValue(0,0,1,3);
                 * activeSheet.setValue(1,0,15,3);
                 * activeSheet.setValue(2,0,25,3);
                 * activeSheet.setValue(3,0,-1,3);
                 * var iconSetRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetRule();
                 * iconSetRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                 * iconSetRule.iconSetType(GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                 * var iconCriteria = iconSetRule.iconCriteria();
                 * iconCriteria[0] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                 * iconCriteria[1] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                 * iconCriteria[2] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                 * iconSetRule.reverseIconOrder(false);
                 * iconSetRule.showIconOnly(false);
                 * activeSheet.conditionalFormats.addRule(iconSetRule);
                 */
                export enum IconValueType{
                    /** Indicates whether to return a specified number directly.
                     * @type {number}
                     */
                    number= 1,
                    /** Indicates whether to return the percentage of a cell value in a specified cell range.
                     * @type {number}
                     */
                    percent= 4,
                    /** Indicates whether to return the result of a formula calculation.
                     * @type {number}
                     */
                    formula= 7,
                    /** Indicates whether to return the percentile of a cell value in a specified cell range.
                     * @type {number}
                     */
                    percentile= 5
                }

                /**
                 * Specifies the relation operator.
                 * @enum {number}
                 * @example
                 * //This example validates data.
                 * var condition1 = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.dateCondition, {compareType: GCTYPE.Spread.Sheets.ConditionalFormatting.DateCompareType.afterEqualsTo, expected: new Date(2012, 11, 31)});
                 * var condition2 = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.dateCondition, {compareType: GCTYPE.Spread.Sheets.ConditionalFormatting.DateCompareType.beforeEqualsTo, expected: new Date(2013, 11, 31)});
                 * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.relationCondition, {compareType: GCTYPE.Spread.Sheets.ConditionalFormatting.LogicalOperators.and, item1: condition1, item2: condition2});
                 * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                 * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                 * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                 * spread.options.highlightInvalidData = true;
                 * activeSheet.setValue(0, 0, new Date(2012, 11, 25));
                 */
                export enum LogicalOperators{
                    /** Specifies the Or relation.
                     * @type {number}
                     */
                    or= 0,
                    /** Specifies the And relation.
                     * @type {number}
                     */
                    and= 1
                }

                /**
                 * Specifies the quarter type.
                 * @enum {number}
                 */
                export enum QuarterType{
                    /** Indicates the first quarter of a year.
                     * @type {number}
                     */
                    quarter1= 0,
                    /** Indicates the second quarter of a year.
                     * @type {number}
                     */
                    quarter2= 1,
                    /** Indicates the third quarter of a year.
                     * @type {number}
                     */
                    quarter3= 2,
                    /** Indicates the fourth quarter of a year.
                     * @type {number}
                     */
                    quarter4= 3
                }

                /**
                 * Specifies the rule type.
                 * @enum {number}
                 */
                export enum RuleType{
                    /** Specifies the base rule of the condition.
                     * @type {number}
                     */
                    conditionRuleBase= 0,
                    /** Specifies the cell value rule.
                     * @type {number}
                     */
                    cellValueRule= 1,
                    /** Specifies the specific text rule.
                     * @type {number}
                     */
                    specificTextRule= 2,
                    /** Specifies the formula rule.
                     * @type {number}
                     */
                    formulaRule= 3,
                    /** Specifies the date occurring rule.
                     * @type {number}
                     */
                    dateOccurringRule= 4,
                    /** Specifies the top 10 rule.
                     * @type {number}
                     */
                    top10Rule= 5,
                    /** Specifies the unique rule.
                     * @type {number}
                     */
                    uniqueRule= 6,
                    /** Specifies the duplicate rule.
                     * @type {number}
                     */
                    duplicateRule= 7,
                    /** Specifies the average rule.
                     * @type {number}
                     */
                    averageRule= 8,
                    /** Specifies the two scale rule.
                     * @type {number}
                     */
                    twoScaleRule= 10,
                    /** Specifies the three scale rule.
                     * @type {number}
                     */
                    threeScaleRule= 11,
                    /** Specifies the data bar rule.
                     * @type {number}
                     */
                    dataBarRule= 12,
                    /** Specifies the icon set rule.
                     * @type {number}
                     */
                    iconSetRule= 13
                }

                /**
                 * Specifies the scale value type.
                 * @enum {number}
                 * @example
                 * //This example creates a data bar rule.
                 * activeSheet.setValue(0,0,1,3);
                 * activeSheet.setValue(1,0,15,3);
                 * activeSheet.setValue(2,0,25,3);
                 * activeSheet.setValue(3,0,-1,3);
                 * var dataBarRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule();
                 * dataBarRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                 * dataBarRule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * dataBarRule.minValue(-1);
                 * dataBarRule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                 * dataBarRule.maxValue(40);
                 * dataBarRule.color("green");
                 * dataBarRule.showBorder(true);
                 * dataBarRule.borderColor("orange");
                 * dataBarRule.dataBarDirection(GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                 * dataBarRule.negativeFillColor("yellow");
                 * dataBarRule.useNegativeFillColor(true);
                 * dataBarRule.negativeBorderColor("red");
                 * dataBarRule.useNegativeBorderColor(true);
                 * dataBarRule.axisPosition(GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                 * dataBarRule.axisColor("blue");
                 * dataBarRule.showBarOnly(false);
                 * activeSheet.conditionalFormats.addRule(dataBarRule);
                 */
                export enum ScaleValueType{
                    /** Indicates whether to return a specified number directly.
                     * @type {number}
                     */
                    number= 0,
                    /** Indicates whether to return the lowest value in a specified cell range.
                     * @type {number}
                     */
                    lowestValue= 1,
                    /** Indicates whether to return the highest value in a specified cell range.
                     * @type {number}
                     */
                    highestValue= 2,
                    /** Indicates whether to return the percentage of a cell value in a specified cell range.
                     * @type {number}
                     */
                    percent= 3,
                    /** Indicates whether to return the percentile of a cell value in a specified cell range.
                     * @type {number}
                     */
                    percentile= 4,
                    /** Indicates whether to return the automatic minimum value in a specified range.
                     * @type {number}
                     */
                    automin= 5,
                    /** Indicates whether to return the result of a formula calculation.
                     * @type {number}
                     */
                    formula= 6,
                    /** Indicates whether to return the automatic maximum value in a specified range.
                     * @type {number}
                     */
                    automax= 7
                }

                /**
                 * Specifies the text compare type.
                 * @enum {number}
                 * @example
                 * //This example uses the TextCompareType enumeration.
                 * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.textCondition, {compareType: GCTYPE.Spread.Sheets.ConditionalFormatting.TextCompareType.contains, expected: "test"});
                 * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                 * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                 * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                 * spread.options.highlightInvalidData = true;
                 * activeSheet.setValue(0, 0, "testing");
                 * //Type text in 0,0 that does not contain "test" to see invalid symbol
                 */
                export enum TextCompareType{
                    /** Indicates whether the string is equal to a specified string.
                     * @type {number}
                     */
                    equalsTo= 0,
                    /** Indicates whether the string is not equal to a specified string.
                     * @type {number}
                     */
                    notEqualsTo= 1,
                    /** Indicates whether the string starts with a specified string.
                     * @type {number}
                     */
                    beginsWith= 2,
                    /** Indicates whether the string does not start with a specified string.
                     * @type {number}
                     */
                    doesNotBeginWith= 3,
                    /** Indicates whether the string ends with a specified string.
                     * @type {number}
                     */
                    endsWith= 4,
                    /** Indicates whether the string does not end with a specified string.
                     * @type {number}
                     */
                    doesNotEndWith= 5,
                    /** Indicates whether the string contains a specified string.
                     * @type {number}
                     */
                    contains= 6,
                    /** Indicates whether the string does not contain a specified string.
                     * @type {number}
                     */
                    doesNotContain= 7
                }

                /**
                 * Specifies the text comparison operator.
                 * @enum {number}
                 * @example
                 * //This example creates a rule.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * var ranges=[new GCTYPE.Spread.Sheets.Range(0,0,10,1)];
                 * activeSheet.conditionalFormats.addSpecificTextRule(GCTYPE.Spread.Sheets.ConditionalFormatting.TextComparisonOperators.contains, "test", style, ranges);
                 * activeSheet.setValue(0, 0, "testing");
                 * activeSheet.setValue(1, 0, "test");
                 * activeSheet.setValue(2, 0, "a");
                 * activeSheet.setValue(3, 0, "t");
                 */
                export enum TextComparisonOperators{
                    /** Determines whether a cell value contains the parameter value.
                     * @type {number}
                     */
                    contains= 0,
                    /** Determines whether a cell value does not contain the parameter value.
                     * @type {number}
                     */
                    doesNotContain= 1,
                    /** Determines whether a cell value begins with the parameter value.
                     * @type {number}
                     */
                    beginsWith= 2,
                    /** Determines whether a cell value ends with the parameter value.
                     * @type {number}
                     */
                    endsWith= 3
                }

                /**
                 * Specifies the top 10 condition type.
                 * @enum {number}
                 * @example
                 * //This example uses the Top10ConditionType enumeration.
                 * var style = new GCTYPE.Spread.Sheets.Style();
                 * style.backColor = "red";
                 * var ranges=[new GCTYPE.Spread.Sheets.Range(0,0,10,1)];
                 * activeSheet.conditionalFormats.addTop10Rule(GCTYPE.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top, 2, style, ranges);
                 * activeSheet.setValue(0, 0, 1);
                 * activeSheet.setValue(1, 0, 50);
                 * activeSheet.setValue(2, 0, 11);
                 * activeSheet.setValue(3, 0, 5);
                 */
                export enum Top10ConditionType{
                    /** Specifies the top condition.
                     * @type {number}
                     */
                    top= 0,
                    /** Specifies the bottom condition.
                     * @type {number}
                     */
                    bottom= 1
                }


                export class Condition{
                    /**
                     * Represents a conditional item using the parameter object.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType} conditionType
                     * @param {Object} args
                     * @constructor
                     * @example
                     * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.averageCondition, {compareType: GCTYPE.Spread.Sheets.ConditionalFormatting.AverageConditionType.above});
                     * nCondition.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, 5);
                     * activeSheet.setValue(1, 0, 15);
                     */
                    constructor(conditionType: GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType,  args: Object);
                    /**
                     * Gets or sets the rule compare type.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.LogicalOperators | GCTYPE.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators | GCTYPE.Spread.Sheets.ConditionalFormatting.TextCompareType | GCTYPE.Spread.Sheets.ConditionalFormatting.ColorCompareType | GCTYPE.Spread.Sheets.ConditionalFormatting.DateCompareType} value The rule compare type.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.LogicalOperators | GCTYPE.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators | GCTYPE.Spread.Sheets.ConditionalFormatting.TextCompareType | GCTYPE.Spread.Sheets.ConditionalFormatting.ColorCompareType | GCTYPE.Spread.Sheets.ConditionalFormatting.DateCompareType | GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} If no value is set, returns the rule compare type; otherwise, returns the condition.
                     * @example
                     * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.textCondition);
                     * nCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.TextCompareType.contains);
                     * nCondition.expected("test");
                     * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, "testing");
                     */
                    compareType(value?: GCTYPE.Spread.Sheets.ConditionalFormatting.LogicalOperators | GCTYPE.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators | GCTYPE.Spread.Sheets.ConditionalFormatting.TextCompareType | GCTYPE.Spread.Sheets.ConditionalFormatting.ColorCompareType | GCTYPE.Spread.Sheets.ConditionalFormatting.DateCompareType): any;
                    /**
                     * Evaluates the condition using the specified evaluator.
                     * @param {Object} evaluator The evaluator that can evaluate an expression or a function.
                     * @param {number} baseRow The base row index for evaluation.
                     * @param {number} baseColumn The base column index for evaluation.
                     * @param {Object} actualObj The actual value of object1 for evaluation.
                     * @returns {boolean} <c>true</c> if the result is successful; otherwise, <c>false</c>.
                     */
                    evaluate(evaluator: Object,  baseRow: number,  baseColumn: number,  actualObj: Object): boolean;
                    /**
                     * Gets or sets the expected value.
                     * @param {Object} value The expected value.
                     * @returns {object | GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} If no value is set, returns the expected value; otherwise, returns the condition.
                     * @example
                     * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.dateCondition);
                     * nCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.DateCompareType.before);
                     * nCondition.expected(new Date(2012, 11, 31));
                     * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, new Date(2012, 12, 12));
                     */
                    expected(value?: any): any;
                    /**
                     * Gets or sets the expected formula.
                     * @param {string | number} formulaOrBaseRow The expected formula or base row.
                     * @param {number} baseColumn The base column.
                     * @returns {string | GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} If no value is set or baseRow and baseColumn is set, returns the expected formula; otherwise, returns the condition.
                     * @example
                     * var textLengthCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.textLengthCondition);
                     * textLengthCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators.greaterThan);
                     * textLengthCondition.formula("$C$1"); // formula used to calculate a number.
                     * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(textLengthCondition);
                     * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, "abcf");
                     * //Set value 3 to $C$1, after this code, the value in Cell(0,0) is valid.
                     * activeSheet.setValue(0, 2, 3);
                     * //Set value 5 to $C$1, after this code, the value in Cel(0,0) is invalid.
                     * // activeSheet.setValue(0, 2, 5);
                     */
                    formula(formulaOrBaseRow?: string | number,  baseColumn ?: number): any;
                    /**
                     * Creates a date extend condition object from the specified day.
                     * @static
                     * @param {number} day The day.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} A date extend condition object.
                     */
                    static fromDay(day: number): GCTYPE.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Creates the area condition from formula data.
                     * @static
                     * @param {string} formula The formula that specifies a range that contains data items.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} The area condition.
                     */
                    static fromFormula(formula: string): GCTYPE.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Creates a date extend condition object from the specified month.
                     * @static
                     * @param {number} month The month. The first month is 0.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} A date extend condition object.
                     */
                    static fromMonth(month: number): GCTYPE.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Creates a date extend condition object from the specified quarter.
                     * @static
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.QuarterType} quarter The quarter.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} A date extend condition object.
                     */
                    static fromQuarter(quarter: GCTYPE.Spread.Sheets.ConditionalFormatting.QuarterType): GCTYPE.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Creates the area condition from source data.
                     * @static
                     * @param {string} expected The expected source that separates each data item with a comma (",").
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} The area condition.
                     */
                    static fromSource(expected: string): GCTYPE.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Creates a date extend condition object from the specified week.
                     * @static
                     * @param {number} week The week.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} A date extend condition object.
                     */
                    static fromWeek(week: number): GCTYPE.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Creates a date extend condition object from the specified year.
                     * @static
                     * @param {number} year The year.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} A date extend condition object.
                     */
                    static fromYear(year: number): GCTYPE.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Gets the expected value.
                     * @constructor
                     * @param {Object} evaluator The evaluator that can evaluate an expression or a function.
                     * @param {number} baseRow The base row index for evaluation.
                     * @param {number} baseColumn The base column index for evaluation.
                     * @returns {Object} The expected value.
                     */
                    getExpected(evaluator: Object,  baseRow: number,  baseColumn: number): Object;
                    /**
                     * Returns the list of valid data items.
                     * @param {Object} evaluator The evaluator that can evaluate an expression or a function.
                     * @param {number} baseRow The base row index for evaluation.
                     * @param {number} baseColumn The base column index for evaluation.
                     * @returns {Array} The list of valid data items.
                     */
                    getValidList(evaluator: Object,  baseRow: number,  baseColumn: number): any[];
                    /**
                     * Gets or sets whether to ignore the blank cell.
                     * @param {boolean} value Whether to ignore the blank cell.
                     * @returns {boolean | GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} If no value is set, returns whether to ignore the blank cell; otherwise, returns the condition.
                     * @example
                     * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.textCondition);
                     * nCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.TextCompareType.contains);
                     * nCondition.expected("te?t");
                     * nCondition.ignoreBlank(true);
                     * nCondition.ignoreCase(true);
                     * nCondition.useWildCards(true);
                     * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, "testing");
                     */
                    ignoreBlank(value?: boolean): any;
                    /**
                     * Gets or sets whether to ignore case when performing the comparison.
                     * @param {boolean} value Whether to ignore case when performing the comparison.
                     * @returns {boolean | GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} If no value is set, returns whether to ignore case when performing the comparison; otherwise, returns the condition.
                     * @example
                     * //This example creates a text condition.
                     * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.textCondition);
                     * nCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.TextCompareType.contains);
                     * nCondition.expected("te?t");
                     * nCondition.ignoreBlank(true);
                     * nCondition.ignoreCase(true);
                     * nCondition.useWildCards(true);
                     * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, "testing");
                     */
                    ignoreCase(value?: boolean): any;
                    /**
                     * Gets or sets the first condition.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} value The first condition.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} If no value is set, returns the first condition; otherwise, returns the relation condition.
                     * @example
                     * //This example validates a date.
                     * var condition1 = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.dateCondition, {compareType: GCTYPE.Spread.Sheets.ConditionalFormatting.DateCompareType.afterEqualsTo, expected: new Date(2012, 11, 31)});
                     * var condition2 = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.dateCondition, {compareType: GCTYPE.Spread.Sheets.ConditionalFormatting.DateCompareType.beforeEqualsTo, expected: new Date(2013, 11, 31)});
                     * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.relationCondition);
                     * nCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.LogicalOperators.and);
                     * nCondition.item1(condition1);
                     * nCondition.item2(condition2);
                     * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, new Date(2012, 11, 25));
                     */
                    item1(value?: GCTYPE.Spread.Sheets.ConditionalFormatting.Condition): GCTYPE.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Gets or sets the second condition.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} value The second condition.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} If no value is set, returns the second condition; otherwise, returns the relation condition.
                     * @example
                     * //This example validates a date.
                     * var condition1 = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.dateCondition, {compareType: GCTYPE.Spread.Sheets.ConditionalFormatting.DateCompareType.afterEqualsTo, expected: new Date(2012, 11, 31)});
                     * var condition2 = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.dateCondition, {compareType: GCTYPE.Spread.Sheets.ConditionalFormatting.DateCompareType.beforeEqualsTo, expected: new Date(2013, 11, 31)});
                     * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.relationCondition);
                     * nCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.LogicalOperators.and);
                     * nCondition.item1(condition1);
                     * nCondition.item2(condition2);
                     * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, new Date(2012, 11, 25));
                     */
                    item2(value?: GCTYPE.Spread.Sheets.ConditionalFormatting.Condition): GCTYPE.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Gets or sets whether to compare whole day or precise date time.
                     * @param {boolean} value Indicates compare whole day or precise date time.
                     * @returns {boolean | GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns compare whole day or precise date time; otherwise, returns the data validator.
                     * @example
                     * //This example uses the preciseCompareDate method.
                     * var dateCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.dateCondition);
                     * dateCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators.greaterThan);
                     * dateCondition.expected(new Date(2020, 4, 22, 06));
                     * //When the option is false, the validator compares the whole day, and they are the same, so validation fails and the red alert is displayed.
                     * //When the option is true, the date time 7 o'clock is greater than 6 o'clock, so the result is successful.
                     * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(dateCondition);
                     * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.date);
                     * validator.preciseCompareDate(true);
                     * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, new Date(2020, 4, 22, 07));
                     */
                    preciseCompareDate(value?: boolean): any;
                    /**
                     * Gets or sets the condition ranges.
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} value The condition ranges.
                     * @returns {Array.<GCTYPE.Spread.Sheets.Range> | GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} If no value is set, returns the condition ranges; otherwise, returns the condition.
                     * @example
                     * //This example creates a unique condition.
                     * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.uniqueCondition);
                     * nCondition.expected(true);
                     * nCondition.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 5, 1)]);
                     * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, 5);
                     */
                    ranges(value?: GCTYPE.Spread.Sheets.Range[]): any;
                    /**
                     * Resets this instance.
                     * @example
                     * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.numberCondition);
                     * nCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                     * nCondition.expected(5);
                     * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, 5);
                     * //Create a button
                     * $("#button1").click(function () {
                     * activeSheet.suspendPaint();
                     * nCondition.reset();
                     * activeSheet.resumePaint();
                     *     });
                     */
                    reset(): void;
                    /**
                     * Gets or sets whether to treat the null value in a cell as zero.
                     * @param {boolean} value Whether to treat the null value in a cell as zero.
                     * @returns {boolean | GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} If no value is set, returns whether to treat the null value in a cell as zero; otherwise, returns the condition.
                     * @example
                     * //This example sets the treatNullValueAsZero method.
                     * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.cellValueCondition);
                     * nCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators.equalsTo);
                     * nCondition.expected(0);
                     * //When the option is false, the validation fails and the red alert is displayed.
                     * //When the option is true, the blank cell is treated as zero and the validation is successful.
                     * nCondition.treatNullValueAsZero(false);
                     * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * validator.ignoreBlank(false);
                     * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, null);
                     */
                    treatNullValueAsZero(value?: boolean): any;
                    /**
                     * Gets or sets whether to compare strings using wildcards.
                     * @param {boolean} value Whether to compare strings using wildcards.
                     * @returns {boolean | GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} If no value is set, returns whether to compare strings using wildcards; otherwise, returns the condition.
                     * @example
                     * //This example allows wildcards.
                     * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.textCondition);
                     * nCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.TextCompareType.contains);
                     * nCondition.expected("te?t");
                     * nCondition.ignoreBlank(true);
                     * nCondition.ignoreCase(true);
                     * nCondition.useWildCards(true);
                     * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, "testing");
                     */
                    useWildCards(value?: boolean): any;
                }

                export class ConditionalFormats{
                    /**
                     * Represents a format condition class.
                     * @class
                     * @param {GCTYPE.Spread.Sheets.Worksheet} worksheet The sheet.
                     */
                    constructor(worksheet: GCTYPE.Spread.Sheets.Worksheet);
                    /**
                     * Adds the two scale rule to the rule collection.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType} minType The minimum scale type.
                     * @param {number} minValue The minimum scale value.
                     * @param {string} minColor The minimum scale color.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType} maxType The maximum scale type.
                     * @param {number} maxValue The maximum scale value.
                     * @param {string} maxColor The maximum scale color.
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GCTYPE.Spread.Sheets.Range.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} The two scale rule added to the rule collection.
                     * @example
                     * //This example uses the add2ScaleRule method.
                     * activeSheet.conditionalFormats.add2ScaleRule(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number,10,"Red",GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number,100,"Yellow", [new GCTYPE.Spread.Sheets.Range(0,0,10,3)]);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     */
                    add2ScaleRule(minType: GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType,  minValue: number,  minColor: string,  maxType: GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType,  maxValue: number,  maxColor: string,  ranges: GCTYPE.Spread.Sheets.Range[]): GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase;
                    /**
                     * Adds the three scale rule to the rule collection.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType} minType The minimum scale type.
                     * @param {number} minValue The minimum scale value.
                     * @param {string} minColor The minimum scale color.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType} midType The midpoint scale type.
                     * @param {number} midValue The midpoint scale value.
                     * @param {string} midColor The midpoint scale color.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType} maxType The maximum scale type.
                     * @param {number} maxValue The maximum scale value.
                     * @param {string} maxColor The maximum scale color.
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GCTYPE.Spread.Sheets.Range.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} The three scale rule added to the rule collection.
                     * @example
                     * //This example uses the add3ScaleRule method.
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     * activeSheet.conditionalFormats.add3ScaleRule(1, 10, "red", 0, 50, "blue",2, 100, "yellow", [new GCTYPE.Spread.Sheets.Range(0, 0, 10, 3)]);
                     */
                    add3ScaleRule(minType: GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType,  minValue: number,  minColor: string,  midType: GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType,  midValue: number,  midColor: string,  maxType: GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType,  maxValue: number,  maxColor: string,  ranges: GCTYPE.Spread.Sheets.Range[]): GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase;
                    /**
                     * Adds an average rule to the rule collection.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.AverageConditionType} type The average condition type.
                     * @param {GCTYPE.Spread.Sheets.Style} style The style that is applied to the cell when the condition is met.
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GCTYPE.Spread.Sheets.Range.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} The average rule added to the rule collection.
                     * @example
                     * //This example uses the addAverageRule method.
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     * activeSheet.setValue(3,0, 2,3);
                     * activeSheet.setValue(4,0, 60,3);
                     * activeSheet.setValue(5,0, 90,3);
                     * activeSheet.setValue(6,0, 3,3);
                     * activeSheet.setValue(7,0, 40,3);
                     * activeSheet.setValue(8,0, 70,3);
                     * activeSheet.setValue(9,0, 5,3);
                     * activeSheet.setValue(10,0, 35,3);
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.borderLeft =new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                     * style.borderTop = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                     * style.borderRight = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                     * style.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                     * activeSheet.conditionalFormats.addAverageRule(GCTYPE.Spread.Sheets.ConditionalFormatting.AverageConditionType.above,style,[new GCTYPE.Spread.Sheets.Range(0, 0, 10, 3)]);
                     */
                    addAverageRule(type: GCTYPE.Spread.Sheets.ConditionalFormatting.AverageConditionType,  style: GCTYPE.Spread.Sheets.Style,  ranges: GCTYPE.Spread.Sheets.Range[]): GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase;
                    /**
                     * Adds the cell value rule to the rule collection.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators} comparisonOperator The comparison operator.
                     * @param {Object} value1 The first value.
                     * @param {Object} value2 The second value.
                     * @param {GCTYPE.Spread.Sheets.Style} style The style that is applied to the cell when the condition is met.
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GCTYPE.Spread.Sheets.Range.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} The cell value rule added to the rule collection.
                     * @example
                     * //This example uses the addCellValueRule method.
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var ranges=[new GCTYPE.Spread.Sheets.Range(0,0,5,1)];
                     * activeSheet.conditionalFormats.addCellValueRule(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between, 2, 100, style, ranges);
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,45,3);
                     */
                    addCellValueRule(comparisonOperator: GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators,  value1: Object,  value2: Object,  style: GCTYPE.Spread.Sheets.Style,  ranges: GCTYPE.Spread.Sheets.Range[]): GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase;
                    /**
                     * Adds a data bar rule to the rule collection.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType} minType The minimum scale type.
                     * @param {number} minValue The minimum scale value.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType} maxType The maximum scale type.
                     * @param {number} maxValue The maximum scale value.
                     * @param {string} color The color data bar to show on the view.
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GCTYPE.Spread.Sheets.Range.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} The data bar rule added to the rule collection.
                     * @example
                     * //This example uses the addDataBarRule method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * activeSheet.conditionalFormats.addDataBarRule(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number, -1, GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number, 40, "orange", [new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     */
                    addDataBarRule(minType: GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType,  minValue: number,  maxType: GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType,  maxValue: number,  color: string,  ranges: GCTYPE.Spread.Sheets.Range[]): GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase;
                    /**
                     * Adds the date occurring rule to the rule collection.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.DateOccurringType} type The data occurring type.
                     * @param {GCTYPE.Spread.Sheets.Style} style The style that is applied to the cell when the condition is met.
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GCTYPE.Spread.Sheets.Range.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} The date occurring rule added to the rule collection.
                     * @example
                     * //This example uses the addDateOccurringRule method.
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var d = new Date();
                     * activeSheet.setValue(0, 0, d);
                     * activeSheet.setValue(1, 0, new Date(d.setDate(d.getDate()+1)));
                     * activeSheet.setValue(2, 0, new Date(d.setDate(d.getDate()+5)));
                     * activeSheet.setValue(3, 0,new Date(d.setDate(d.getDate()+6)));
                     * activeSheet.setValue(4, 0,new Date(d.setDate(d.getDate()+7)));
                     * activeSheet.setValue(5, 0, new Date(d.setDate(d.getDate()+8)));
                     * activeSheet.conditionalFormats.addDateOccurringRule(GCTYPE.Spread.Sheets.ConditionalFormatting.DateOccurringType.nextWeek, style, [new GCTYPE.Spread.Sheets.Range(0,0,10,1)]);
                     */
                    addDateOccurringRule(type:GCTYPE.Spread.Sheets.ConditionalFormatting.DateOccurringType,  style: GCTYPE.Spread.Sheets.Style,  ranges: GCTYPE.Spread.Sheets.Range[]): GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase;
                    /**
                     * Adds a duplicate rule to the rule collection.
                     * @param {GCTYPE.Spread.Sheets.Style} style The style that is applied to the cell when the condition is met.
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GCTYPE.Spread.Sheets.Range.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} The duplicate rule added to the rule collection.
                     * @example
                     * //This example uses the addDuplicateRule method.
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "yellow";
                     * var ranges=[new GCTYPE.Spread.Sheets.Range(0,0,10,1)];
                     * activeSheet.conditionalFormats.addDuplicateRule(style, ranges);
                     * activeSheet.setValue(0, 0, 50);
                     * activeSheet.setValue(1, 0, 50);
                     * activeSheet.setValue(2, 0, 11);
                     * activeSheet.setValue(3, 0, 5);
                     */
                    addDuplicateRule(style: GCTYPE.Spread.Sheets.Style,  ranges: GCTYPE.Spread.Sheets.Range[]): GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase;
                    /**
                     * Adds the formula rule to the rule collection.
                     * @param {string} formula The condition formula.
                     * @param {GCTYPE.Spread.Sheets.Style} style The style that is applied to the cell when the condition is met.
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GCTYPE.Spread.Sheets.Range.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} The formula rule added to the rule collection.
                     * @example
                     * //This example uses the addFormulaRule method.
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var ranges = [new GCTYPE.Spread.Sheets.Range(0, 0, 2, 1)];
                     * activeSheet.conditionalFormats.addFormulaRule("=A1=B1+C1", style, ranges);
                     * activeSheet.setValue(0, 0, 2,3);
                     * activeSheet.setValue(0, 1, 1,3);
                     * activeSheet.setValue(0, 2,1,3);
                     * activeSheet.setValue(1, 0, 1,3);
                     */
                    addFormulaRule(formula: string,  style: GCTYPE.Spread.Sheets.Style,  ranges: GCTYPE.Spread.Sheets.Range[]): GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase;
                    /**
                     * Adds an icon set rule to the rule collection.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType} iconSetType The type of icon set.
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GCTYPE.Spread.Sheets.Range.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} The icon set rule added to the rule collection.
                     * @example
                     * //This example uses the addIconSetRule method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * activeSheet.conditionalFormats.addIconSetRule(GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights, [new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     */
                    addIconSetRule(iconSetTye: GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType,  ranges: GCTYPE.Spread.Sheets.Range[]): GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase;
                    /**
                     * Adds the rule.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} rule The rule to add.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase}
                     * @example
                     * //This example uses the addRule method.
                     * var scale = new GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule();
                     * scale.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.threeScaleRule);
                     * scale.midColor("red");
                     * scale.midType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.midValue(50);
                     * scale.maxColor("blue");
                     * scale.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.maxValue(100);
                     * scale.minColor("yellow");
                     * scale.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.minValue(10);
                     * scale.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * activeSheet.conditionalFormats.addRule(scale);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     */
                    addRule(rule: GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase): GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase;
                    /**
                     * Adds the text rule to the rule collection.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.TextComparisonOperators} comparisonOperator The comparison operator.
                     * @param {string} text The text for comparison.
                     * @param {GCTYPE.Spread.Sheets.Style} style The style that is applied to the cell when the condition is met.
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied to items whose item type is GCTYPE.Spread.Sheets.Range.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} The text rule added to the rule collection.
                     * @example
                     * //This example uses the addSpecificTextRule method.
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var ranges=[new GCTYPE.Spread.Sheets.Range(0,0,10,1)];
                     * activeSheet.conditionalFormats.addSpecificTextRule(GCTYPE.Spread.Sheets.ConditionalFormatting.TextComparisonOperators.contains, "test", style, ranges);
                     * activeSheet.setValue(0, 0, "testing");
                     * activeSheet.setValue(1, 0, "test");
                     * activeSheet.setValue(2, 0, "a");
                     * activeSheet.setValue(3, 0, "t");
                     */
                    addSpecificTextRule(comparisonOperator: GCTYPE.Spread.Sheets.ConditionalFormatting.TextComparisonOperators,  text: string,  style: GCTYPE.Spread.Sheets.Style,  ranges: GCTYPE.Spread.Sheets.Range[]): GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase;
                    /**
                     * Adds the top 10 rule or bottom 10 rule to the collection based on the Top10ConditionType object.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.Top10ConditionType} type The top 10 condition.
                     * @param {number} rank The number of top or bottom items to apply the style to.
                     * @param {GCTYPE.Spread.Sheets.Style} style The style that is applied to the cell when the condition is met.
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GCTYPE.Spread.Sheets.Range.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} The top 10 rule added to the rule collection.
                     * @example
                     * //This example uses the addTop10Rule method.
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var ranges=[new GCTYPE.Spread.Sheets.Range(0,0,10,1)];
                     * activeSheet.conditionalFormats.addTop10Rule(GCTYPE.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top, 2, style, ranges);
                     * activeSheet.setValue(0, 0, 1);
                     * activeSheet.setValue(1, 0, 50);
                     * activeSheet.setValue(2, 0, 11);
                     * activeSheet.setValue(3, 0, 5);
                     */
                    addTop10Rule(type: GCTYPE.Spread.Sheets.ConditionalFormatting.Top10ConditionType,  rank: number,  style: GCTYPE.Spread.Sheets.Style,  ranges: GCTYPE.Spread.Sheets.Range[]): GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase;
                    /**
                     * Adds a unique rule to the rule collection.
                     * @param {GCTYPE.Spread.Sheets.Style} style The style that is applied to the cell when the condition is met.
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GCTYPE.Spread.Sheets.Range.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} The unique rule added to the rule collection.
                     * @example
                     * //This example uses the addUniqueRule method.
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "green";
                     * activeSheet.setValue(0, 0, 50);
                     * activeSheet.setValue(1, 0, 50);
                     * activeSheet.setValue(2, 0, 11);
                     * activeSheet.setValue(3, 0, 5);
                     * activeSheet.conditionalFormats.addUniqueRule(style, [new GCTYPE.Spread.Sheets.Range(0,0,10,1)]);
                     */
                    addUniqueRule(style: GCTYPE.Spread.Sheets.Style,  ranges: GCTYPE.Spread.Sheets.Range[]): GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase;
                    /**
                     * Removes all rules.
                     * @example
                     * //This example uses the clearRule method.
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     * activeSheet.conditionalFormats.add2ScaleRule(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number, 10, "red", GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number, 100, "yellow", [new GCTYPE.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * // Remove comment in front of method to test
                     * //activeSheet.conditionalFormats.clearRule();
                     */
                    clearRule(): void;
                    /**
                     * Determines whether the specified cell contains a specified rule.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} rule The rule for which to check.
                     * @param {number} row The row index.
                     * @param {number} column The column index.
                     * @returns {boolean} <c>true</c> if the specified cell contains a specified rule; otherwise, <c>false</c>.
                     * @example
                     * //This example checks to see if a cell has a specified rule.
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var rule = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * rule.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * rule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,5,1)]);
                     * rule.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between);
                     * rule.style(style);
                     * rule.value1(2);
                     * rule.value2(100);
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,45,3);
                     * var ruletest = activeSheet.conditionalFormats.containsRule(rule, 0, 0);
                     * alert(ruletest);
                     */
                    containsRule(rule: GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase,  row: number,  column: number): boolean;
                    /**
                     * Gets the number of rule objects in the collection.
                     * @returns {number} The number of rule objects in the collection.
                     * @example
                     * //This example counts the rules.
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var rule = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * rule.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * rule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,5,1)]);
                     * rule.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between);
                     * rule.style(style);
                     * rule.value1(2);
                     * rule.value2(100);
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,45,3);
                     * var ruletest = activeSheet.conditionalFormats.count();
                     * alert(ruletest);
                     */
                    count(): number;
                    /**
                     * Gets the rule using the index.
                     * @param {number} index The index from which to get the rule.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} The rule from the index.
                     * @example
                     * //This example uses the getRule method.
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var rule = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * rule.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * rule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,5,1)]);
                     * rule.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between);
                     * rule.style(style);
                     * rule.value1(2);
                     * rule.value2(100);
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,45,3);
                     * var ruletest = activeSheet.conditionalFormats.getRule(0);
                     * alert(ruletest.value1());
                     */
                    getRule(index: number): GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase;
                    /**
                     * Gets the conditional rules from the cell at the specified row and column.
                     * @param {number} row The row index.
                     * @param {number} column The column index.
                     * @returns {Array.<GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase>} The conditional rules.
                     * @example
                     * //This example uses the getRules method.
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var rule = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * rule.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * rule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,5,1)]);
                     * rule.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between);
                     * rule.style(style);
                     * rule.value1(2);
                     * rule.value2(100);
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,45,3);
                     * var ruletest = activeSheet.conditionalFormats.getRules();
                     * alert(ruletest[0].style().backColor);
                     */
                    getRules(row: number,  column: number): GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase[];
                    /**
                     * Removes a rule object from the ConditionalFormats object.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} rule The rule object to remove from the ConditionalFormats object.
                     * @example
                     * //This example uses the removeRule method.
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var rule = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * rule.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * rule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,5,1)]);
                     * rule.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between);
                     * rule.style(style);
                     * rule.value1(2);
                     * rule.value2(100);
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,45,3);
                     * activeSheet.conditionalFormats.removeRule(rule);
                     */
                    removeRule(rule: GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase): void;
                    /**
                     * Removes the rules from a specified cell range.
                     * @param {number} row The row index of the first cell in the range.
                     * @param {number} column The column index of the first cell in the range.
                     * @param {number} rowCount The number of rows in the range.
                     * @param {number} columnCount The number of columns in the range.
                     * @example
                     * //This example uses the removeRuleByRange method.
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var rule = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * rule.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * rule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,5,1)]);
                     * rule.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between);
                     * rule.style(style);
                     * rule.value1(2);
                     * rule.value2(100);
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,45,3);
                     * activeSheet.conditionalFormats.removeRuleByRange(0, 0, 5, 1);
                     */
                    removeRuleByRange(row: number,  column: number,  rowCount: number,  columnCount: number): void;
                }

                export class ConditionRuleBase{
                    /**
                     * Represents a formatting base rule class as the specified style.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType} ruleType
                     * @param {GCTYPE.Spread.Sheets.Style} style The style for the rule.
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} ranges The range array.
                     * @class
                     */
                    constructor(ruleType: GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType,  style: GCTYPE.Spread.Sheets.Style,  ranges: GCTYPE.Spread.Sheets.Range[]);
                    /**
                     * Gets or sets the base condition of the rule.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} value The base condition of the rule.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition | GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} If no value is set, returns the base condition of the rule; otherwise, returns the condition rule.
                     */
                    condition(value?: GCTYPE.Spread.Sheets.ConditionalFormatting.Condition): any;
                    /**
                     * Determines whether the range of cells contains the cell at the specified row and column.
                     * @param {number} row The row index.
                     * @param {number} column The column index.
                     * @returns {boolean} <c>true</c> if the range of cells contains the cell at the specified row and column; otherwise, <c>false</c>.
                     */
                    contains(row: number,  column: number): boolean;
                    /**
                     * Creates condition for the rule.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} The condition.
                     */
                    createCondition(): GCTYPE.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Returns the cell style of the rule if the cell satisfies the condition.
                     * @param {Object} evaluator The object that can evaluate a condition.
                     * @param {number} baseRow The row index.
                     * @param {number} baseColumn The column index.
                     * @param {Object} actual The actual value.
                     * @returns {GCTYPE.Spread.Sheets.Style} The cell style of the rule.
                     */
                    evaluate(evaluator: Object,  baseRow: number,  baseColumn: number,  actual: Object): GCTYPE.Spread.Sheets.Style;
                    /**
                     * Gets the style of the base rule.
                     * @returns {GCTYPE.Spread.Sheets.Style}
                     */
                    getExpected(): GCTYPE.Spread.Sheets.Style;
                    /**
                     * Specifies whether the range for this rule intersects another range.
                     * @param {number} row The row index.
                     * @param {number} column The column index.
                     * @param {number} rowCount The number of rows.
                     * @param {number} columnCount The number of columns.
                     * @returns {boolean} <c>true</c> if the range for this rule intersects another range; otherwise, <c>false</c>.
                     */
                    intersects(row: number,  column: number,  rowCount: number,  columnCount: number): boolean;
                    /**
                     * Specifies whether this rule is a scale rule.
                     * @returns {boolean} <c>true</c> if this rule is a scale rule; otherwise, <c>false</c>.
                     */
                    isScaleRule(): boolean;
                    /**
                     * Gets or sets the priority of the rule.
                     * @param {number} value The priority of the rule.
                     * @returns {number | GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} If no value is set, returns the priority of the rule; otherwise, returns the condition rule.
                     */
                    priority(value?: number): any;
                    /**
                     * Gets or sets the condition rule ranges.
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} value The condition rule ranges.
                     * @returns {Array.<GCTYPE.Spread.Sheets.Range> | GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} If no value is set, returns the condition rule ranges; otherwise, returns the condition rule.
                     * @example
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "green";
                     * var ranges = [new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)];
                     * activeSheet.conditionalFormats.addUniqueRule(style, ranges);
                     * activeSheet.setValue(0, 0, 50);
                     * activeSheet.setValue(1, 0, 50);
                     * activeSheet.setValue(2, 0, 11);
                     * activeSheet.setValue(3, 0, 5);
                     */
                    ranges(value?: GCTYPE.Spread.Sheets.Range[]): any;
                    /**
                     * Resets the rule.
                     */
                    reset(): void;
                    /**
                     * Gets or sets the condition rule type.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType} value The condition rule type.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType | GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} If no value is set, returns the condition rule type; otherwise, returns the condition rule.
                     * @example
                     * //This example uses the ruleType method.
                     * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.foreColor = "black";
                     * var cell = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * cell.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * cell.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                     * cell.value1(5);
                     * cell.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * cell.style(style);
                     * activeSheet.conditionalFormats.addRule(cell);
                     * var style1 = new GCTYPE.Spread.Sheets.Style();
                     * style1.foreColor = "red";
                     * var top = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * top.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                     * top.type(GCTYPE.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                     * top.rank(3);
                     * top.style(style1);
                     * top.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * top.stopIfTrue(true);
                     * activeSheet.conditionalFormats.addRule(top);
                     */
                    ruleType(value?: GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType): any;
                    /**
                     * Gets or sets whether rules with lower priority are applied before this rule.
                     * @param {boolean} value Whether rules with lower priority are applied before this rule.
                     * @returns {boolean | GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} If no value is set, returns whether the rules with lower priority are not applied before this rule; otherwise, returns the condition rule.
                     * @example
                     * //This example applies multiple rules.
                     * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.foreColor = "black";
                     * var cell = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * cell.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * cell.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                     * cell.value1(5);
                     * cell.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * cell.style(style);
                     * activeSheet.conditionalFormats.addRule(cell);
                     * var style1 = new GCTYPE.Spread.Sheets.Style();
                     * style1.foreColor = "red";
                     * var top = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * top.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                     * top.type(GCTYPE.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                     * top.rank(3);
                     * top.style(style1);
                     * top.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * top.stopIfTrue(true);
                     * activeSheet.conditionalFormats.addRule(top);
                     */
                    stopIfTrue(value?: boolean): any;
                    /**
                     * Gets or sets the style for the rule.
                     * @param {GCTYPE.Spread.Sheets.Style} value The style for the rule.
                     * @returns {GCTYPE.Spread.Sheets.Style | GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase} If no value is set, returns the style for the rule; otherwise, returns the condition rule.
                     * @example
                     * //This example applies multiple rules.
                     * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.foreColor = "black";
                     * var cell = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * cell.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * cell.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                     * cell.value1(5);
                     * cell.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * cell.style(style);
                     * activeSheet.conditionalFormats.addRule(cell);
                     * var style1 = new GCTYPE.Spread.Sheets.Style();
                     * style1.foreColor = "red";
                     * var top = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * top.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                     * top.type(GCTYPE.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                     * top.rank(3);
                     * top.style(style1);
                     * top.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * top.stopIfTrue(true);
                     * activeSheet.conditionalFormats.addRule(top);
                     */
                    style(value?: GCTYPE.Spread.Sheets.Style): any;
                }

                export class DataBarRule extends ScaleRule{
                    /**
                     * Represents a data bar conditional rule with the specified parameters.
                     * @extends GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType} minType The minimum scale type.
                     * @param {number | string} minValue The minimum scale value.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType} maxType The maximum scale type.
                     * @param {number | string} maxValue The maximum scale value.
                     * @param {string} color The fill color of the data bar.
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} ranges The data bar rule effected range.
                     * @class
                     * @example
                     * //This example creates a data bar rule.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number, -1, GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number, 40, "green", [new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    constructor(minType: GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType,  minValue: number | string,  maxType: GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType,  maxValue: number | string,  color: string,  ranges: GCTYPE.Spread.Sheets.Range[]);
                    /**
                     * Gets or sets the axis color of the data bar.
                     * @param {string} value The axis color of the data bar.
                     * @returns {string | GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the axis color of the data bar; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the axisColor method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     *  //rule
                     * var dataBarRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    axisColor(value?: string): any;
                    /**
                     * Gets or sets the axis position of the data bar.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition} value The axis position of the data bar.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition | GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the axis position of the data bar; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the axisPosition method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     *  //rule
                     * var dataBarRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    axisPosition(value?: GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition): any;
                    /**
                     * Gets or sets the color of the border.
                     * @param {string} value The color of the border.
                     * @returns {string | GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the color of the border; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the borderColor method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     *  //rule
                     * var dataBarRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    borderColor(value?: string): any;
                    /**
                     * Gets or sets the positive fill color of the data bar.
                     * @param {string} value The fill color.
                     * @returns {string | GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the positive fill color of the data bar; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the color method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     *  //rule
                     * var dataBarRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    color(value?: string): any;
                    /**
                     * Gets or sets the data bar direction.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection} value The data bar direction.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection | GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the data bar direction; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the dataBarDirection method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     *  //rule
                     * var dataBarRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    dataBarDirection(value?: GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection): any;
                    /**
                     * Returns the specified value of the rule if the cell meets the condition.
                     * @param {Object} evaluator The evaluator.
                     * @param {number} baseRow The row index.
                     * @param {number} baseColumn The column index.
                     * @param {Object} actual The current value.
                     * @returns {Object} The specified value of the rule if the cell meets the condition.
                     */
                    evaluate(evaluator: Object,  baseRow: number,  baseColumn: number,  actual: Object): any;
                    /**
                     * Gets or sets a value that indicates whether the data bar is a gradient.
                     * @param {boolean} value Whether the data bar is a gradient.
                     * @returns {boolean | GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the value that indicates whether the data bar is a gradient; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the gradient method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * dataBarRule.gradient(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    gradient(value?: boolean): any;
                    /**
                     * Gets or sets the color of the negative border.
                     * @param {string} value The color of the negative border.
                     * @returns {string | GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the color of the negative border; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the negativeBorderColor method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    negativeBorderColor(value?: string): any;
                    /**
                     * Gets or sets the color of the negative fill.
                     * @param {string} value The color of the negative fill.
                     * @returns {string | GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the color of the negative fill; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the negativeFillColor method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    negativeFillColor(value?: string): any;
                    /**
                     * Gets or sets whether to display the data bar without text.
                     * @param {boolean} value Whether to display the data bar without text.
                     * @returns {boolean | GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns whether the widget displays the data bar without text; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the showBarOnly method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    showBarOnly(value?: boolean): any;
                    /**
                     * Gets or sets a value that indicates whether to paint the border.
                     * @param {boolean} value Whether to paint the border.
                     * @returns {boolean | GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the value that indicates whether to paint the border; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the showBorder method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    showBorder(value?: boolean): any;
                    /**
                     * Gets or sets a value that indicates whether the negative border color is used to paint the border for the negative value.
                     * @param {boolean} value Whether the negative border color is used to paint the border for the negative value.
                     * @returns {boolean | GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the value that indicates whether the negative border color is used to paint the border for the negative value; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the useNegativeBorderColor method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    useNegativeBorderColor(value?: boolean): any;
                    /**
                     * Gets or sets a value that indicates whether the negative fill color is used to paint the negative value.
                     * @param {boolean} value Whether the negative fill color is used to paint the negative value.
                     * @returns {boolean | GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule} If no value is set, returns the value that indicates whether the negative fill color is used to paint the negative value; otherwise, returns the data bar rule.
                     * @example
                     * //This example uses the useNegativeFillColor method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    useNegativeFillColor(value?: boolean): any;
                }

                export class IconCriterion{
                    /**
                     * Represents an icon criteria with the specified parameters.
                     * @class
                     * @param {boolean} isGreaterThanOrEqualTo If set to true, use the greater than or equal to operator to calculate the value.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType} iconValueType The type of scale value.
                     * @param {Object} iconValue The scale value.
                     * @example
                     * //This example creates an icon rule.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * //rule
                     * var iconSetRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetRule();
                     * iconSetRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * iconSetRule.iconSetType(GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                     * var iconCriteria = iconSetRule.iconCriteria();
                     * iconCriteria[0] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                     * iconCriteria[1] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                     * iconCriteria[2] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                     * iconSetRule.reverseIconOrder(false);
                     * iconSetRule.showIconOnly(false);
                     * activeSheet.conditionalFormats.addRule(iconSetRule);
                     */
                    constructor(isGreaterThanOrEqualTo: boolean,  iconValueType: IconValueType,  iconValue: Object);
                }

                export class IconSetRule extends ScaleRule{
                    /**
                     * Represents an icon set rule with the specified parameters.
                     * @class
                     * @extends GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType} iconSetType The type of icon set.
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} ranges
                     * @example
                     * //This example creates a new icon set rule and sets the range and icon for it.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var iconSetRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetRule();
                     * iconSetRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * iconSetRule.iconSetType(GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                     * var icons = iconSetRule.icons();
                     * icons[0] = {iconSetType: GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.fiveArrowsColored, iconIndex: 1};
                     * icons[1] = {iconSetType: GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.fiveArrowsColored, iconIndex: 2};
                     * icons[2] = {iconSetType: GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.noIcons, iconIndex: 0};
                     *
                     * var iconCriteria = iconSetRule.iconCriteria();
                     * iconCriteria[0] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                     * iconCriteria[1] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                     * iconCriteria[2] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                     * iconSetRule.reverseIconOrder(false);
                     * iconSetRule.showIconOnly(false);
                     * activeSheet.conditionalFormats.addRule(iconSetRule);
                     */
                    constructor(iconSetType: IconSetType,  ranges: GCTYPE.Spread.Sheets.Range[]);
                    /**
                     * Returns the specified value of the rule if the cell meets the condition.
                     * @param {Object} evaluator The evaluator.
                     * @param {number} baseRow The row index.
                     * @param {number} baseColumn The column index.
                     * @param {Object} actual The current value.
                     * @returns {Object} The specified value of the rule if the cell meets the condition.
                     */
                    evaluate(evaluator: Object,  baseRow: number,  baseColumn: number,  actual: Object): any;
                    /**
                     * Gets the icon based on the specific iconSetType and iconIndex objects.
                     * @static
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType} iconSetType The icon set type.
                     * @param {number} iconIndex The icon index.
                     * returns {object} An object that contains the image's URL string, the offset, and width and height.
                     * If the user wants to customize the icon for IconSet, it returns the image URL string.
                     * @example
                     * //This example returns the icons for an icon set rule.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * //get the icon
                     * var base = GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetRule.getIcon;
                     * GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetRule.getIcon = function (iconSetType, iconIndex) {
                     *      var icon = base.apply(this, arguments);
                     *      if (iconSetType === GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.threeArrowsColored) {
                     *          if (iconIndex === 0) {
                     *              return "images/Star2.png";
                     *          } else if (iconIndex === 1){
                     *              return "images/Rating4.png";
                     *          } else if (iconIndex === 2) {
                     *              return "images/Box4.png";
                     *          }
                     *      }
                     *      return icon;
                     * };
                     * var iconSetRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetRule();
                     * iconSetRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * iconSetRule.iconSetType(GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.threeArrowsColored);
                     * var iconCriteria = iconSetRule.iconCriteria();
                     * iconCriteria[0] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                     * iconCriteria[1] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                     * iconCriteria[2] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                     * iconSetRule.reverseIconOrder(false);
                     * iconSetRule.showIconOnly(false);
                     * activeSheet.conditionalFormats.addRule(iconSetRule);
                     */
                    static getIcon(iconSetType: IconSetType,  iconIndex: number): Object;
                    /**
                     * Gets the icon criteria.
                     * @returns {Array.<GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion>} Returns the icon criterions whose item type is GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion.
                     * @example
                     * //This example creates a rule.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * //rule
                     * var iconSetRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetRule();
                     * iconSetRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * iconSetRule.iconSetType(GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                     * var iconCriteria = iconSetRule.iconCriteria();
                     * iconCriteria[0] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                     * iconCriteria[1] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                     * iconCriteria[2] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                     * iconSetRule.reverseIconOrder(false);
                     * iconSetRule.showIconOnly(false);
                     * activeSheet.conditionalFormats.addRule(iconSetRule);
                     */
                    iconCriteria(): GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion[];
                    /**
                     * Gets or sets the icons.
                     * @param {object[]} [iconInfos] - Sets the iconInfos array.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType} iconInfos.iconSetType - The custom iconSetType
                     * @param {number} iconInfos.iconIndex - The custom iconIndex
                     * @returns {object[]} Returns the iconInfos array.
                     * @example
                     * //This example creates a rule.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     *
                     * //rule
                     * var iconSetRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetRule();
                     * iconSetRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * iconSetRule.iconSetType(GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                     * var icons = iconSetRule.icons();
                     * icons[0] = {iconSetType: GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.fiveArrowsColored, iconIndex: 1};
                     * icons[1] = {iconSetType: GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.fiveArrowsColored, iconIndex: 2};
                     * icons[2] = {iconSetType: GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.noIcons, iconIndex: 0};
                     * iconSetRule.reverseIconOrder(false);
                     * iconSetRule.showIconOnly(false);
                     * activeSheet.conditionalFormats.addRule(iconSetRule);
                     */
                    icons(value?: GCTYPE.Spread.Sheets.ConditionalFormatting.IIconInfo[]): GCTYPE.Spread.Sheets.ConditionalFormatting.IIconInfo[];
                    /**
                     * Gets or sets the type of icon set.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType} value The type of icon set.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType | GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetRule} If no value is set, returns the type of icon set; otherwise, returns the icon set rule.
                     * @example
                     * //This example creates a rule.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * //rule
                     * var iconSetRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetRule();
                     * iconSetRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * iconSetRule.iconSetType(GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                     * var iconCriteria = iconSetRule.iconCriteria();
                     * iconCriteria[0] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                     * iconCriteria[1] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                     * iconCriteria[2] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                     * iconSetRule.reverseIconOrder(false);
                     * iconSetRule.showIconOnly(false);
                     * activeSheet.conditionalFormats.addRule(iconSetRule);
                     */
                    iconSetType(value?: GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType): any;
                    /**
                     * Resets the rule.
                     * @example
                     * //This example uses the reset method.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * //rule
                     * var iconSetRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetRule();
                     * iconSetRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * iconSetRule.iconSetType(GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                     * var iconCriteria = iconSetRule.iconCriteria();
                     * iconCriteria[0] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                     * iconCriteria[1] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                     * iconCriteria[2] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                     * iconSetRule.reverseIconOrder(false);
                     * iconSetRule.showIconOnly(false);
                     * activeSheet.conditionalFormats.addRule(iconSetRule);
                     * iconSetRule.reset();
                     */
                    reset(): void;
                    /**
                     * Gets or sets whether to reverse icon order.
                     * @param {boolean} value Whether to reverse icon order.
                     * @returns {boolean | GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetRule} If no value is set, returns the value that indicates whether to reverse icon order; otherwise, returns the icon set rule.
                     * @example
                     * //This example creates a rule.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * //rule
                     * var iconSetRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetRule();
                     * iconSetRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * iconSetRule.iconSetType(GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                     * var iconCriteria = iconSetRule.iconCriteria();
                     * iconCriteria[0] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                     * iconCriteria[1] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                     * iconCriteria[2] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                     * iconSetRule.reverseIconOrder(false);
                     * iconSetRule.showIconOnly(false);
                     * activeSheet.conditionalFormats.addRule(iconSetRule);
                     */
                    reverseIconOrder(value?: boolean): any;
                    /**
                     * Gets or sets whether to display the icon only.
                     * @param {boolean} value Whether to display the icon only.
                     * @returns {boolean | GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetRule} If no value is set, returns the value that indicates whether to display the icon only; otherwise, returns the icon set rule.
                     * @example
                     * //This example creates a rule.
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * //rule
                     * var iconSetRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetRule();
                     * iconSetRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * iconSetRule.iconSetType(GCTYPE.Spread.Sheets.ConditionalFormatting.IconSetType.fourTrafficLights);
                     * var iconCriteria = iconSetRule.iconCriteria();
                     * iconCriteria[0] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 1);
                     * iconCriteria[1] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 10);
                     * iconCriteria[2] = new GCTYPE.Spread.Sheets.ConditionalFormatting.IconCriterion(true, GCTYPE.Spread.Sheets.ConditionalFormatting.IconValueType.number, 20);
                     * iconSetRule.reverseIconOrder(false);
                     * iconSetRule.showIconOnly(false);
                     * activeSheet.conditionalFormats.addRule(iconSetRule);
                     */
                    showIconOnly(value?: boolean): any;
                }

                export class NormalConditionRule extends ConditionRuleBase{
                    /**
                     * Represents a normal conditional rule.
                     * @class
                     * @extends GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType} ruleType
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} ranges The cell ranges where the rule is applied whose item type is GCTYPE.Spread.Sheets.Range.
                     * @param {GCTYPE.Spread.Sheets.Style} style The style that is applied to the cell when the condition is met.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.LogicalOperators | GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators | GCTYPE.Spread.Sheets.ConditionalFormatting.TextComparisonOperators} operator The comparison operator.
                     * @param {Object} value1 The first value.
                     * @param {Object} value2 The second value.
                     * @param {string} text The text for comparison.
                     * @param {string} formula The condition formula.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.Top10ConditionType | GCTYPE.Spread.Sheets.ConditionalFormatting.AverageConditionType | GCTYPE.Spread.Sheets.ConditionalFormatting.DateOccurringType} type The average condition type.
                     * @param {number} rank The number of top or bottom items to apply the style to.
                     * @constructor
                     * @example
                     * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                     * var cell = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * cell.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * cell.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                     * cell.value1(5);
                     * cell.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * cell.style(style);
                     * activeSheet.conditionalFormats.addRule(cell);
                     * //button
                     * $("#button1").click(function () {
                     *      cell.reset();
                     *      activeSheet.suspendPaint();
                     *      activeSheet.resumePaint();
                     * });
                     */
                    constructor(ruleType: GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType,  ranges: GCTYPE.Spread.Sheets.Range[],  style: GCTYPE.Spread.Sheets.Style,  operator: GCTYPE.Spread.Sheets.ConditionalFormatting.LogicalOperators | GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators | GCTYPE.Spread.Sheets.ConditionalFormatting.TextComparisonOperators,  value1: Object,  value2: Object,  text: string,  formula: string,  type: GCTYPE.Spread.Sheets.ConditionalFormatting.Top10ConditionType | GCTYPE.Spread.Sheets.ConditionalFormatting.AverageConditionType | GCTYPE.Spread.Sheets.ConditionalFormatting.DateOccurringType,  rank: number);
                    /**
                     * Creates a condition for the rule.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} The condition.
                     */
                    createCondition(): GCTYPE.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Gets or sets the condition formula.
                     * @param {string | number} formulaOrBaseRow The condition formula or the base row.
                     * @param {number} baseColumn The base column.
                     * @returns {string | GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule} If no value is set or baseRow and baseColumn is set, returns the condition formula; otherwise, returns the number condition rule.
                     * @example
                     * //This example uses the formula method.
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var rule = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * rule.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.formulaRule);
                     * rule.formula("=A1=B1+C1");
                     * rule.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 2, 1)]);
                     * rule.style(style);
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0, 0, 2,3);
                     * activeSheet.setValue(0, 1, 1,3);
                     * activeSheet.setValue(0, 2,1,3);
                     * activeSheet.setValue(1, 0, 1,3);
                     * var formulaOfTheTopLeftCell = rule.formula();
                     * var formulaOfA1 = rule.formula(0, 0);
                     * var formulaOfA2 = rule.formula(1, 0);
                     */
                    formula(formulaOrBaseRow?: string | number,  baseColumn ?: number): any;
                    /**
                     * Gets or sets the comparison operator.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators} value The comparison operator.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators | GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule} If no value is set, returns the comparison operator; otherwise, returns the number condition rule.
                     * @example
                     * //This example creates multiple rules.
                     * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.foreColor = "black";
                     * var cell = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * cell.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * cell.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                     * cell.value1(5);
                     * cell.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * cell.style(style);
                     * activeSheet.conditionalFormats.addRule(cell);
                     * var style1 = new GCTYPE.Spread.Sheets.Style();
                     * style1.foreColor = "red";
                     * var top = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * top.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                     * top.type(GCTYPE.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                     * top.rank(3);
                     * top.style(style1);
                     * top.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * top.stopIfTrue(true);
                     * activeSheet.conditionalFormats.addRule(top);
                     */
                    operator(value?: GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators): any;
                    /**
                     * Gets or sets the number of top or bottom items to apply the style to.
                     * @param {number} value The number of top or bottom items to apply the style to.
                     * @returns {number | GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule} If no value is set, returns the number of top or bottom items to apply the style to; otherwise, returns the number condition rule.
                     * @example
                     * //This example creates multiple rules.
                     * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.foreColor = "black";
                     * var cell = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * cell.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * cell.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                     * cell.value1(5);
                     * cell.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * cell.style(style);
                     * activeSheet.conditionalFormats.addRule(cell);
                     * var style1 = new GCTYPE.Spread.Sheets.Style();
                     * style1.foreColor = "red";
                     * var top = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * top.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                     * top.type(GCTYPE.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                     * top.rank(3);
                     * top.style(style1);
                     * top.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * top.stopIfTrue(true);
                     * activeSheet.conditionalFormats.addRule(top);
                     */
                    rank(value?: number): any;
                    /**
                     * Resets the rule.
                     * @example
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     * activeSheet.setValue(3,0, 2,3);
                     * activeSheet.setValue(4,0, 60,3);
                     * activeSheet.setValue(5,0, 90,3);
                     * activeSheet.setValue(6,0, 3,3);
                     * activeSheet.setValue(7,0, 40,3);
                     * activeSheet.setValue(8,0, 70,3);
                     * activeSheet.setValue(9,0, 5,3);
                     * activeSheet.setValue(10,0, 35,3);
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.borderLeft =new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                     * style.borderTop = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                     * style.borderRight = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                     * style.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("blue",GCTYPE.Spread.Sheets.LineStyle.medium);
                     * var rule = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * rule.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.averageRule);
                     * rule.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * rule.style(style);
                     * rule.type(GCTYPE.Spread.Sheets.ConditionalFormatting.AverageConditionType.above);
                     * activeSheet.conditionalFormats.addRule(rule);
                     * rule.reset();
                     */
                    reset(): void;
                    /**
                     * Gets or sets the text for comparison.
                     * @param {string} value The text for comparison.
                     * @returns {string | GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule} If no value is set, returns the text for comparison; otherwise, returns the number condition rule.
                     * @example
                     * //This example creates a rule.
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * var rule = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * rule.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.specificTextRule);
                     * rule.style(style);
                     * rule.text("test");
                     * rule.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.TextComparisonOperators.contains);
                     * rule.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0, 0, "testing");
                     * activeSheet.setValue(1, 0, "test");
                     * activeSheet.setValue(2, 0, "a");
                     * activeSheet.setValue(3, 0, "t");
                     */
                    text(value?: string): any;
                    /**
                     * Gets or sets the average condition type.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.AverageConditionType} value The average condition type.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.AverageConditionType | GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule} If no value is set, returns the average condition type; otherwise, returns the number condition rule.
                     * @example
                     * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.foreColor = "black";
                     * var cell = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * cell.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * cell.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                     * cell.value1(5);
                     * cell.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * cell.style(style);
                     * activeSheet.conditionalFormats.addRule(cell);
                     * var style1 = new GCTYPE.Spread.Sheets.Style();
                     * style1.foreColor = "red";
                     * var top = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * top.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                     * top.type(GCTYPE.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                     * top.rank(3);
                     * top.style(style1);
                     * top.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * top.stopIfTrue(true);
                     * activeSheet.conditionalFormats.addRule(top);
                     */
                    type(value?: GCTYPE.Spread.Sheets.ConditionalFormatting.AverageConditionType): any;
                    /**
                     * Gets or sets the first value.
                     * @param {Object | number} valueOrBaseRow The first value or the base row.
                     * @param {number} baseColumn The base column.
                     * @returns {Object | GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule} If no value is set or baseRow and baseColumn is set, returns the first value; otherwise, returns the number condition rule.
                     * @example
                     * //This example creates multiple rules.
                     * activeSheet.setArray(0,0,[[1,10],[2,9], [3,8],[4,7],[5,6],[6,5],[7,4],[8,3],[9,2],[10,1]]);
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.foreColor = "black";
                     * var cell = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * cell.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * cell.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan);
                     * cell.value1("=B1");
                     * cell.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * cell.style(style);
                     * activeSheet.conditionalFormats.addRule(cell);
                     * var style1 = new GCTYPE.Spread.Sheets.Style();
                     * style1.foreColor = "red";
                     * var top = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * top.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.top10Rule);
                     * top.type(GCTYPE.Spread.Sheets.ConditionalFormatting.Top10ConditionType.top);
                     * top.rank(3);
                     * top.style(style1);
                     * top.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * top.stopIfTrue(true);
                     * activeSheet.conditionalFormats.addRule(top);
                     * var formulaOfTheTopLeftCell = cell.value1();
                     * var formulaOfA5 = cell.value1(4, 0);
                     * var formulaOfA10 = cell.value1(9, 0);
                     */
                    value1(valueOrBaseRow?: any,  baseColumn?: number): any;
                    /**
                     * Gets or sets the first value.
                     * @param {Object | number} valueOrBaseRow The first value or the base row.
                     * @param {number} baseColumn The base column.
                     * @returns {Object | GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule} If no value is set or baseRow and baseColumn is set, returns the first value; otherwise, returns the number condition rule.
                     * @example
                     * //This example uses the value2 method.
                     * activeSheet.setArray(0,0,[1,2,3,4,5,6,7,8,9,10]);
                     * var cell = new GCTYPE.Spread.Sheets.ConditionalFormatting.NormalConditionRule();
                     * cell.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.cellValueRule);
                     * cell.operator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between);
                     * cell.value1(5);
                     * cell.value2(7);
                     * cell.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 1)]);
                     * var style = new GCTYPE.Spread.Sheets.Style();
                     * style.backColor = "red";
                     * style.foreColor = "black";
                     * cell.style(style);
                     * activeSheet.conditionalFormats.addRule(cell);
                     */
                    value2(valueOrBaseRow?: any,  baseColumn?: number): any;
                }

                export class ScaleRule extends ConditionRuleBase{
                    /**
                     * Represents a scale conditional rule.
                     * @@extends GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionRuleBase
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType} ruleType The rule type.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType} minType The minimum scale type.
                     * @param {number} minValue The minimum scale value.
                     * @param {string} minColor The minimum scale color.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType} midType The midpoint scale type.
                     * @param {number} midValue The midpoint scale value.
                     * @param {string} midColor The midpoint scale color.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType} maxType The maximum scale type.
                     * @param {number} maxValue The maximum scale value.
                     * @param {string} maxColor The maximum scale color.
                     * @param {Array.<GCTYPE.Spread.Sheets.Range>} ranges The ranges.
                     * @constructor
                     * @example
                     * var scale = new GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule();
                     * scale.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.threeScaleRule);
                     * scale.midColor("red");
                     * scale.midType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.midValue(50);
                     * scale.maxColor("blue");
                     * scale.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.maxValue(100);
                     * scale.minColor("yellow");
                     * scale.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.minValue(10);
                     * scale.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * activeSheet.conditionalFormats.addRule(scale);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     */
                    constructor(ruleType: GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType,  minType?: GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType,  minValue?: number,  minColor?: string,  midType?: GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType,  midValue?: number,  midColor?: string,  maxType?: GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType,  maxValue?: number,  maxColor?: string,  ranges?: GCTYPE.Spread.Sheets.Range[]);
                    /**
                     * Creates a condition for the rule.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} The condition.
                     */
                    createCondition(): GCTYPE.Spread.Sheets.ConditionalFormatting.Condition;
                    /**
                     * Returns a specified value of the rule if the cell satisfies the condition.
                     * @param {Object} evaluator The evaluator.
                     * @param {number} baseRow The row index.
                     * @param {number} baseColumn The column index.
                     * @param {Object} actual The actual value object for evaluation.
                     * @returns {string} A specified value of the rule if the cell satisfies the condition.
                     */
                    evaluate(evaluator: Object,  baseRow: number,  baseColumn: number,  actual: Object): any;
                    /**
                     * Gets or sets the maximum color scale.
                     * @param {string} value The maximum color scale.
                     * @returns {string | GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule} If no value is set, returns the maximum color scale; otherwise, returns the scale rule.
                     * @example
                     * var rule = new GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule();
                     * rule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,10,3)]);
                     * rule.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.twoScaleRule);
                     * rule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * rule.minValue(10);
                     * rule.minColor("Yellow");
                     * rule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * rule.maxValue(100);
                     * rule.maxColor("Blue");
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     */
                    maxColor(value?: string): any;
                    /**
                     * Gets or sets the maximum scale type.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType} value The maximum scale type.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType | GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule} If no value is set, returns the maximum scale type; otherwise, returns the scale rule.
                     * @example
                     * var scale = new GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule();
                     * scale.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.threeScaleRule);
                     * scale.midColor("red");
                     * scale.midType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.midValue(50);
                     * scale.maxColor("blue");
                     * scale.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.maxValue(100);
                     * scale.minColor("yellow");
                     * scale.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.minValue(10);
                     * scale.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * activeSheet.conditionalFormats.addRule(scale);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     */
                    maxType(value?: GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType): any;
                    /**
                     * Gets or sets the maximum scale value.
                     * @param {number} value The maximum scale value.
                     * @returns {number | GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule} If no value is set, returns the maximum scale value; otherwise, returns the scale rule.
                     * @example
                     * var scale = new GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule();
                     * scale.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.twoScaleRule);
                     * scale.maxColor("blue");
                     * scale.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.maxValue(100);
                     * scale.minColor("yellow");
                     * scale.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.minValue(10);
                     * scale.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * activeSheet.conditionalFormats.addRule(scale);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     * alert("Color: " + scale.maxColor() + " Type: " + scale.maxType() + " Value: " + scale.maxValue());
                     */
                    maxValue(value?: number): any;
                    /**
                     * Gets or sets the midpoint scale color.
                     * @param {string} value The midpoint scale color.
                     * @returns {string | GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule} If no value is set, returns the midpoint scale color; otherwise, returns the scale rule.
                     * @example
                     * var scale = new GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule();
                     * scale.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.threeScaleRule);
                     * scale.midColor("red");
                     * scale.midType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.midValue(50);
                     * scale.maxColor("blue");
                     * scale.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.maxValue(100);
                     * scale.minColor("yellow");
                     * scale.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.minValue(10);
                     * scale.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * activeSheet.conditionalFormats.addRule(scale);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     */
                    midColor(value?: string): any;
                    /**
                     * Gets or sets the midpoint scale type.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType} value The midpoint scale type.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType | GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule} If no value is set, returns the midpoint scale type; otherwise, returns the scale rule.
                     * @example
                     * var scale = new GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule();
                     * scale.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.threeScaleRule);
                     * scale.midColor("red");
                     * scale.midType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.midValue(50);
                     * scale.maxColor("blue");
                     * scale.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.maxValue(100);
                     * scale.minColor("yellow");
                     * scale.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.minValue(10);
                     * scale.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * activeSheet.conditionalFormats.addRule(scale);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     */
                    midType(value?: GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType): any;
                    /**
                     * Gets or sets the midpoint scale value.
                     * @param {number} value The midpoint scale value.
                     * @returns {number | GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule} If no value is set, returns the midpoint scale value; otherwise, returns the scale rule.
                     * @example
                     * var scale = new GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule();
                     * scale.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.threeScaleRule);
                     * scale.midColor("red");
                     * scale.midType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.midValue(50);
                     * scale.maxColor("blue");
                     * scale.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.maxValue(100);
                     * scale.minColor("yellow");
                     * scale.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * scale.minValue(10);
                     * scale.ranges([new GCTYPE.Spread.Sheets.Range(0, 0, 10, 3)]);
                     * activeSheet.conditionalFormats.addRule(scale);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     */
                    midValue(value?: number): any;
                    /**
                     * Gets or sets the minimum scale color.
                     * @param {string} value The minimum scale color.
                     * @returns {string | GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule} If no value is set, returns the minimum scale color; otherwise, returns the scale rule.
                     * @example
                     * var rule = new GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule();
                     * rule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,10,3)]);
                     * rule.ruleType(GCTYPE.Spread.Sheets.ConditionalFormatting.RuleType.twoScaleRule);
                     * rule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * rule.minValue(10);
                     * rule.minColor("Yellow");
                     * rule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * rule.maxValue(100);
                     * rule.maxColor("Blue");
                     * activeSheet.conditionalFormats.addRule(rule);
                     * activeSheet.setValue(0,0, 1,3);
                     * activeSheet.setValue(1,0, 50,3);
                     * activeSheet.setValue(2,0, 100,3);
                     */
                    minColor(value?: string): any;
                    /**
                     * Gets or sets the type of minimum scale.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType} value The type of minimum scale.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType | GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule} If no value is set, returns the type of minimum scale; otherwise, returns the scale rule.
                     * @example
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    minType(value?: GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType): any;
                    /**
                     * Gets or sets the minimum scale value.
                     * @param {number} value The minimum scale value.
                     * @returns {number | GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleRule} If no value is set, returns the minimum scale value; otherwise, returns the scale rule.
                     * @example
                     * activeSheet.setValue(0,0,1,3);
                     * activeSheet.setValue(1,0,15,3);
                     * activeSheet.setValue(2,0,25,3);
                     * activeSheet.setValue(3,0,-1,3);
                     * var dataBarRule = new GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarRule();
                     * dataBarRule.ranges([new GCTYPE.Spread.Sheets.Range(0,0,4,1)]);
                     * dataBarRule.minType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.minValue(-1);
                     * dataBarRule.maxType(GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType.number);
                     * dataBarRule.maxValue(40);
                     * dataBarRule.color("green");
                     * dataBarRule.showBorder(true);
                     * dataBarRule.borderColor("orange");
                     * dataBarRule.dataBarDirection(GCTYPE.Spread.Sheets.ConditionalFormatting.BarDirection.leftToRight);
                     * dataBarRule.negativeFillColor("yellow");
                     * dataBarRule.useNegativeFillColor(true);
                     * dataBarRule.negativeBorderColor("red");
                     * dataBarRule.useNegativeBorderColor(true);
                     * dataBarRule.axisPosition(GCTYPE.Spread.Sheets.ConditionalFormatting.DataBarAxisPosition.automatic);
                     * dataBarRule.axisColor("blue");
                     * dataBarRule.showBarOnly(false);
                     * activeSheet.conditionalFormats.addRule(dataBarRule);
                     */
                    minValue(value?: number): any;
                    /**
                     * Gets whether evaluation should stop if the condition evaluates to <c>true</c>.
                     */
                    stopIfTrue(value?: boolean): boolean;
                }

                export class ScaleValue{
                    /**
                     * Represents a scale value with the specified type and value.
                     * @class
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType} type The scale value type.
                     * @param {Object} value The scale value.
                     */
                    constructor(type: GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType,  value: Object);
                    /** Gets the scale value type.
                     * @type {GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType}
                     */
                    type: GCTYPE.Spread.Sheets.ConditionalFormatting.ScaleValueType;
                    /** Gets the scale value.
                     * @type {Object}
                     */
                    value: Object;
                }
            }

            module ContextMenu{

                export interface IMenuItemData{
                    name?:string;
                    text?:string;
                    command?:string|Function;
                    disable?:boolean;
                    iconClass?:string;
                    group?:string;
                    subMenu?:IMenuItemData[];
                    type?:string;
                    workArea?:string;
                    visible?: boolean;
                    menuContent?: string;
                    status?: string | any
                    placeholder?: string;
                    commandOptions?: any;
                }


                export class ContextMenu{
                    /**
                     * Represents ContextMenu
                     * @class
                     */
                    constructor();
                    /**
                     * Represents the build-in menuData
                     * @type {Array.<object>}
                     * @property {string} [name] - Represent context menu item's identify.
                     * @property {string} [text] - Represent the text to be shown,if this context menu item is a group,text will be shown as DOM element's title.
                     * @property {string|Function} [command] - Represent a command name,commandManager will use this as index to find this command,if this command exist,then execute it.
                     * @property {boolean} [disable] - Represent this context menu item is disabled under current condition, default value is false.
                     * @property {string} [iconClass] - Represent this context menu item's icon,it is a class name.
                     * @property {string} [group] - Represent this context menu item is a group menu item and this property's value should be it's group header's name.
                     * @property {Array.<object>} [subMenu] - Represent this context menu item has sub menu.
                     * @property {string} [type] - Represent a context menu's type.
                     * @property {string} [workArea] - Represent this context menu item's should be shown on what area,value can be a collection of conditions,separate by whitespace. include: "sheetTab", "outline", "viewport", "rowHeader", "colHeader", "comment", "slicer", "corner".
                     */
                    menuData: GCTYPE.Spread.Sheets.ContextMenu.IMenuItemData[];
                    /**
                     * Represents the build-in menuView
                     * @type {GCTYPE.Spread.Sheets.ContextMenu.MenuView}
                     */
                    menuView: GCTYPE.Spread.Sheets.ContextMenu.MenuView;
                    /**
                     * open context menu
                     * @param {Array.<object>} menuData
                     * @param {string} [menuData.name] - Represent context menu item's identify.
                     * @param {string} [menuData.text] - Represent the text to be shown,if this context menu item is a group,text will be shown as DOM element's title.
                     * @param {string|Function} [menuData.command] - Represent a command name,commandManager will use this as index to find this command,if this command exist,then execute it.
                     * @param {boolean} [menuData.disable] - Represent this context menu item is disabled under current condition, default value is false.
                     * @param {string} [menuData.iconClass] - Represent this context menu item's icon,it is a class name.
                     * @param {string} [menuData.group] - Represent this context menu item is a group menu item and this param's value should be it's group header's name.
                     * @param {Array.<object>} [menuData.subMenu] - Represent this context menu item has sub menu.
                     * @param {string} [menuData.type] - Represent a context menu's type.
                     * @param {string} [menuData.workArea] - Represent this context menu item's should be shown on what area,value can be a collection of conditions,separate by whitespace. include: "sheetTab", "outline", "viewport", "rowHeader", "colHeader", "comment", "slicer", "corner".
                     * @param {Array.<object>} itemsDataForShown
                     * @param {string} [itemsDataForShown.name] - Represent context menu item's identify.
                     * @param {string} [itemsDataForShown.text] - Represent the text to be shown,if this context menu item is a group,text will be shown as DOM element's title.
                     * @param {string|Function} [itemsDataForShown.command] - Represent a command name,commandManager will use this as index to find this command,if this command exist,then execute it.
                     * @param {boolean} [itemsDataForShown.disable] - Represent this context menu item is disabled under current condition, default value is false.
                     * @param {string} [itemsDataForShown.iconClass] - Represent this context menu item's icon,it is a class name.
                     * @param {string} [itemsDataForShown.group] - Represent this context menu item is a group menu item and this param's value should be it's group header's name.
                     * @param {Array.<object>} [itemsDataForShown.subMenu] - Represent this context menu item has sub menu.
                     * @param {string} [itemsDataForShown.type] - Represent a context menu's type.
                     * @param {string} [itemsDataForShown.workArea] - Represent this context menu item's should be shown on what area,value can be a collection of conditions,separate by whitespace. include: "sheetTab", "outline", "viewport", "rowHeader", "colHeader", "comment", "slicer", "corner".
                     * @param {Object} hitInfo
                     * @param {Object} spread
                     * @return {boolean} indicate whether or not the contextmenu event has been processed done
                     * @example
                     *    var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                     *    function ContextMenu(){}
                     *    ContextMenu.prototype = new GCTYPE.Spread.Sheets.ContextMenu.ContextMenu(spread);
                     *    ContextMenu.prototype.onOpenMenu = function (menuData, itemsDataForShown, hitInfo, spread) {
                     *           console.log(menuData);
                     *           console.log(itemsDataForShown);
                     *           console.log(hitInfo);
                     *           console.log(spread);
                     *           //you can change itemsDataForShown to change filter result
                     *           //if you only want to change filter result,return false or don't return anything
                     *           //you also can open your own context menu,if you want to do this,return true
                     *           //return true;
                     *    };
                     *    var contextMenu = new ContextMenu();
                     *    spread.contextMenu = contextMenu;
                     */
                    onOpenMenu(menuData: GCTYPE.Spread.Sheets.ContextMenu.IMenuItemData[],  itemsDataForShown: GCTYPE.Spread.Sheets.ContextMenu.IMenuItemData[],  hitInfo: Object,  spread: Object): boolean;
                }

                export class MenuView{
                    /**
                     * Represents MenuView
                     * @class
                     */
                    constructor();
                    /**
                     * create menuitem view
                     * @param {GCTYPE.Spread.Sheets.ContextMenu.IMenuItemData} menuItemData the data of the menu item which needs to be shown
                     * @return {HTMLElement} menuitem view
                     * @example
                     * $(document).ready(function () {
                     *    var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                     *    function CustomMenuView() {
                     *   }
                     *   CustomMenuView.prototype = new GCTYPE.Spread.Sheets.ContextMenu.MenuView();
                     *   CustomMenuView.prototype.createMenuItemElement = function (menuItemData) {
                     *      var self = this;
                     *      var menuItemView = GCTYPE.Spread.Sheets.ContextMenu.MenuView.prototype.createMenuItemElement.call(self, menuItemData);
                     *      if (menuItemData.name === "markWithABg") {
                     *          var subMenuView = menuItemView.find(".gc-ui-contextmenu-container");
                     *          $(subMenuView[0]).colorpicker();
                     *      }
                     *      return menuItemView;
                     *  };
                     * });
                     */
                    createMenuItemElement(menuItemData: GCTYPE.Spread.Sheets.ContextMenu.IMenuItemData):HTMLElement;
                    /**
                     * get command options of specified menu item
                     * @param {Object} menuItemData the data of the menu item which be clicked
                     * @param {HTMLElement} host the container of the menu item which be clicked
                     * @param {Object} event the mouse click event
                     * @return {Object} command options of specified menu item
                     * @example
                     *   var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                     *   function CustomMenuView() {
                     *   }
                     *   CustomMenuView.prototype = new GCTYPE.Spread.Sheets.ContextMenu.MenuView();
                     *   CustomMenuView.prototype.getCommandOptions = function (menuItemData, host, event) {
                     *      if (menuItemData &amp;&amp; menuItemData.name === "markWithABg") {
                     *          var ele = event.target || event.srcElement;
                     *          if (ele.className.indexOf("colorpicker-div-inner-colorcell") !== -1) {
                     *              ele = ele.parentElement;
                     *          }
                     *          return ele.style.background;
                     *      }
                     *   };
                     */
                    getCommandOptions(menuItemData: GCTYPE.Spread.Sheets.ContextMenu.IMenuItemData,  host: Object,  event: Object): any;
                }
            }

            module DataValidation{
                /**
                 * Creates a validator based on the data.
                 * @static
                 * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators} typeOperator The type of ComparisonOperators compare operator.
                 * @param {object} v1 The first object.
                 * @param {object} v2 The second object.
                 * @returns {GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} The validator.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GCTYPE.Spread.Sheets.DataValidation.createDateValidator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between, new Date(2012, 11, 31), new Date(2013, 11, 31));
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Enter a date between 12/31/2012 and 12/31/2013.");
                 * dv.inputTitle("Tip");
                 * activeSheet.getCell(1, -1).validator(dv);
                 */
                function createDateValidator(typeOperator: GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators,  v1: Object,  v2: Object): GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator;
                /**
                 * Creates a validator based on a formula list.
                 * @static
                 * @param {string} formula The formula list.
                 * @returns {GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} The validator.
                 * @example
                 * activeSheet.setValue(0, 2, 5);
                 * activeSheet.setValue(1, 2, 4);
                 * activeSheet.setValue(2, 2, 5);
                 * spread.options.highlightInvalidData = true;
                 * var dv = GCTYPE.Spread.Sheets.DataValidation.createFormulaListValidator("$C$1:$C$3");
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Pick a value from the list.");
                 * dv.inputTitle("tip");
                 * activeSheet.setDataValidator(1, 1, 1,1,dv,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * var validList = activeSheet.getDataValidator(1, 1).getValidList(activeSheet, 1, 1);
                 * alert(validList);
                 */
                function createFormulaListValidator(formula: string): GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator;
                /**
                 * Creates a validator based on a formula.
                 * @static
                 * @param {string} formula The formula condition.
                 * @returns {GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} The validator.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * //The formula validator is valid if the formula condition returns true.
                 * var dv = GCTYPE.Spread.Sheets.DataValidation.createFormulaValidator("A1>0");
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Enter a value greater than 0 in A1.");
                 * dv.inputTitle("Tip");
                 * activeSheet.setDataValidator(0, 0, 1,1,dv,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                function createFormulaValidator(formula: string): GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator;
                /**
                 * Creates a validator based on a list.
                 * @static
                 * @param {string} source The list value.
                 * @returns {GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} The validator.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GCTYPE.Spread.Sheets.DataValidation.createListValidator("1,2,3");
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Value must be 1,2 or 3");
                 * dv.inputTitle("tip");
                 * activeSheet.setDataValidator(1,1,1,1,dv, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 * alert(activeSheet.getDataValidator(1,1).getValidList(activeSheet,1,1));
                 */
                function createListValidator(source: string): GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator;
                /**
                 * Creates a validator based on numbers.
                 * @static
                 * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators} typeOperator The type of ComparisonOperators compare operator.
                 * @param {object} v1 The first object.
                 * @param {object} v2 The second object.
                 * @param {boolean} isIntegerValue Set to <c>true</c> if the validator is set to a number.
                 * @returns {GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} The validator.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GCTYPE.Spread.Sheets.DataValidation.createNumberValidator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between, "5", "20", true);
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Value must be between 5 and 20.");
                 * dv.inputTitle("tip");
                 * activeSheet.setDataValidator(1, 1, 1,1,dv,GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                function createNumberValidator(typeOperator: GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators,  v1: Object,  v2: Object,  isIntegerValue: boolean): GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator;
                /**
                 * Creates a validator based on text length.
                 * @static
                 * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators} typeOperator The type of ComparisonOperators compare operator.
                 * @param {object} v1 The first object.
                 * @param {object} v2 The second object.
                 * @returns {GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} The validator.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GCTYPE.Spread.Sheets.DataValidation.createTextLengthValidator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan, "4", "20");
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Number of characters must be greater than 4.");
                 * dv.inputTitle("tip");
                 * activeSheet.setDataValidator(1, 1, 1, 1, dv, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                function createTextLengthValidator(typeOperator: GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators,  v1: Object,  v2: Object): GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator;
                /**
                 * Creates a validator based on the time.
                 * @static
                 * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators} typeOperator The type of ComparisonOperators compare operator.
                 * @param {object} v1 The first object.
                 * @param {object} v2 The second object.
                 * @returns {GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} The validator.
                 * @example
                 * spread.options.highlightInvalidData = true;
                 * var dv = GCTYPE.Spread.Sheets.DataValidation.createTimeValidator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.between, '9:08:09', '19:08:09');
                 * dv.showInputMessage(true);
                 * dv.inputMessage("Enter a time between 9:08:09 and 19:08:09.");
                 * dv.inputTitle("Tip");
                 * sheet.setDataValidator(1, 1, dv);
                 */
                function createTimeValidator(typeOperator: GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators,  v1: Object,  v2: Object): GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator;
                /**
                 * Indicates the data validator criteria type.
                 * @enum {number}
                 * @example
                 * //This example uses the CriteriaType enumeration.
                 * var textLengthCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.textLengthCondition);
                 * textLengthCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators.greaterThan);
                 * textLengthCondition.formula("$C$1"); // formula used to calculate a number.
                 * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(textLengthCondition);
                 * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                 * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                 * spread.options.highlightInvalidData = true;
                 * activeSheet.setValue(0, 0, "abcf");
                 * //Set value 3 to $C$1, after this code, the value in Cell(0,0) is valid.
                 * activeSheet.setValue(0, 2, 3);
                 * //Set value 5 to $C$1, after this code, the value in Cel(0,0) is invalid.
                 * // activeSheet.setValue(0, 2, 5);
                 */
                export enum CriteriaType{
                    /**
                     * Specifies that the data validation allows any type of value and does not check for a type or range of values.
                     */
                    anyValue= 0,
                    /**
                     * Specifies that the data validation checks for and allows whole number values satisfying the given condition.
                     */
                    wholeNumber= 1,
                    /**
                     * Specifies that the data validation checks for and allows decimal values satisfying the given condition.
                     */
                    decimalValues= 2,
                    /**
                     * Specifies that the data validation checks for and allows a value that matches one in a list of values.
                     */
                    list= 3,
                    /**
                     * Specifies that the data validation checks for and allows date values satisfying the given condition.
                     */
                    date= 4,
                    /**
                     * Specifies that the data validation checks for and allows time values satisfying the given condition.
                     */
                    time= 5,
                    /**
                     * Specifies that the data validation checks for and allows text values whose length satisfies the given condition.
                     */
                    textLength= 6,
                    /**
                     * Specifies that the data validation uses a custom formula to check the cell value.
                     */
                    custom= 7
                }

                /**
                 * Indicates the data validation result.
                 * @enum {number}
                 */
                export enum DataValidationResult{
                    /**
                     * Indicates to apply the value to a cell for a validation error.
                     */
                    forceApply= 0,
                    /**
                     * Indicates to discard the value and not apply it to the cell for a validation error.
                     */
                    discard= 1,
                    /**
                     * Indicates to retry multiple times to apply the value to the cell for a validation error.
                     */
                    retry= 2
                }

                /**
                 * Indicates the data validation error style.
                 * @enum {number}
                 */
                export enum ErrorStyle{
                    /**
                     * Specifies to use a stop icon in the error alert.
                     */
                    stop= 0,
                    /**
                     * Specifies to use a warning icon in the error alert.
                     */
                    warning= 1,
                    /**
                     * Specifies to use an information icon in the error alert.
                     */
                    information= 2
                }

                /**
                 * Indicates the data validation highlightposition.
                 * @enum {number}
                 */
                export enum HighlightPosition{
                    /**
                     * Specifies highlight flag on the topleft of the invalid data cell.
                     */
                    topLeft= 0,
                    /**
                     * Specifies highlight flag on the topright of the invalid data cell.
                     */
                    topRight= 1,
                    /**
                     * Specifies highlight flag on the bottomright of the invalid data cell.
                     */
                    bottomRight= 2,
                    /**
                     * Specifies highlight flag on the bottomleft of the invalid data cell.
                     */
                    bottomLeft= 3,
                    /**
                     * Specifies image which type is icon on the left of the invalid data cell.
                     */
                    outsideLeft= 4,
                    /**
                     * Specifies  image which type is icon on the Right of the invalid data cell.
                     */
                    outsideRight= 5
                }

                /**
                 * Indicates the data validation highlightType.
                 * @enum {number}
                 */
                export enum HighlightType{
                    /**
                     * Specifies to use a circle in the invalid data cell.
                     */
                    circle= 0,
                    /**
                     * Specifies to use a dogEar in the invalid data cell.
                     */
                    dogEar= 1,
                    /**
                     * Specifies to use a icon in the invalid data cell.
                     */
                    icon= 2
                }


                export class DefaultDataValidator{
                    /**
                     * Represents a data validator.
                     * @class
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} condition The condition.
                     * @example
                     * //This example validates the cell data.
                     * spread.options.highlightInvalidData = true;
                     * var dv = GCTYPE.Spread.Sheets.DataValidation.createTextLengthValidator(GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators.greaterThan, 5);
                     * activeSheet.setDataValidator(0, 0, 1, 1, dv, GCTYPE.Spread.Sheets.SheetArea.viewport);
                     * activeSheet.setValue(0, 0, "abcf");
                     */
                    constructor(condition: GCTYPE.Spread.Sheets.ConditionalFormatting.Condition);
                    /**
                     * Gets or sets the comparison operator.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators} value The comparison operator.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators | GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns the comparison operator; otherwise, returns the data validator.
                     */
                    comparisonOperator(value?: GCTYPE.Spread.Sheets.ConditionalFormatting.ComparisonOperators): any;
                    /**
                     * Gets or sets the condition to validate.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} value The condition to validate.
                     * @returns {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition | GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns the condition to validate; otherwise, returns the data validator.
                     */
                    condition(value?: GCTYPE.Spread.Sheets.ConditionalFormatting.Condition): any;
                    /**
                     * Gets or sets the error message.
                     * @param {string} value The error message.
                     * @returns {string | GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns the error message; otherwise, returns the data validator.
                     */
                    errorMessage(value?: string): any;
                    /**
                     * Gets or sets the error style to display.
                     * @param {GCTYPE.Spread.Sheets.DataValidation.ErrorStyle} value The error style to display.
                     * @returns {GCTYPE.Spread.Sheets.DataValidation.ErrorStyle | GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns the error style to display; otherwise, returns the data validator.
                     */
                    errorStyle(value?: GCTYPE.Spread.Sheets.DataValidation.ErrorStyle): any;
                    /**
                     * Gets or sets the error title.
                     * @param {string} value The error title.
                     * @returns {string | GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns the error title; otherwise, returns the data validator.
                     */
                    errorTitle(value?: string): any;
                    /**
                     * Returns the valid data lists if the Data validation type is list; otherwise, returns null.
                     * @param {object} evaluator The object that can evaluate a condition.
                     * @param {number} baseRow The base row.
                     * @param {number} baseColumn The base column.
                     * @returns {Array.<Object>} The valid data lists or null.
                     */
                    getValidList(evaluator: Object,  baseRow: number,  baseColumn: number): any[];
                    /**
                     * Get or Sets the invalid data cell highlight style.
                     * @param {GCTYPE.Spread.Sheets.DataValidation.HighlightType} [style.type] - typeIndicates the data validation highlightType.
                     * @param {string} [style.color] - Indicates the data validation highlight color.
                     * @param {GCTYPE.Spread.Sheets.DataValidation.HighlightPosition} [style.position] - Indicates the data validation highlight position.
                     * @param {string} [style.image] - Indicates the data validation highlight image url or data.
                     * @returns {Object | GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns the hignlight style object; otherwise, returns the data validator.
                     * @example
                     * //This example uses the highlightStyle method.
                     * sheet.setValue(1, 1, "sss");
                     * var dv = GCTYPE.Spread.Sheets.DataValidation.createListValidator('Fruit,Vegetable,Food');
                     * dv.highlightStyle({
                     *    type:GCTYPE.Spread.Sheets.DataValidation.HighlightType.dogEar,
                     *    color:'blue',
                     *    position:GCTYPE.Spread.Sheets.DataValidation.HighlightPosition.topLeft
                     * });
                     * sheet.setDataValidator(1,1, dv);
                     * spread.options.highlightInvalidData = true;
                     */
                    highlightStyle(style?: Object): Object;
                    /**
                     * Gets or sets whether to ignore an empty value.
                     * @param {boolean} value Indicates whether to ignore the empty value.
                     * @returns {boolean | GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns whether to ignore the empty value; otherwise, returns the data validator.
                     * @example
                     * //This example uses the IgnoreBlank method.
                     * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.cellValueCondition);
                     * nCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators.equalsTo);
                     * nCondition.expected(0);
                     * //When the option is false, the validation fails and the red alert is displayed.
                     * //When the option is true, the blank cell is treated as zero and the validation is successful.
                     * nCondition.treatNullValueAsZero(false);
                     * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * validator.ignoreBlank(false);
                     * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, null);
                     */
                    ignoreBlank(value?: boolean): any;
                    /**
                     * Gets or sets whether to display a drop-down button.
                     * @param {boolean} value Indicates whether to display a drop-down button.
                     * @returns {boolean | GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns whether to display a drop-down button; otherwise, returns the data validator.
                     * @example
                     * //This example uses the inCellDropdown method.
                     * spread.options.highlightInvalidData = true;
                     * var dv = GCTYPE.Spread.Sheets.DataValidation.createListValidator("1,2,3");
                     * dv.showInputMessage(true);
                     * dv.inputMessage("Value must be 1,2 or 3");
                     * dv.inputTitle("tip");
                     * dv.inCellDropdown(true);
                     * activeSheet.setDataValidator(1,1,1,1,dv,GCTYPE.Spread.Sheets.SheetArea.viewport);
                     * var validList = activeSheet.getDataValidator(1, 1).getValidList(activeSheet, 1, 1);
                     * alert(validList);
                     */
                    inCellDropdown(value?: boolean): any;
                    /**
                     * Gets or sets the input message.
                     * @param {string} value The input message.
                     * @returns {string | GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns the input message; otherwise, returns the data validator.
                     * @example
                     * spread.options.highlightInvalidData = true;
                     * var dv = GCTYPE.Spread.Sheets.DataValidation.createListValidator("1,2,3");
                     * dv.showInputMessage(true);
                     * dv.inputMessage("Value must be 1,2 or 3");
                     * dv.inputTitle("tip");
                     * activeSheet.setDataValidator(1,1,1,1,dv,GCTYPE.Spread.Sheets.SheetArea.viewport);
                     * alert(activeSheet.getDataValidator(1,1).getValidList(activeSheet,1,1));
                     */
                    inputMessage(value?: string): any;
                    /**
                     * Gets or sets the input title.
                     * @param {string} value The input title.
                     * @returns {string | GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns the input title; otherwise, returns the data validator.
                     * @example
                     * spread.options.highlightInvalidData = true;
                     * var dv = GCTYPE.Spread.Sheets.DataValidation.createListValidator("1,2,3");
                     * dv.showInputMessage(true);
                     * dv.inputMessage("Value must be 1,2 or 3");
                     * dv.inputTitle("tip");
                     * activeSheet.setDataValidator(1,1,1,1,dv,GCTYPE.Spread.Sheets.SheetArea.viewport);
                     * alert(activeSheet.getDataValidator(1,1).getValidList(activeSheet,1,1));
                     */
                    inputTitle(value?: string): any;
                    /**
                     * Determines whether the current value is valid.
                     * @param {object} evaluator The evaluator.
                     * @param {number} baseRow The base row.
                     * @param {number} baseColumn The base column.
                     * @param {object} actual The current value.
                     * @returns {boolean} <c>true</c> if the value is valid; otherwise, <c>false</c>.
                     */
                    isValid(evaluator: Object,  baseRow: number,  baseColumn: number,  actual: Object): boolean;
                    /**
                     * Gets or sets whether to compare whole day or precise date time.
                     * @param {boolean} value Indicates compare whole day or precise date time.
                     * @returns {boolean | GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns compare whole day or precise date time; otherwise, returns the data validator.
                     * @example
                     * //This example uses the preciseCompareDate method.
                     * var dateCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.dateCondition);
                     * dateCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators.greaterThan);
                     * dateCondition.expected(new Date(2020, 4, 22, 06));
                     * //When the option is false, the validator compares the whole day, and they are the same, so validation fails and the red alert is displayed.
                     * //When the option is true, the date time 7 o'clock is greater than 6 o'clock, so the result is successful.
                     * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(dateCondition);
                     * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.date);
                     * validator.preciseCompareDate(true);
                     * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, new Date(2020, 4, 22, 07));
                     */
                    preciseCompareDate(value?: boolean): any;
                    /**
                     * Resets the data validator.
                     * @example
                     * //This example uses the reset method.
                     * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.cellValueCondition);
                     * nCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators.equalsTo);
                     * nCondition.expected(0);
                     * //When the option is false, the validation fails and the red alert is displayed.
                     * //When the option is true, the blank cell is treated as zero and the validation is successful.
                     * nCondition.treatNullValueAsZero(false);
                     * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * validator.ignoreBlank(false);
                     * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, null);
                     * validator.reset();
                     */
                    reset(): void;
                    /**
                     * Gets or sets whether to display an error message.
                     * @param {boolean} value Indicates whether to display an error message.
                     * @returns {boolean | GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns whether to display an error message; otherwise, returns the data validator.
                     * @example
                     * spread.options.highlightInvalidData = true;
                     * //The formula validator is valid if the formula condition returns true.
                     * var dv = GCTYPE.Spread.Sheets.DataValidation.createFormulaValidator("A1&gt;0");
                     * dv.showInputMessage(true);
                     * dv.inputMessage("Enter a value greater than 0 in A1.");
                     * dv.inputTitle("Tip");
                     * dv.showErrorMessage(true);
                     * dv.errorMessage("Incorrect Value");
                     * activeSheet.setDataValidator(0, 0, 1, 1, dv, GCTYPE.Spread.Sheets.SheetArea.viewport);
                     * //bind
                     * activeSheet.bind(GCTYPE.Spread.Sheets.Events.ValidationError, function (sender, args) {
                     *     if (args.validator.showErrorMessage()) {
                     *         if (confirm(args.validator.errorMessage())) {
                     *             args.validationResult = GCTYPE.Spread.Sheets.DataValidation.DataValidationResult.retry;
                     *         } else {
                     *             args.validationResult = GCTYPE.Spread.Sheets.DataValidation.DataValidationResult.forceApply;
                     *         }
                     *     }
                     * });
                     */
                    showErrorMessage(value?: boolean): any;
                    /**
                     * Gets or sets whether to display the input title and input message.
                     * @param {boolean} value Indicates whether to display the input title and input message.
                     * @returns {boolean | GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns whether to display the input title and input message; otherwise, returns the data validator.
                     * @example
                     * spread.options.highlightInvalidData = true;
                     * var dv = GCTYPE.Spread.Sheets.DataValidation.createListValidator("1,2,3");
                     * dv.showInputMessage(true);
                     * dv.inputMessage("Value must be 1,2 or 3");
                     * dv.inputTitle("tip");
                     * activeSheet.setDataValidator(1,1,1,1,dv,GCTYPE.Spread.Sheets.SheetArea.viewport);
                     * alert(activeSheet.getDataValidator(1,1).getValidList(activeSheet,1,1));
                     */
                    showInputMessage(value?: boolean): any;
                    /**
                     * Gets or sets the criteria type of this data validator.
                     * @param {GCTYPE.Spread.Sheets.DataValidation.CriteriaType} value The criteria type of this data validator.
                     * @returns {GCTYPE.Spread.Sheets.DataValidation.CriteriaType | GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator} If no value is set, returns the criteria type of this data validator; otherwise, returns the data validator.
                     */
                    type(value?: GCTYPE.Spread.Sheets.DataValidation.CriteriaType): any;
                    /**
                     * Gets the first value of the data validation.
                     * @param {number} baseRow The base row.
                     * @param {number} baseColumn The base column.
                     * @returns {object} The first value.
                     * @example
                     * //This example validates a cell value.
                     * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.cellValueCondition);
                     * nCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators.equalsTo);
                     * nCondition.expected(0);
                     * //When the option is false, the validation fails and the red alert is displayed.
                     * //When the option is true, the blank cell is treated as zero and the validation is successful.
                     * nCondition.treatNullValueAsZero(false);
                     * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * validator.ignoreBlank(false);
                     * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, null);
                     * alert(validator.value1());
                     */
                    value1(baseRow ?: number,  baseColumn ?: number): any;
                    /**
                     * Gets the second value of the data validation.
                     * @param {number} baseRow The base row.
                     * @param {number} baseColumn The base column.
                     * @returns {object} The second value.
                     * @example
                     * //This example validates a cell value.
                     * var nCondition = new GCTYPE.Spread.Sheets.ConditionalFormatting.Condition(GCTYPE.Spread.Sheets.ConditionalFormatting.ConditionType.cellValueCondition);
                     * nCondition.compareType(GCTYPE.Spread.Sheets.ConditionalFormatting.GeneralComparisonOperators.equalsTo);
                     * nCondition.expected(0);
                     * //When the option is false, the validation fails and the red alert is displayed.
                     * //When the option is true, the blank cell is treated as zero and the validation is successful.
                     * nCondition.treatNullValueAsZero(false);
                     * var validator = new GCTYPE.Spread.Sheets.DataValidation.DefaultDataValidator(nCondition);
                     * validator.type(GCTYPE.Spread.Sheets.DataValidation.CriteriaType.custom);
                     * validator.ignoreBlank(false);
                     * activeSheet.getCell(0, 0, GCTYPE.Spread.Sheets.SheetArea.viewport).validator(validator);
                     * spread.options.highlightInvalidData = true;
                     * activeSheet.setValue(0, 0, null);
                     * alert(validator.value2());
                     */
                    value2(baseRow ?: number,  baseColumn ?: number): any;
                }
            }

            module Fill{

                export interface IFillOptions{
                    fillType: GCTYPE.Spread.Sheets.Fill.FillType;
                    series: GCTYPE.Spread.Sheets.Fill.FillSeries;
                    direction?: GCTYPE.Spread.Sheets.Fill.FillDirection;
                    step?: number;
                    stop?: number;
                    unit?: GCTYPE.Spread.Sheets.Fill.FillDateUnit;
                }

                // <editor-fold desc="AutoFillType">
                 /**
                 * Represents the type of drag fill.
                 * @enum {number}
                 * @example
                 * //This example uses the AutoFillType enumeration.
                 * activeSheet.bind(GCTYPE.Spread.Sheets.Events.DragFillBlockCompleted, function (e, info) {
                 *         alert("Type (" + info.autoFillType + ")");
                 * });
                 */
                export enum AutoFillType{
                    /**
                     *  Fills cells with all data objects, including values, formatting, and formulas.
                     */
                    copyCells= 0,
                    /**
                     *   Fills cells with series.
                     */
                    fillSeries= 1,
                    /**
                     *   Fills cells only with formatting.
                     */
                    fillFormattingOnly= 2,
                    /**
                     *   Fills cells with values and not formatting.
                     */
                    fillWithoutFormatting= 3,
                    /**
                     *  Clears cell values.
                     */
                    clearValues= 4,
                    /**
                     *  Automatically fills cells.
                     */
                    auto= 5
                }

                // <editor-fold desc="FillDateUnit">
                 /**
                 * Represents the date fill unit.
                 * @enum {number}
                 * @example
                 * //This example uses the FillDateUnit enumeration.
                 * spread.options.allowUserDragFill = true;
                 * activeSheet.setValue(0, 0, new Date(2011, 1, 1));
                 * activeSheet.setValue(0, 1, new Date(2011, 2, 9));
                 * activeSheet.setValue(0, 2, 5);
                 * activeSheet.setValue(0, 3, 10);
                 * activeSheet.setValue(0, 4, 1);
                 *
                 * var start = new GCTYPE.Spread.Sheets.Range(0, 0, 1, 1);
                 * var r = new GCTYPE.Spread.Sheets.Range(0, 0, 4, 1);
                 * activeSheet.fillAuto(start, r, {
                 *     fillType: GCTYPE.Spread.Sheets.Fill.FillType.date,
                 *     series: GCTYPE.Spread.Sheets.Fill.FillSeries.column,
                 *     fillDirection: GCTYPE.Spread.Sheets.Fill.FillDirection.down,
                 *     unit: GCTYPE.Spread.Sheets.Fill.FillDateUnit.day,
                 *     step: 1,
                 *     stop: new Date(2011, 2, 11)
                 * });
                 *
                 * start = new GCTYPE.Spread.Sheets.Range(0, 1, 1, 1);
                 * var r2 = new GCTYPE.Spread.Sheets.Range(0, 1, 4, 1);
                 * activeSheet.fillAuto(start, r2, {
                 * fillType: GCTYPE.Spread.Sheets.Fill.FillType.date,
                 * series: GCTYPE.Spread.Sheets.Fill.FillSeries.column,
                 * fillDirection:GCTYPE.Spread.Sheets.Fill.FillDirection.down,
                 * unit: GCTYPE.Spread.Sheets.Fill.FillDateUnit.day,
                 * step: 1,
                 * stop: new Date(2011, 2, 11)
                 * });
                 *
                 * start = new GCTYPE.Spread.Sheets.Range(0, 2, 1, 1);
                 * var r3 = new GCTYPE.Spread.Sheets.Range(0, 2, 4, 1);
                 * activeSheet.fillAuto(start, r3, {
                 *     fillType: GCTYPE.Spread.Sheets.Fill.FillType.auto,
                 *     series: GCTYPE.Spread.Sheets.Fill.FillSeries.column,
                 * });
                 *
                 * start = new GCTYPE.Spread.Sheets.Range(0, 3, 1, 1);
                 * var r4 = new GCTYPE.Spread.Sheets.Range(0, 3, 4, 1);
                 * activeSheet.fillAuto(start, r4, {
                 *     fillType: GCTYPE.Spread.Sheets.Fill.FillType.growth,
                 *     series: GCTYPE.Spread.Sheets.Fill.FillSeries.column,
                 *     step:2,
                 *     stop:55
                 * });
                 *
                 * start = new GCTYPE.Spread.Sheets.Range(0, 4, 1, 1);
                 * var r5 = new GCTYPE.Spread.Sheets.Range(0, 4, 4, 1);
                 * activeSheet.fillAuto(start, r5, {
                 *     fillType: GCTYPE.Spread.Sheets.Fill.FillType.linear,
                 *     series: GCTYPE.Spread.Sheets.Fill.FillSeries.column,
                 *     step:3,
                 *     stop:20
                 * });
                 *
                 * activeSheet.setValue(0, 5, 123);
                 * var r6 = new GCTYPE.Spread.Sheets.Range(0, 5, 4, 1);
                 * activeSheet.fillAuto(new GCTYPE.Spread.Sheets.Range(0, 5, 1, 1), r6, {
                 *     fillType: GCTYPE.Spread.Sheets.Fill.FillType.auto,
                 *     series: GCTYPE.Spread.Sheets.Fill.FillSeries.column,
                 * });
                 */
                export enum FillDateUnit{
                    /** Sets the date fill unit to day.
                     * @type {number}
                     */
                    day= 0,
                    /** Sets the date fill unit to weekday.
                     * @type {number}
                     */
                    weekday= 1,
                    /** Sets the date fill unit to month.
                     * @type {number}
                     */
                    month= 2,
                    /** Sets the date fill unit to year.
                     * @type {number}
                     */
                    year= 3
                }

                // <editor-fold desc="FillDirection">
                 /**
                 * Represents the type of drag fill direction.
                 * @enum {number}
                 * @example
                 * var start = new GCTYPE.Spread.Sheets.Range(0, 2, 1, 1);
                 * activeSheet.setValue(0, 2, 5);
                 * var r3 = new GCTYPE.Spread.Sheets.Range(0, 2, 4, 1);
                 * activeSheet.fillAuto(start, r3, {fillType: GCTYPE.Spread.Sheets.Fill.FillType.auto, fillDirection:GCTYPE.Spread.Sheets.Fill.FillDirection.down, series: GCTYPE.Spread.Sheets.Fill.FillSeries.column});
                 */
                export enum FillDirection{
                    /**
                     *  Fills from the right to the left.
                     */
                    left= 0,
                    /**
                     *  Fills from the left to the right.
                     */
                    right= 1,
                    /**
                     *  Fills from the bottom to the top.
                     */
                    up= 2,
                    /**
                     *   Fills from the top to the bottom.
                     */
                    down= 3
                }

                // <editor-fold desc="FillSeries">
                 /**
                 * Represents the fill series for drag fill.
                 * @enum {number}
                 * @example
                 * //This example automatically fills the data in an area of the sheet.
                 * activeSheet.setValue(0, 0, 5);
                 * var start = new GCTYPE.Spread.Sheets.Range(0, 0, 1, 1);
                 * var r3 = new GCTYPE.Spread.Sheets.Range(0, 0, 4, 1);
                 * activeSheet.fillAuto(start,r3, {fillType:GCTYPE.Spread.Sheets.Fill.FillType.auto, series:GCTYPE.Spread.Sheets.Fill.FillSeries.column, fillDirection:GCTYPE.Spread.Sheets.Fill.FillDirection.down});
                 */
                export enum FillSeries{
                    /**
                     *  Fills the column data.
                     */
                    column= 0,
                    /**
                     *  Fills the row data.
                     */
                    row= 1
                }

                // <editor-fold desc="FillType">
                 /**
                 * Represents the type of fill data.
                 * @enum {number}
                 */
                export enum FillType{
                    /** Represents the direction fill type.
                     * @type {number}
                     */
                    direction= 0,
                    /** Represents the linear fill type.
                     * @type {number}
                     */
                    linear= 1,
                    /** Represents the growth fill type.
                     * @type {number}
                     */
                    growth= 2,
                    /** Represents the date fill type.
                     * @type {number}
                     */
                    date= 3,
                    /** Represents the auto fill type.
                     * @type {number}
                     */
                    auto= 4
                }

            }

            module Filter{

                export interface IFilterDialogVisibleInfo{
                    sortByValue? : boolean,
                    sortByColor? : boolean,
                    filterByColor? : boolean,
                    filterByValue? : boolean,
                    listFilterArea? : boolean
                }


                export interface IFilteredArgs{
                    action: FilterActionType;
                    sheet: Sheets.Worksheet;
                    range: Sheets.Range;
                    filteredRows: number[];
                    filteredOutRows: number[];
                    columns: number;
                }

                /**
                 * Defines the type of filter action.
                 * @enum {number}
                 */
                export enum FilterActionType{
                    /** Specifies the filter action.
                     */
                    filter= 0,
                    /** Specifies the unfilter action.
                     */
                    unfilter= 1
                }


                export class HideRowFilter extends RowFilterBase{
                    /**
                     * Represents a default row filter.
                     * @class GCTYPE.Spread.Sheets.Filter.HideRowFilter
                     * @extends GCTYPE.Spread.Sheets.Filter.RowFilterBase
                     * @param {GCTYPE.Spread.Sheets.Range} range The filter range.
                     * @example
                     * //The following example creates a new filter.
                     * sheet.rowFilter(new GCTYPE.Spread.Sheets.Filter.HideRowFilter(new GCTYPE.Spread.Sheets.Range(0,0,4,4)));
                     * sheet.repaint();
                     */
                    constructor(range?: GCTYPE.Spread.Sheets.Range);
                    /**
                     * Gets or sets the visible info for the row filter.
                     * @param {Object} visibleInfo The visible info for row filter.
                     * @param {boolean} [visibleInfo.sortByValue] Whether to show the sort by value area in filter dialog.
                     * @param {boolean} [visibleInfo.sortByColor] Whether to show the sort by color area in filter dialog.
                     * @param {boolean} [visibleInfo.filterByColor] Whether to show the filter by color area in filter dialog.
                     * @param {boolean} [visibleInfo.filterByValue] Whether to show the filter by value area in filter dialog.
                     * @param {boolean} [visibleInfo.listFilterArea] Whether to show the list filter in filter dialog.
                     * @returns {Object | GCTYPE.Spread.Sheets.Filter.HideRowFilter} If no value is set filter dialog visible info; otherwise, returns the HideRowFilter.
                     * @example
                     * //This example creates a row filter.
                     *  sheet.rowFilter(new GCTYPE.Spread.Sheets.Filter.HideRowFilter(new GCTYPE.Spread.Sheets.Range(1,1,10,3)));
                     *  var filter = sheet.rowFilter();
                     *  filter.filterDialogVisibleInfo({
                     *           sortByValue : false,
                     *           sortByColor : true,
                     *           filterByColor : true,
                     *           filterByValue : true,
                     *           listFilterArea : false
                     *       })
                     */
                    filterDialogVisibleInfo(visibleInfo?: GCTYPE.Spread.Sheets.Filter.IFilterDialogVisibleInfo): any;
                }

                export class RowFilterBase{
                    /**
                     * Represents a row filter base that supports row filters for filtering rows in a sheet.
                     * @class GCTYPE.Spread.Sheets.Filter.RowFilterBase
                     * @param {GCTYPE.Spread.Sheets.Range} range The filter range.
                     */
                    constructor(range?: GCTYPE.Spread.Sheets.Range);
                    /**
                     * Represents the range for the row filter.
                     * @type {GCTYPE.Spread.Sheets.Range}
                     */
                    range: GCTYPE.Spread.Sheets.Range;
                    /**
                     * Represents the type name string used for supporting serialization.
                     * @type {string}
                     */
                    typeName: string;
                    /**
                     * Adds a specified filter to the row filter.
                     * @param {number} col The column index.
                     * @param {GCTYPE.Spread.Sheets.ConditionalFormatting.Condition} condition The condition to filter.
                     */
                    addFilterItem(col: number,  condition: GCTYPE.Spread.Sheets.ConditionalFormatting.Condition): void;
                    /**
                     * Filters the specified column.
                     * @param {number} col The index of the column to be filtered; if it is omitted, all the columns in the range will be filtered.
                     */
                    filter(col?: number): void;
                    /**
                     * Gets or sets whether the sheet column's filter button is displayed.
                     * @param {number} col The column index of the filter button.
                     * @param {boolean} value Whether the filter button is displayed.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Filter.RowFilterBase}
                     *      No parameter <c>false</c> if all filter buttons are invisible; otherwise, <c>true</c>.
                     *      One parameter col <c>false</c> if the specified column filter button is invisible; otherwise, <c>true</c>.
                     *      One parameter value <c>GCTYPE.Spread.Sheets.Filter.RowFilterBase</c> sets all filter buttons to be visible(true)/invisible(false).
                     *      Two parameters col,value <c>GCTYPE.Spread.Sheets.Filter.RowFilterBase</c> sets the specified column filter button to be visible(true)/invisible(false).
                     */
                    filterButtonVisible(col?: number,  value?: boolean): any;
                    /**
                     * Loads the object state from the specified JSON string.
                     * @param {object} settings The row filter data from deserialization.
                     */
                    fromJSON(settings: Object): void;
                    /**
                     * Gets all the filtered conditions.
                     * @returns {Array.<GCTYPE.Spread.Sheets.ConditionalFormatting.Condition>} Returns a collection that contains all the filtered conditions.
                     */
                    getFilteredItems(): GCTYPE.Spread.Sheets.ConditionalFormatting.Condition[];
                    /**
                     * Gets the filters for the specified column.
                     * @param {number} col The column index.
                     * @returns {Array.<GCTYPE.Spread.Sheets.ConditionalFormatting.Condition>} Returns a collection that contains conditions that belong to a specified column.
                     */
                    getFilterItems(col: number): GCTYPE.Spread.Sheets.ConditionalFormatting.Condition[];
                    /**
                     * Gets the current sort state.
                     * @param {number} col The column index.
                     * @returns {GCTYPE.Spread.Sheets.SortState} The sort state of the current filter.
                     */
                    getSortState(col: number): GCTYPE.Spread.Sheets.SortState;
                    /**
                     * Gets a value that indicates whether any row or specified column is filtered.
                     * @param {number} col The column index.
                     * @returns {boolean}  No parameter <c>true</c> if some rows are filtered; otherwise, <c>false</c>.
                     *                     One parameter col <c>true</c> if the specified column is filtered; otherwise, <c>false</c>.
                     * @example
                     * //This example uses the isFiltered method.
                     * activeSheet.setValue(0, 0, "North");
                     * activeSheet.setValue(1, 0, "South");
                     * activeSheet.setValue(2, 0, "East");
                     * activeSheet.setValue(3, 0, "South");
                     * activeSheet.setValue(4, 0, "North");
                     * activeSheet.setValue(5, 0, "North");
                     * activeSheet.setValue(6, 0, "West");
                     * activeSheet.setColumnWidth(0, 80);
                     * //Set a row filter.
                     * activeSheet.rowFilter(new GCTYPE.Spread.Sheets.Filter.HideRowFilter(new GCTYPE.Spread.Sheets.Range(0, 0, 7, 1)));
                     * //button
                     * $("#button1").click(function () {
                     *     var rowFilter = spread.getActiveSheet().rowFilter();
                     *     if (rowFilter.isFiltered(0)) {
                     *         alert("Row-filtering executed for Column1");
                     *     } else {
                     *         alert("Row-filtering not executed for Column1");
                     *     }
                     * });
                     * //Add button control to page
                     * &lt;input type="button" id="button1" value="button1"/&gt;
                     */
                    isFiltered(col?: number): boolean;
                    /**
                     * Determines whether the specified row is filtered out.
                     * @param {number} row The row index.
                     * @returns {boolean} <c>true</c> if the row is filtered out; otherwise, <c>false</c>.
                     */
                    isRowFilteredOut(row: number): boolean;
                    /**
                     * Performs the action when some columns have just been filtered or unfiltered.
                     * @param {object} args An object that contains the <i>action</i>, <i>sheet</i>, <i>range</i>, <i>filteredRows</i>, and <i>filteredOutRows</i>. See the Remarks for additional information.
                     */
                    onFilter(args: GCTYPE.Spread.Sheets.Filter.IFilteredArgs): void;
                    /**
                     * Opens the filter dialog when the user clicks the filter button.
                     * @param {GCTYPE.Spread.Sheets.IFilterButtonHitInfo} filterButtonHitInfo The hit test information about the filter button.
                     */
                    openFilterDialog(filterButtonHitInfo: GCTYPE.Spread.Sheets.IFilterButtonHitInfo): void;
                    /**
                     * Removes the specified filter.
                     * @param {number} col The column index.
                     */
                    removeFilterItems(col: number): void;
                    /**
                     * Clears all filters.
                     */
                    reset(): void;
                    /**
                     * Sorts the specified column in the specified order.
                     * @param {number} col The column index.
                     * @param {boolean} ascending Set to <c>true</c> to sort as ascending.
                     */
                    sortColumn(col: number,  ascending: boolean): void;
                    /**
                     * Saves the object state to a JSON string.
                     * @returns {object} The row filter data.
                     */
                    toJSON(): Object;
                    /**
                     * Removes the filter from the specified column.
                     * @param {number} col The index of the column for which to remove the filter; if it is omitted, removes the filter for all columns in the range.
                     */
                    unfilter(col?: number): void;
                }
            }

            module FloatingObjects{

                export class FloatingObject{
                    /**
                     * Represents a floating object.
                     * @class
                     * @param {string} name The name of the floating object.
                     * @param {number} x The <i>x</i> location of the floating object.
                     * @param {number} y The <i>y</i> location of the floating object.
                     * @param {number} width The width of the floating object.
                     * @param {number} height The height of the floating object.
                     * @remarks
                     * This is a base class that is intended for internal use.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    constructor(name: string,  x: number,  y: number,  width: number,  height: number);
                    /** Represents the type name string used for supporting serialization.
                     * @type {string}
                     */
                    typeName: string;
                    /**
                     * Gets or sets whether to disable moving the floating object.
                     * @param {boolean} value The setting for whether to disable moving the floating object.
                     * @returns {boolean | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the setting for whether to disable moving the floating object; otherwise, returns the floating object.
                     * @example
                     * //This example prevents you from moving or resizing the floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.allowResize(false);
                     * customFloatingObject.allowMove(false);
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    allowMove(value?: boolean): any;
                    /**
                     * Gets or sets whether to disable resizing the floating object.
                     * @param {boolean} value The setting for whether to disable resizing the floating object.
                     * @returns {boolean | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the setting for whether to disable resizing the floating object; otherwise, returns the floating object.
                     * @example
                     * //This example prevents you from moving or resizing the floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.allowResize(false);
                     * customFloatingObject.allowMove(false);
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    allowResize(value?: boolean): any;
                    /**
                     * Gets or sets the alternative text of the floating object for screen readers.
                     * @param {string} value The alternative text of the floating object.
                     * @returns {string} The alternative text of the floating object.
                     */
                    alt(value?: string): any;
                    /**
                     * Gets a copy of the current content of the instance.
                     * @returns {HTMLElement} A copy of the current content of the instance.
                     */
                    cloneContent(): HTMLElement;
                    /**
                     * Gets or sets the content of the custom floating object.
                     * @param {HTMLElement} value The content of the custom floating object.
                     * @returns {HTMLElement | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the content of the custom floating object; otherwise, returns the floating object.
                     */
                    content(value?: HTMLElement): any;
                    /**
                     * Gets or sets whether the object moves when hiding or showing, resizing, or moving rows or columns.
                     * @param {boolean} value The value indicates whether the object moves when hiding or showing, resizing, or moving rows or columns.
                     * @returns {boolean | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns whether this floating object dynamically moves; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * customFloatingObject.isVisible(true);
                     * customFloatingObject.dynamicSize(true);
                     * customFloatingObject.dynamicMove(true);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    dynamicMove(value?: boolean): any;
                    /**
                     * Gets or sets whether the size of the object changes when hiding or showing, resizing, or moving rows or columns.
                     * @param {boolean} value The value indicates whether the size of the object changes when hiding or showing, resizing, or moving rows or columns.
                     * @returns {boolean | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns whether this floating object dynamically changes size; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * customFloatingObject.isVisible(true);
                     * customFloatingObject.dynamicSize(true);
                     * customFloatingObject.dynamicMove(true);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    dynamicSize(value?: boolean): any;
                    /**
                     * Gets or sets the end column index of the floating object position.
                     * @param {number} value The end column index of the floating object position.
                     * @returns {number | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the end column index of the floating object position; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * //takes effect when added into the sheet.
                     * customFloatingObject.startRow(2);
                     * customFloatingObject.startColumn(2);
                     * customFloatingObject.startRowOffset(10);
                     * customFloatingObject.startColumnOffset(10);
                     * customFloatingObject.endRow(7);
                     * customFloatingObject.endColumn(5);
                     * customFloatingObject.endRowOffset(10);
                     * customFloatingObject.endColumnOffset(10);
                     */
                    endColumn(value?: number): any;
                    /**
                     * Gets or sets the offset relative to the end column of the floating object.
                     * @param {number} value The offset relative to the end column of the floating object.
                     * @returns {number | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the offset relative to the end column of the floating object; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * //takes effect when added into the sheet.
                     * customFloatingObject.startRow(2);
                     * customFloatingObject.startColumn(2);
                     * customFloatingObject.startRowOffset(10);
                     * customFloatingObject.startColumnOffset(10);
                     * customFloatingObject.endRow(7);
                     * customFloatingObject.endColumn(5);
                     * customFloatingObject.endRowOffset(10);
                     * customFloatingObject.endColumnOffset(10);
                     */
                    endColumnOffset(value?: number): any;
                    /**
                     * Gets or sets the end row index of the floating object position.
                     * @param {number} value The end row index of the floating object position.
                     * @returns {number | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the end row index of the floating object position; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * //takes effect when added into the sheet.
                     * customFloatingObject.startRow(2);
                     * customFloatingObject.startColumn(2);
                     * customFloatingObject.startRowOffset(10);
                     * customFloatingObject.startColumnOffset(10);
                     * customFloatingObject.endRow(7);
                     * customFloatingObject.endColumn(5);
                     * customFloatingObject.endRowOffset(10);
                     * customFloatingObject.endColumnOffset(10);
                     */
                    endRow(value?: number): any;
                    /**
                     * Gets or sets the offset relative to the end row of the floating object.
                     * @param {number} value The offset relative to the end row of the floating object.
                     * @returns {number | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the offset relative to the end row of the floating object; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * //takes effect when added into the sheet.
                     * customFloatingObject.startRow(2);
                     * customFloatingObject.startColumn(2);
                     * customFloatingObject.startRowOffset(10);
                     * customFloatingObject.startColumnOffset(10);
                     * customFloatingObject.endRow(7);
                     * customFloatingObject.endColumn(5);
                     * customFloatingObject.endRowOffset(10);
                     * customFloatingObject.endColumnOffset(10);
                     */
                    endRowOffset(value?: number): any;
                    /**
                     * Gets or sets whether the position of the floating object is fixed. When fixedPosition is true, dynamicMove and dynamicSize are disabled.
                     * @param {boolean} value The value indicates whether the position of the floating object is fixed.
                     * @returns {boolean | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns whether the position of the floating object is fixed; otherwise, returns the floating object.
                     * @example
                     * //This example sets the position of the object to fixed.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * customFloatingObject.fixedPosition(true);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    fixedPosition(value: boolean): any;
                    /**
                     * Gets the dom host of the custom content.
                     * @returns {Array.<HTMLElement>}
                     */
                    getHost(): HTMLElement[];
                    /**
                     * Gets or sets the height of a floating object.
                     * @param {number} value The height of a floating object.
                     * @returns {number | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the height of a floating object; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1");
                     * customFloatingObject.x(10);
                     * customFloatingObject.y(10);
                     * customFloatingObject.width(60);
                     * customFloatingObject.height(64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    height(value?: number): any;
                    /**
                     * Gets or sets whether this floating object is locked.
                     * @param {boolean} value The value that indicates whether this floating object is locked.
                     * @returns {boolean | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns whether this floating object is locked; otherwise, returns the floating object.
                     * @example
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1");
                     * customFloatingObject.x(10);
                     * customFloatingObject.y(10);
                     * customFloatingObject.width(60);
                     * customFloatingObject.height(64);
                     * customFloatingObject.isLocked(true);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * activeSheet.options.isProtected = true;
                     */
                    isLocked(value?: boolean): any;
                    /**
                     * Gets or sets whether this floating object is selected.
                     * @param {boolean} value The value that indicates whether this floating object is selected.
                     * @returns {boolean | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns whether this floating object is selected; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * customFloatingObject.isSelected(true);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    isSelected(value?: boolean): any;
                    /**
                     * Gets or sets whether this floating object is visible.
                     * @param {boolean} value The value that indicates whether this floating object is visible.
                     * @returns {boolean | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns whether this floating object is visible; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * customFloatingObject.isVisible(true);
                     * customFloatingObject.dynamicSize(true);
                     * customFloatingObject.dynamicMove(true);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    isVisible(value?: boolean): any;
                    /**
                     * Gets the name of the floating object.
                     * @param {string} value The name of the floating object.
                     * @returns {string | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the name of the floating object; otherwise, returns the floating object.
                     * @example
                     * //This example uses the name method.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject();
                     * customFloatingObject.name("f1");
                     * customFloatingObject.x(10);
                     * customFloatingObject.y(10);
                     * customFloatingObject.width(60);
                     * customFloatingObject.height(64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    name(value?: string): any;
                    /**
                     * Refresh the content in floatingObject.The user should override this method to make their content synchronize with the floatingObject.
                     */
                    refreshContent(): void;
                    /**
                     * Gets or sets the starting column index of the floating object position.
                     * @param {number} value The starting column index of the floating object position.
                     * @returns {number | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the starting column index of the floating object position; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * //takes effect when added into the sheet.
                     * customFloatingObject.startRow(2);
                     * customFloatingObject.startColumn(2);
                     * customFloatingObject.startRowOffset(10);
                     * customFloatingObject.startColumnOffset(10);
                     */
                    startColumn(value?: number): any;
                    /**
                     * Gets or sets the offset relative to the start column of the floating object.
                     * @param {number} value The offset relative to the start column of the floating object.
                     * @returns {number | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the offset relative to the start column of the floating object; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * //takes effect when added into the sheet.
                     * customFloatingObject.startRow(2);
                     * customFloatingObject.startColumn(2);
                     * customFloatingObject.startRowOffset(10);
                     * customFloatingObject.startColumnOffset(10);
                     */
                    startColumnOffset(value?: number): any;
                    /**
                     * Gets or sets the starting row index of the floating object position.
                     * @param {number} value The starting row index of the floating object position.
                     * @returns {number | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the starting row index of the floating object position; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * //takes effect when added into the sheet.
                     * customFloatingObject.startRow(2);
                     * customFloatingObject.startColumn(2);
                     * customFloatingObject.startRowOffset(10);
                     * customFloatingObject.startColumnOffset(10);
                     */
                    startRow(value?: number): any;
                    /**
                     * Gets or sets the offset relative to the start row of the floating object.
                     * @param {number} value The offset relative to the start row of the floating object.
                     * @returns {number | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the offset relative to the start row of the floating object; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * //takes effect when added into the sheet.
                     * customFloatingObject.startRow(2);
                     * customFloatingObject.startColumn(2);
                     * customFloatingObject.startRowOffset(10);
                     * customFloatingObject.startColumnOffset(10);
                     */
                    startRowOffset(value?: number): any;
                    /**
                     * Gets or sets the width of a floating object.
                     * @param {number} value The width of a floating object.
                     * @returns {number | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the width of a floating object; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1");
                     * customFloatingObject.x(10);
                     * customFloatingObject.y(10);
                     * customFloatingObject.width(60);
                     * customFloatingObject.height(64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    width(value?: number): any;
                    /**
                     * Gets or sets the horizontal location of the floating object.
                     * @param {number} value The horizontal location of the floating object.
                     * @return {number | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the horizontal location of the floating object; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1");
                     * customFloatingObject.x(10);
                     * customFloatingObject.y(10);
                     * customFloatingObject.width(60);
                     * customFloatingObject.height(64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    x(value?: number): any;
                    /**
                     * Gets or sets the vertical location of the floating object.
                     * @param {number} value The vertical location of the floating object.
                     * @return {number | GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} If no value is set, returns the vertical location of the floating object; otherwise, returns the floating object.
                     * @example
                     * //This example creates a floating object.
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1");
                     * customFloatingObject.x(10);
                     * customFloatingObject.y(10);
                     * customFloatingObject.width(60);
                     * customFloatingObject.height(64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    y(value?: number): any;
                }

                export class FloatingObjectCollection{
                    /**
                     * Represents a floating object manager that managers all floating objects in a sheet.
                     * @class
                     * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The worksheet.
                     * @param {string} typeName The type name.
                     */
                    constructor(sheet?: GCTYPE.Spread.Sheets.Worksheet,  typeName?: string);
                    /**
                     * Adds a floating object to the sheet.
                     * The arguments has 2 modes.
                     * If there is 1 parameter, the parameter is floatingObject which is a GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject type.
                     * If there are 6 parameters, the parameters are name, src, x, y, width, and height.
                     * @param {GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject|string} floatingObjectOrName The floating object that will be added to the sheet, or the name of the picture that will be added to the sheet.
                     * @param {string} src The image source of the picture.
                     * @param {number} x The x location of the picture.
                     * @param {number} y The y location of the picture.
                     * @param {number} width The width of the picture.
                     * @param {number} height The height of the picture.
                     * @return {GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} The floating object that has been added to the sheet.
                     * @example
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 10, 10, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     */
                    add(floatingObjectOrName: GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject | string,  src?: string,  x?: number,  y?: number,  width?: number,  height?: number): GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject;
                    /**
                     * Gets all of the floating objects in the sheet.
                     * @return {Array.<GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject>} The collection of all the floating objects in the sheet.
                     * @example
                     * activeSheet.pictures.add("p1", "pics/download.jpg", 1, 6, 400, 400);
                     * activeSheet.pictures.add("p2", "pics/download.jpg", 500, 150, 200, 300);
                     * var pictures = activeSheet.pictures.all();
                     * for (var i = 0; i &lt; pictures.length; i++) {
                     *     alert("Path of picture " + i + " is:  " + pictures[i].src())
                     * }
                     */
                    all(): GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject[];
                    /**
                     * Removes all floating objects in the sheet.
                     */
                    clear(): void;
                    /**
                     * Gets a floating object from the sheet by the indicate name.
                     * @param {string} name The name of the floating object.
                     * @return {GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject} The floating object in the sheet with the indicate name.
                     * @example
                     * activeSheet.pictures.add("f2","tsoutline.png",100,60,200,100);
                     * //button
                     * $("#button1").click(function () {
                     *  var pic = activeSheet.pictures.get("f2");
                     * });
                     */
                    get(name: string): GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject;
                    /**
                     * Removes a floating object from the sheet by the indicate name.
                     * @param {string} name The name of the floating object.
                     * @example
                     * activeSheet.pictures.add("f2","tsoutline.png",100,60,200,100);
                     * //button
                     * $("#button1").click(function () {
                     *      activeSheet.resumePaint();
                     *      activeSheet.pictures.remove("f2");
                     *      activeSheet.repaint();
                     * });
                     */
                    remove(name: string): void;
                    /**
                     * Gets or sets the z-index of floating object.
                     * @param {string} name The name of the floatingObject.
                     * @param {number} zIndex The z-index of the floating object.
                     * @return {number | *} If the parameter 'zIndex' is null or undefined,it will return the z-index of the floating object with the indicate name.
                     * @example
                     * var customFloatingObject = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f1", 20, 20, 60, 64);
                     * var btn = document.createElement('button');
                     * btn.style.width = "60px";
                     * btn.style.height = "30px";
                     * btn.innerText = "button1";
                     * customFloatingObject.content(btn);
                     * activeSheet.floatingObjects.add(customFloatingObject);
                     * var customFloatingObject1 = new GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject("f2", 5, 5, 30, 64);
                     * var btn1 = document.createElement('button');
                     * btn1.style.width = "60px";
                     * btn1.style.height = "30px";
                     * btn1.innerText = "button2";
                     * customFloatingObject1.content(btn1);
                     * activeSheet.floatingObjects.add(customFloatingObject1);
                     * activeSheet.floatingObjects.zIndex("f2", 897);
                     * activeSheet.floatingObjects.zIndex("f1", 898);
                     */
                    zIndex(name: string,  zIndex?: number): any;
                }

                export class Picture extends FloatingObject{
                    /**
                     * Represents a picture.
                     * @extends GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject
                     * @class
                     * @param {string} name The name of the picture.
                     * @param {string} src The image source of the picture.
                     * @param {number} x The <i>x</i> location of the picture.
                     * @param {number} y The <i>y</i> location of the picture.
                     * @param {number} width The width of the picture.
                     * @param {number} height The height of the picture.
                     */
                    constructor(name: string,  src: string,  x: number,  y: number,  width: number,  height: number);
                    /**
                     * Gets or sets the background color of the picture.
                     * @param {string} value The backcolor of the picture.
                     * @returns {string | GCTYPE.Spread.Sheets.FloatingObjects.Picture} If no value is set, returns the backcolor of the picture; otherwise, returns the picture.
                     * @example
                     * //This example sets the backcolor of the picture.
                     * activeSheet.pictures.add("f2","Event.png",2,2,10,10);
                     * var picture = activeSheet.pictures.get("f2");
                     * picture.pictureStretch(GCTYPE.Spread.Sheets.ImageLayout.stretch);
                     * picture.backColor("Blue");
                     * picture.borderWidth(2);
                     * picture.borderColor("Red");
                     */
                    backColor(value?: string): any;
                    /**
                     * Gets or sets the border color of the picture.
                     * @param {string} value The border color of the picture.
                     * @returns {string | GCTYPE.Spread.Sheets.FloatingObjects.Picture} If no value is set, returns the border color of the picture; otherwise, returns the picture.
                     * @example
                     * //This example sets the border color of the picture.
                     * activeSheet.pictures.add("f2","Event.png",2,2,10,10);
                     * var picture = activeSheet.pictures.get("f2");
                     * picture.pictureStretch(GCTYPE.Spread.Sheets.ImageLayout.stretch);
                     * picture.backColor("Blue");
                     * picture.borderWidth(2);
                     * picture.borderColor("Red");
                     */
                    borderColor(value?: string): any;
                    /**
                     * Gets or sets the border radius of the picture.
                     * @param {number} value The border radius of the picture.
                     * @returns {number | GCTYPE.Spread.Sheets.FloatingObjects.Picture} If no value is set, returns the border radius of the picture; otherwise, returns the picture.
                     * @example
                     * //This example uses the borderRadius method.
                     * activeSheet.pictures.add("f2","Event.png",2,2,10,10);
                     * var picture = activeSheet.pictures.get("f2");
                     * picture.pictureStretch(GCTYPE.Spread.Sheets.ImageLayout.center);
                     * picture.backColor("Blue");
                     * picture.borderWidth(2);
                     * picture.borderColor("Red");
                     * picture.borderStyle("dotted");
                     * picture.borderRadius(5);
                     */
                    borderRadius(value?: number): any;
                    /**
                     * Gets or sets the border style of the picture.
                     * @param {string} value The css border style of the picture, such as dotted, dashed, solid, and so on.
                     * @returns {string | GCTYPE.Spread.Sheets.FloatingObjects.Picture} If no value is set, returns the border style of the picture; otherwise, returns the picture.
                     * @example
                     * //This example uses the borderStyle method.
                     * activeSheet.pictures.add("f2","Event.png",2,2,10,10);
                     * var picture = activeSheet.pictures.get("f2");
                     * picture.pictureStretch(GCTYPE.Spread.Sheets.ImageLayout.center);
                     * picture.backColor("Blue");
                     * picture.borderWidth(2);
                     * picture.borderColor("Red");
                     * picture.borderStyle("dotted");
                     * picture.borderRadius(5);
                     */
                    borderStyle(value?: string): any;
                    /**
                     * Gets or sets the border width of the picture.
                     * @param {number} value The border width of the picture.
                     * @returns {number | GCTYPE.Spread.Sheets.FloatingObjects.Picture} If no value is set, returns the border width of the picture; otherwise, returns the picture.
                     * @example
                     * //This example uses the borderWidth method.
                     * activeSheet.pictures.add("f2","Event.png",2,2,10,10);
                     * var picture = activeSheet.pictures.get("f2");
                     * picture.pictureStretch(GCTYPE.Spread.Sheets.ImageLayout.stretch);
                     * picture.backColor("Blue");
                     * picture.borderWidth(2);
                     * picture.borderColor("Red");
                     */
                    borderWidth(value?: number): any;
                    /**
                     * Gets the original height of the picture.
                     * @returns {number} The original height of the picture.
                     * @example
                     * activeSheet.pictures.add("f2","Event.png",2,2,6,6);
                     * activeSheet.pictures.add("f1","tsoutline.png",3,0,6,6);
                     * var picture = activeSheet.pictures.get("f2");
                     * picture.pictureStretch(GCTYPE.Spread.Sheets.ImageLayout.center);
                     * //button
                     * $("#button1").click(function () {
                     *   alert(picture.getOriginalHeight());
                     * });
                     */
                    getOriginalHeight(): number;
                    /**
                     * Gets the original width of the picture.
                     * @returns {number} The original width of the picture.
                     * @example
                     * activeSheet.pictures.add("f2","Event.png",2,2,6,6);
                     * activeSheet.pictures.add("f1","tsoutline.png",3,0,6,6);
                     * var picture = activeSheet.pictures.get("f2");
                     * picture.pictureStretch(GCTYPE.Spread.Sheets.ImageLayout.center);
                     * //button
                     * $("#button1").click(function () {
                     *      alert(picture.getOriginalWidth());
                     * });
                     */
                    getOriginalWidth(): number;
                    /**
                     * Gets or sets the stretch of the picture.
                     * @param {GCTYPE.Spread.Sheets.ImageLayout} value The stretch of the picture.
                     * @returns {GCTYPE.Spread.Sheets.ImageLayout | GCTYPE.Spread.Sheets.FloatingObjects.Picture} If no value is set, returns the stretch of the picture; otherwise, returns the picture.
                     * @example
                     * //This example uses the pictureStretch method.
                     * activeSheet.pictures.add("f2","Event.png",2,2,10,10);
                     * var picture = activeSheet.pictures.get("f2");
                     * picture.pictureStretch(GCTYPE.Spread.Sheets.ImageLayout.stretch);
                     * picture.backColor("Blue");
                     * picture.borderWidth(2);
                     * picture.borderColor("Red");
                     */
                    pictureStretch(value?: GCTYPE.Spread.Sheets.ImageLayout): any;
                    /**
                     * Gets or sets the src of the picture.
                     * @param {string} value The src of the picture.
                     * @returns {string | GCTYPE.Spread.Sheets.FloatingObjects.Picture} If no value is set, returns the src of the picture; otherwise, returns the picture.
                     */
                    src(value?: string): any;
                }
            }

            module FormulaTextBox{
                /**
                 * Gets the FormulaTextBox instance by the host element.
                 * @param {HTMLElement|string} host The host element or the host element id.
                 * @returns {GCTYPE.Spread.Sheets.FormulaTextBox.FormulaTextBox} The FormulaTextBox instance.
                 * @example
                 * window.onload = function(){
                 *      var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"), { sheetCount: 1 });
                 *      var rangeSelector = new GCTYPE.Spread.Sheets.FormulaTextBox.FormulaTextBox(document.getElementById("ftb"), {rangeSelectMode: true});
                 *      rangeSelector.workbook(spread);
                 *      var rangeSelectorInstance = GCTYPE.Spread.Sheets.FormulaTextBox.findControl("ftb");
                 * }
                 */
                function findControl(host: HTMLElement|string): GCTYPE.Spread.Sheets.FormulaTextBox.FormulaTextBox;

                export interface IFormulaTextBoxOptions{
                    rangeSelectMode: boolean;
                    absoluteReference: boolean;
                    needSheetName?: boolean;
                }


                export class FormulaTextBox{
                    /**
                     * Represents a formula text box.
                     * @class
                     * @param {HTMLElement} host The DOM element. It can be INPUT, TEXTAREA, or editable DIV.
                     * @param {Object} options The options. Default is {rangeSelectMode: false, absoluteReference: false}
                     * @example
                     * window.onload = function(){
                     *      var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"), { sheetCount: 1 });
                     *      rangeSelector = new GCTYPE.Spread.Sheets.FormulaTextBox.FormulaTextBox(document.getElementById("ftb"), {rangeSelectMode: true});
                     *      rangeSelector.workbook(spread);
                     * }
                     * function buttonClick(){
                     *      alert(rangeSelector.text());
                     * }
                     */
                    constructor(host: HTMLElement,  options: GCTYPE.Spread.Sheets.FormulaTextBox.IFormulaTextBoxOptions);
                    /**
                     * Adds a custom function description.
                     * @param {GCTYPE.Spread.CalcEngine.Functions.IFunctionDescription} functionDescription The function description to add. This can be an array. See the Remarks for more information.
                     */
                    add(functionDescription: GCTYPE.Spread.CalcEngine.Functions.IFunctionDescription): void;
                    /**
                     * Gets or sets whether the text box uses automatic complete.
                     * @param {boolean} value Whether to use automatic complete when editing.
                     * @returns {boolean} If no value is set, returns whether the text box uses auto complete; otherwise, there is no return value.
                     */
                    autoComplete(value?: boolean): boolean;
                    /**
                     * Binds an event.
                     * @param {string} type The event type.
                     * @param {Object} data Optional. Specifies additional data to pass along to the function.
                     * @param {Function} fn Specifies the function to run when the event occurs.
                     */
                    bind(type: string,  data: Object,  fn: Function): void;
                    /**
                     * Gets or sets the cursor position.
                     * @param {number} value The cursor position.
                     * @returns {number} If no value is set, returns the cursor position; otherwise, there is no return value.
                     */
                    caret(value?: number): any;
                    /**
                     * Removes host from formula text box and removes all binding events.
                     */
                    destroy(): void;
                    /**
                     * refresh the formula text box with the active cell.
                     * @param {boolean} [ignoreEditing] set to true to avoid the formula text box enter editing mode.
                     */
                    refresh(ignoreEditing?: boolean): void;
                    /**
                     * Removes a custom function description.
                     * @param {string} name The custom function description name.
                     */
                    remove(name: string): void;
                    /**
                     * Gets or sets whether to display the function's help tip.
                     * @param {boolean} value Whether to display the function's help tip when editing.
                     * @returns {boolean} If no value is set, returns whether the text box displays the function's help tip when editing; otherwise, there is no return value.
                     */
                    showHelp(value?: boolean): any;
                    /**
                     * Gets or sets the text.
                     * @param {string} value The text.
                     * @returns {string} If no value is set, returns the text; otherwise, there is no return value.
                     */
                    text(value?: string): string;
                    /**
                     * Removes the binding of an event.
                     * @param {string} type The event type.
                     * @param {Function} fn Specifies the function for which to remove the binding.
                     */
                    unbind(type: string,  fn: Function): void;
                    /**
                     * Removes the binding of all events.
                     */
                    unbindAll(): void;
                    /**
                     * Gets or sets the Workbook component to work with the formula text box.
                     * @param {GCTYPE.Spread.Sheets.Workbook} value The Workbook component.
                     * @returns {GCTYPE.Spread.Sheets.Workbook} If no value is set, returns the workbook component; otherwise, there is no return value.
                     * @example
                     * window.onload = function(){
                     *      var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"),{sheetCount:3});
                     *      var activeSheet = spread.getActiveSheet();
                     *      activeSheet.setArray(0, 0, [1, 2, 3, 4, 5]);
                     *      var fbx = new GCTYPE.Spread.Sheets.FormulaTextBox.FormulaTextBox(document.getElementById("formulaTextBox"));
                     *      fbx.workbook(spread);
                     * };
                     */
                    workbook(value?: GCTYPE.Spread.Sheets.Workbook): GCTYPE.Spread.Sheets.Workbook;
                }
            }

            module Hyperlink{
                /**
                 * Present the way that user open the hyperlinked document. Default is blank.
                 * @enum {number}
                 * @example
                 * //This example uses the HyperlinkTargetType.
                 * sheet.setHyperlink(1, 1, {
                 *    url: 'https://www.grapecity.com/spreadjs',
                 *    tooltip: 'baidu',
                 *    target: GCTYPE.Spread.Sheets.Hyperlink.HyperlinkTargetType.top,
                 * }, GCTYPE.Spread.Sheets.SheetArea.viewport);
                 */
                export enum HyperlinkTargetType{
                    /**
                     * Opens the hyperlinked document in a new window or tab.
                     */
                    blank= 0,
                    /**
                     * Opens the hyperlinked document in the same frame where the user clicked.
                     */
                    self= 1,
                    /**
                     * Opens the hyperlinked document in the parent frame.
                     */
                    parent= 2,
                    /**
                     * Opens the hyperlinked document in the full body of the window.
                     */
                    top= 3
                }

            }

            module OutlineColumn{

                export interface IOutlineColumnOptions{
                    columnIndex?: number; //OutlineColumn index.
                    showImage?: boolean; //Whether to display images.
                    images?: string[]; //The images by level (url or base64Image).
                    showCheckBox?: boolean; //Whether to display the check box.
                    showIndicator?: boolean; //Whether to display the indicator.
                    expandIndicator?: string; //The expand indicator (url or base64Image).
                    collapseIndicator?: string; //The collapse indicator (url or base64Image).
                    maxLevel?: number; //When the current row level is greater than maxLevel, the IncreaseCellIndent action does not take effect.
                }


                export class OutlineColumn{
                    /**
                     * Represents an indented column.
                     * @class
                     * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The outlineColumn's WorkSheet.
                     */
                    constructor(sheet: GCTYPE.Spread.Sheets.Worksheet);
                    /**
                     * Gets the check status of the row or all rows.
                     * @param {number} [row] The index of the row.
                     * @returns {boolean|Array.<boolean>} If row is undefined, returns all row's check status; otherwise, returns the check status of the row.
                     */
                    getCheckStatus(row?: number): any;
                    /**
                     * Gets the collapsed setting of the row or all rows.
                     * @param {number} [row] The index of the collapsed row.
                     * @returns {boolean|Array.<boolean>} If row is undefined, returns all row's collapsed status; otherwise, returns the collapsed setting of the row.
                     */
                    getCollapsed(row?: number): any;
                    /**
                     * Gets or sets the outlineColumn options.
                     * @param {Object} outlineColumnOptions The outlineColumn options.
                     * @param {number} outlineColumnOptions.columnIndex - The index of the indented column.
                     * @param {boolean} [outlineColumnOptions.showImage] - Whether to display images.
                     * @param {Array.<string>} [outlineColumnOptions.images] - The images by level (url or base64Image).
                     * @param {boolean} [outlineColumnOptions.showCheckBox] - Whether to display a check box.
                     * @param {boolean} [outlineColumnOptions.showIndicator] - Whether to display the indicator.
                     * @param {string} [outlineColumnOptions.expandIndicator] - The expand indicator (url or base64Image).
                     * @param {string} [outlineColumnOptions.collapseIndicator] - The collapse indicator (url or base64Image).
                     * @param {number} [outlineColumnOptions.maxLevel] - When the current row level is greater than maxLevel, the IncreaseCellIndent action does not take effect.
                     * @returns {Object | GCTYPE.Spread.Sheets.OutlineColumn.OutlineColumn} outlineColumnOptions|outlineColumn
                     * If no outlineColumnOptions item is set, returns outlineColumnOptions; otherwise, returns the outlineColumn instance.
                     * @example
                     * var rowCount = 38;
                     * var colCount = 10;
                     * activeSheet.setColumnCount(colCount);
                     * activeSheet.setRowCount(rowCount);
                     * activeSheet.setColumnWidth(0, 310);
                     * activeSheet.setColumnWidth(1, 150);
                     * activeSheet.setColumnWidth(2, 150);
                     * activeSheet.frozenColumnCount(1);
                     * activeSheet.setValue(0, 0, "Name", GCTYPE.Spread.Sheets.SheetArea.colHeader);
                     * activeSheet.setValue(0, 1, "Chapter", GCTYPE.Spread.Sheets.SheetArea.colHeader);
                     * activeSheet.setValue(0, 2, "Page", GCTYPE.Spread.Sheets.SheetArea.colHeader);
                     * var commands = [
                     *     {name: 'Preface', chapter: '1', page: 1, indent: 0},
                     *     {name: 'Java SE5 and SE6', chapter: '1.1', page: 2, indent: 1},
                     *     {name: 'Java SE6', chapter: '1.1.1', page: 2, indent: 2},
                     *     {name: 'The 4th edition', chapter: '1.2', page: 2, indent: 1},
                     *     {name: 'Changes', chapter: '1.2.1', page: 3, indent: 2},
                     *     {name: 'Note on the cover design', chapter: '1.3', page: 4, indent: 1},
                     *     {name: 'Acknowledgements', chapter: '1.4', page: 4, indent: 1},
                     *     {name: 'Introduction', chapter: '2', page: 9, indent: 0},
                     *     {name: 'Prerequisites', chapter: '2.1', page: 9, indent: 1},
                     *     {name: 'Learning Java', chapter: '2.2', page: 10, indent: 1},
                     *     {name: 'Goals', chapter: '2.3', page: 10, indent: 1},
                     *     {name: 'Teaching from this book', chapter: '2.4', page: 11, indent: 1},
                     *     {name: 'JDK HTML documentation', chapter: '2.5', page: 11, indent: 1},
                     *     {name: 'Exercises', chapter: '2.6', page: 12, indent: 1},
                     *     {name: 'Foundations for Java', chapter: '2.7', page: 12, indent: 1},
                     *     {name: 'Source code', chapter: '2.8', page: 12, indent: 1},
                     *     {name: 'Coding standards', chapter: '2.8.1', page: 14, indent: 2},
                     *     {name: 'Errors', chapter: '2.9', page: 14, indent: 1},
                     *     {name: 'Introduction to Objects', chapter: '3', page: 15, indent: 0},
                     *     {name: 'The progress of abstraction', chapter: '3.1', page: 15, indent: 1},
                     *     {name: 'An object has an interface', chapter: '3.2', page: 17, indent: 1},
                     *     {name: 'An object provides services', chapter: '3.3', page: 18, indent: 1},
                     *     {name: 'The hidden implementation', chapter: '3.4', page: 19, indent: 1},
                     *     {name: 'Reusing the implementation', chapter: '3.5', page: 20, indent: 1},
                     *     {name: 'Inheritance', chapter: '3.6', page: 21, indent: 1},
                     *     {name: 'Is-a vs. is-like-a relationships', chapter: '3.6.1', page: 24, indent: 2},
                     *     {name: 'Interchangeable objects with polymorphism', chapter: '3.7', page: 25, indent: 1},
                     *     {name: 'The singly rooted hierarchy', chapter: '3.8', page: 28, indent: 1},
                     *     {name: 'Containers', chapter: '3.9', page: 28, indent: 1},
                     *     {name: 'Parameterized types (Generics)', chapter: '3.10', page: 29, indent: 1},
                     *     {name: 'Object creation & lifetime', chapter: '3.11', page: 30, indent: 1},
                     *     {name: 'Exception handling: dealing with errors', chapter: '3.12', page: 31, indent: 1},
                     *     {name: 'Concurrent programming', chapter: '3.13', page: 32, indent: 1},
                     *     {name: 'Java and the Internet', chapter: '3.14', page: 33, indent: 1},
                     *     {name: 'What is the Web?', chapter: '3.14.1', page: 33, indent: 2},
                     *     {name: 'Client-side programming', chapter: '3.14.2', page: 34, indent: 2},
                     *     {name: 'Server-side programming', chapter: '3.14.3', page: 38, indent: 2},
                     *     {name: 'Summary', chapter: '3.15', page: 38, indent: 1},
                     * ];
                     * for (var r = 0; r &lt; commands.length; r++) {
                     *     activeSheet.setValue(r, 0, commands[r]['name']);
                     *     activeSheet.setValue(r, 1, commands[r]['chapter']);
                     *     activeSheet.setValue(r, 2, commands[r]['page']);
                     *     activeSheet.getRange(r, 0, 1, 1).textIndent(commands[r].indent);
                     * }
                     * activeSheet.outlineColumn.options({
                     *      columnIndex: 0,
                     *      showImage: true,
                     *      showCheckBox: true,
                     *      images: ['star2.png', 'box4.png', 'rating4.png'],
                     *      maxLevel: 2
                     * });
                     * activeSheet.showRowOutline(true);
                     * spread.invalidateLayout();
                     * spread.repaint();
                     */
                    options(outlineColumnOptions?: GCTYPE.Spread.Sheets.OutlineColumn.IOutlineColumnOptions): any;
                    /**
                     * Refreshes the indented column.
                     */
                    refresh(): void;
                    /**
                     * Sets the check status of the row.
                     * @param {number} row The index of the row.
                     * @param {boolean} checkStatus The check status of the row.
                     */
                    setCheckStatus(row: number,  checkStatus: boolean): void;
                    /**
                     * Sets whether the row is collapsed.
                     * @param {number} row The index of the row.
                     * @param {boolean} collapsed The collapsed setting for the row.
                     */
                    setCollapsed(row: number,  collapsed: boolean): void;
                }
            }

            module Outlines{
                /**
                 * Specifies the status of an outline (range group) summary row or column position.
                 * @enum {number}
                 * @example
                 * sheet.suspendPaint();
                 * sheet.rowOutlines.group(3,2);
                 * sheet.columnOutlines.group(4,1);
                 * sheet.rowOutlines.direction(GCTYPE.Spread.Sheets.Outlines.OutlineDirection.backward);
                 * sheet.columnOutlines.direction(GCTYPE.Spread.Sheets.Outlines.OutlineDirection.forward);
                 * sheet.resumePaint();
                 */
                export enum OutlineDirection{
                    /** The summary row is above or to the left of the group detail.
                     * @type {number}
                     */
                    backward= 0,
                    /** The summary row is below or to the right of the group detail.
                     * @type {number}
                     */
                    forward= 1
                }

                /**
                 * Specifies the status of an outline (range group).
                 * @enum {number}
                 * @example
                 * //The following example specifies to display a range group as collapsed.
                 * sheet.rowOutlines.group(0,5);
                 * var rgi = sheet.rowOutlines.find(1, 0);
                 * rgi.state(GCTYPE.Spread.Sheets.Outlines.OutlineState.collapsed);
                 * spread.invalidateLayout();
                 * spread.repaint();
                 */
                export enum OutlineState{
                    /** Indicates expanded status with the minus sign.
                     * @type {number}
                     */
                    expanded= 0,
                    /** Indicates collapsed status with the plus sign.
                     * @type {number}
                     */
                    collapsed= 1
                }


                export class Outline{
                    /**
                     * Represents an outline (range group) for the worksheet.
                     * @param {number} count The number of rows or columns.
                     * @class
                     */
                    constructor(count: number);
                    /**
                     * Gets or sets the outline's (range group) direction.
                     * @param {GCTYPE.Spread.Sheets.Outlines.OutlineDirection} [direction] The outline's (range group) direction.
                     * @returns {GCTYPE.Spread.Sheets.Outlines.OutlineDirection | GCTYPE.Spread.Sheets.Outlines.Outline} If no value is set, returns the outline's (range group) direction; otherwise, returns the outline.
                     * @example
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(3,2);
                     * activeSheet.columnOutlines.group(4,1);
                     * activeSheet.rowOutlines.direction(GCTYPE.Spread.Sheets.Outlines.OutlineDirection.forward);
                     * activeSheet.resumePaint();
                     */
                    direction(direction?: GCTYPE.Spread.Sheets.Outlines.OutlineDirection): any;
                    /**
                     * Expands all outlines (range groups), using the specified level.
                     * @param {number} level The level of the outline to expand or collapse.
                     * @param {boolean} expand Whether to expand the groups.
                     * @example
                     * //This example uses the expand method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * activeSheet.rowOutlines.expand(0,false);
                     * activeSheet.resumePaint();
                     */
                    expand(level: number,  expand: boolean): void;
                    /**
                     * Expands or collapses the specified outline (range group) of rows or columns.
                     * @param {GCTYPE.Spread.Sheets.Outlines.OutlineInfo} groupInfo The group information of the range group.
                     * @param {boolean} expand Whether to expand the groups.
                     */
                    expandGroup(groupInfo: GCTYPE.Spread.Sheets.Outlines.OutlineInfo,  expand: boolean): void;
                    /**
                     * Gets the outline (range group) with the specified group level and row or column index.
                     * @param {number} index The index of the row or column.
                     * @param {number} level The level of the outline (range group).
                     * @returns {GCTYPE.Spread.Sheets.Outlines.OutlineInfo} The specified range group.
                     * @example
                     * //This example uses the find method.
                     * activeSheet.rowOutlines.group(0,5);
                     * var rgi = activeSheet.rowOutlines.find(1, 0);
                     * rgi.state(GCTYPE.Spread.Sheets.Outlines.OutlineState.collapsed);
                     * spread.invalidateLayout();
                     * spread.repaint();
                     */
                    find(index: number,  level: number): GCTYPE.Spread.Sheets.Outlines.OutlineInfo;
                    /**
                     * Gets the collapsed internal.
                     * @param {number} index The index.
                     * @returns {boolean} <c>true</c> if collapsed; otherwise, <c>false</c>.
                     * @example
                     * //This example uses the getCollapsed method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * activeSheet.rowOutlines.expand(0,true);
                     * activeSheet.resumePaint();
                     * alert(activeSheet.rowOutlines.isCollapsed(0));
                     */
                    getCollapsed(index: number): boolean;
                    /**
                     * Gets the level of a specified row or column.
                     * The level's index is zero-based.
                     * @param {number} index The index of the row or column.
                     * @returns {number} The level for the row or column.
                     * @example
                     * //This example uses the getLevel method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * activeSheet.rowOutlines.expand(0,true);
                     * activeSheet.resumePaint();
                     * alert(activeSheet.rowOutlines.getLevel(0));
                     */
                    getLevel(index: number): number;
                    /**
                     * Gets the number of the deepest level.
                     * @remarks The level index is zero-based.
                     * @returns {number} The number of the deepest level.
                     * @example
                     * //This example uses the getMaxLevel method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * activeSheet.rowOutlines.group(1,4);
                     * activeSheet.rowOutlines.expand(0,true);
                     * activeSheet.columnOutlines.group(0,1);
                     * activeSheet.resumePaint();
                     * alert(activeSheet.rowOutlines.getMaxLevel());
                     */
                    getMaxLevel(): number;
                    /**
                     * Gets the state for the specified group.
                     * @param {GCTYPE.Spread.Sheets.Outlines.OutlineInfo} groupInfo The group information.
                     * @returns {GCTYPE.Spread.Sheets.Outlines.OutlineState} The group state.
                     * @example
                     * //This example uses the getState method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * var rgi = activeSheet.rowOutlines.find(1, 0);
                     * rgi.state(GCTYPE.Spread.Sheets.Outlines.OutlineInfo.collapsed);
                     * alert(activeSheet.rowOutlines.getState(rgi));
                     * activeSheet.resumePaint();
                     */
                    getState(groupInfo: GCTYPE.Spread.Sheets.Outlines.OutlineInfo): GCTYPE.Spread.Sheets.Outlines.OutlineState;
                    /**
                     * Groups a range of rows or columns into an outline (range group) from a specified start index.
                     * @param {number} index The group starting index.
                     * @param {number} count The number of rows or columns to group.
                     * @example
                     * //This example uses the group method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * activeSheet.rowOutlines.expand(0,false);
                     * activeSheet.resumePaint();
                     */
                    group(index: number,  count: number): void;
                    /**
                     * Determines whether the range group at the specified index is collapsed.
                     * @param {number} index The index of the row or column in the range group.
                     * @returns {boolean} <c>true</c> if the specified row or column is collapsed; otherwise, <c>false</c>.
                     * @example
                     * //This example uses the isCollapsed method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * activeSheet.rowOutlines.expand(0,true);
                     * activeSheet.resumePaint();
                     * alert(activeSheet.rowOutlines.isCollapsed(0));
                     */
                    isCollapsed(index: number): boolean;
                    /**
                     * Determines whether the specified index is the end of the group.
                     * @param {number} index The index.
                     * @param {number} processLevel The process level.
                     * @returns {boolean} <c>true</c> if the specfied index is the end of the group; otherwise, <c>false</c>.
                     */
                    isGroupEnd(index: number,  processLevel: number): boolean;
                    /**
                     * Refreshes this range group.
                     */
                    refresh(): void;
                    /**
                     * Resumes the adding.
                     */
                    resumeAdding(): void;
                    /**
                     * Sets the collapsed level.
                     * @param {number} index The index.
                     * @param {boolean} collapsed Set to <c>true</c> to collapse the level.
                     * @example
                     * //This example uses the setCollapsed method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * activeSheet.rowOutlines.setCollapsed(0,false);
                     * activeSheet.resumePaint();
                     */
                    setCollapsed(index: number,  collapsed: boolean): void;
                    /**
                     * Suspends the adding.
                     */
                    suspendAdding(): void;
                    /**
                     * Removes all outlines (range groups).
                     * @example
                     * //This example uses the ungroup method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * activeSheet.rowOutlines.ungroup();
                     * activeSheet.resumePaint();
                     */
                    ungroup(): void;
                    /**
                     * Removes a range of rows or columns from the outline (range group) at the specified start index.
                     * @param {number} index The group starting index.
                     * @param {number} count The number of rows or columns to remove.
                     * @example
                     * //This example uses the ungroupRange method.
                     * activeSheet.suspendPaint();
                     * activeSheet.rowOutlines.group(0,5);
                     * activeSheet.rowOutlines.ungroupRange(0,1);
                     * activeSheet.resumePaint();
                     */
                    ungroupRange(index: number,  count: number): void;
                }

                export class OutlineInfo{
                    /**
                     * Represents the outline (range group) information.
                     * @param {GCTYPE.Spread.Sheets.Outlines.Outline} model The owner of the outline.
                     * @param {number} start The start index of the outline.
                     * @param {number} end The end index of the outline.
                     * @param {number} level The level of the outline.
                     * @class
                     */
                    constructor(model: GCTYPE.Spread.Sheets.Outlines.Outline,  start: number,  end: number,  level: number);
                    /** The children of the group.
                     * @type {Array}
                     */
                    children: any[];
                    /** The end index of the group.
                     * @type {number}
                     */
                    end: number;
                    /** The level of the group.
                     * @type {number}
                     */
                    level: number;
                    /** The owner of the group.
                     * @type {GCTYPE.Spread.Sheets.Outlines.Outline}
                     */
                    model: GCTYPE.Spread.Sheets.Outlines.Outline;
                    /** The parent of the group.
                     * @type {GCTYPE.Spread.Sheets.Outlines.OutlineInfo}
                     */
                    parent: GCTYPE.Spread.Sheets.Outlines.OutlineInfo;
                    /** The start index of the group.
                     * @type {number}
                     */
                    start: number;
                    /**
                     * Adds the child.
                     * @param {Object} child The child.
                     */
                    addChild(child: Object): void;
                    /**
                     * Compares this instance to a specified OutlineInfo object and returns an indication of their relative values.
                     * @param {number} index The index of the group item.
                     * @returns {boolean} <c>true</c> if the range group contains the specified index; otherwise, <c>false</c>.
                     */
                    contains(index: number): boolean;
                    /**
                     * Gets or sets the state of this outline (range group).
                     * @param {GCTYPE.Spread.Sheets.Outlines.OutlineState} [value] The state of this outline (range group).
                     * @returns {GCTYPE.Spread.Sheets.Outlines.OutlineState} The state of this outline (range group).
                     */
                    state(value?: GCTYPE.Spread.Sheets.Outlines.OutlineState): GCTYPE.Spread.Sheets.Outlines.OutlineState;
                }
            }

            module PDF{
                module PDFFontsManager{
                    /**
                     *Provide a fallback font for the specific font.
                     *@param {string} font the css font string.
                     *@return {string | ArrayBuffer} The font file in base64 string or ArrayBuffer.
                     */
                    function fallbackFont(font: string): any;
                    /**
                     *Register a Font for export PDF.
                     *@param {string} name The font name.
                     *@param {Object} [font] The font object.
                     *@param {string | ArrayBuffer} [font.normal] The normal font file in base64 string or ArrayBuffer.
                     *@param {string | ArrayBuffer} [font.bold] The bold font file in base64 string or ArrayBuffer.
                     *@param {string | ArrayBuffer} [font.italic] The italic font file in base64 string or ArrayBuffer.
                     *@param {string | ArrayBuffer} [font.boldItalic] The boldItalic font file in base64 string or ArrayBuffer.
                     */
                    function registerFont(name: string,  font: Object): void;
                }

            }

            module Print{

                export interface IPageInfo{
                    pages: IPageInfoItem[];
                }


                export interface IPageInfoItem{
                    row: number;
                    column: number;
                    rowCount: number;
                    columnCount: number;
                }


                export interface IWatermarkItem{
                    x: number;
                    y: number;
                    width: number;
                    height: number;
                    imageSrc: string;
                    page: string;
                }


                export interface PrintMargins{
                    top: number;
                    bottom: number;
                    left: number;
                    right: number;
                    header: number;
                    footer: number;
                }


                export interface PrintSize{
                    height: number;
                    width: number;
                }

                /**
                 * Specifies the paper kind for the printed page.
                 * @enum {number}
                 * @example
                 * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                 * printInfo.headerLeft("Header Left");
                 * printInfo.paperSize(new GCTYPE.Spread.Sheets.Print.PaperSize(GCTYPE.Spread.Sheets.Print.PaperKind.a4));
                 * spread.print(0);
                 */
                export enum PaperKind{
                    /**
                     * Specifies the paper size is 420 mm * 594 mm.
                     */
                    a2= 66,
                    /**
                     * Specifies the paper size is 297 mm * 420 mm.
                     */
                    a3= 8,
                    /**
                     * Specifies the paper size is 322 mm * 445 mm.
                     */
                    a3Extra= 63,
                    /**
                     * Specifies the paper size is 322 mm * 445 mm.
                     */
                    a3ExtraTransverse= 68,
                    /**
                     * Specifies the paper size is 420 mm * 297 mm.
                     */
                    a3Rotated= 76,
                    /**
                     * Specifies the paper size is 297 mm * 420 mm.
                     */
                    a3Transverse= 67,
                    /**
                     * Specifies the paper size is 210 mm * 297 mm.
                     */
                    a4= 9,
                    /**
                     * Specifies the paper size is 236 mm * 322 mm.
                     */
                    a4Extra= 53,
                    /**
                     * Specifies the paper size is 210 mm * 330 mm.
                     */
                    a4Plus= 60,
                    /**
                     * Specifies the paper size is 297 mm * 210 mm.
                     */
                    a4Rotated= 77,
                    /**
                     * Specifies the paper size is 210 mm * 297 mm.
                     */
                    a4Small= 10,
                    /**
                     * Specifies the paper size is 210 mm * 297 mm.
                     */
                    a4Transverse= 55,
                    /**
                     * Specifies the paper size is 148 mm * 210 mm.
                     */
                    a5= 11,
                    /**
                     * Specifies the paper size is 174 mm * 235 mm.
                     */
                    a5Extra= 64,
                    /**
                     * Specifies the paper size is 210 mm * 148 mm.
                     */
                    a5Rotated= 78,
                    /**
                     * Specifies the paper size is 148 mm * 210 mm.
                     */
                    a5Transverse= 61,
                    /**
                     * Specifies the paper size is 105 mm * 148 mm.
                     */
                    a6= 70,
                    /**
                     * Specifies the paper size is 148 mm * 105 mm.
                     */
                    a6Rotated= 83,
                    /**
                     * Specifies the paper size is 227 mm * 356 mm.
                     */
                    aPlus= 57,
                    /**
                     * Specifies the paper size is 250 mm * 353 mm.
                     */
                    b4= 12,
                    /**
                     * Specifies the paper size is 250 mm * 353 mm.
                     */
                    b4Envelope= 33,
                    /**
                     * Specifies the paper size is 364 mm * 257 mm.
                     */
                    b4JisRotated= 79,
                    /**
                     * Specifies the paper size is 176 mm * 250 mm.
                     */
                    b5= 13,
                    /**
                     * Specifies the paper size is 176 mm * 250 mm.
                     */
                    b5Envelope= 34,
                    /**
                     * Specifies the paper size is 201 mm * 276 mm.
                     */
                    b5Extra= 65,
                    /**
                     * Specifies the paper size is 257 mm * 182 mm.
                     */
                    b5JisRotated= 80,
                    /**
                     * Specifies the paper size is 182 mm * 257 mm.
                     */
                    b5Transverse= 62,
                    /**
                     * Specifies the paper size is 176 mm * 125 mm.
                     */
                    b6Envelope= 35,
                    /**
                     * Specifies the paper size is 128 mm * 182 mm.
                     */
                    b6Jis= 88,
                    /**
                     * Specifies the paper size is 182 mm * 128 mm.
                     */
                    b6JisRotated= 89,
                    /**
                     * Specifies the paper size is 305 mm * 487 mm.
                     */
                    bPlus= 58,
                    /**
                     * Specifies the paper size is 324 mm * 458 mm.
                     */
                    c3Envelope= 29,
                    /**
                     * Specifies the paper size is 229 mm * 324 mm.
                     */
                    c4Envelope= 30,
                    /**
                     * Specifies the paper size is 162 mm * 229 mm.
                     */
                    c5Envelope= 28,
                    /**
                     * Specifies the paper size is 114 mm * 229 mm.
                     */
                    c65Envelope= 32,
                    /**
                     * Specifies the paper size is 114 mm * 162 mm.
                     */
                    c6Envelope= 31,
                    /**
                     * Specifies the paper size is 17 in. * 22 in.
                     */
                    cSheet= 24,
                    /**
                     * Specifies the paper size is defined by the user.
                     */
                    custom= 0,
                    /**
                     * Specifies the paper size is 110 mm * 220 mm.
                     */
                    dlEnvelope= 27,
                    /**
                     * Specifies the paper size is 22 in. * 34 in.
                     */
                    dSheet= 25,
                    /**
                     * Specifies the paper size is 34 in. * 44 in.
                     */
                    eSheet= 26,
                    /**
                     * Specifies the paper size is 7.25 in. * 10.5 in.
                     */
                    executive= 7,
                    /**
                     * Specifies the paper size is 8.5 in. * 13 in.
                     */
                    folio= 14,
                    /**
                     * Specifies the paper size is 8.5 in. * 13 in.
                     */
                    germanLegalFanfold= 41,
                    /**
                     * Specifies the paper size is 8.5 in. * 12 in.
                     */
                    germanStandardFanfold= 40,
                    /**
                     * Specifies the paper size is 220 mm * 220 mm.
                     */
                    inviteEnvelope= 47,
                    /**
                     * Specifies the paper size is 250 mm * 353 mm.
                     */
                    isoB4= 42,
                    /**
                     * Specifies the paper size is 110 mm * 230 mm.
                     */
                    italyEnvelope= 36,
                    /**
                     * Specifies the paper size is 200 mm * 148 mm.
                     */
                    japaneseDoublePostcard= 69,
                    /**
                     * Specifies the paper size is 148 mm * 200 mm.
                     */
                    japaneseDoublePostcardRotated= 82,
                    /**
                     * Specifies the paper size is Japanese Chou #3 envelope, 120 mm * 235 mm.
                     */
                    japaneseEnvelopeChouNumber3= 73,
                    /**
                     * Specifies the paper size is Japanese rotated Chou #3 envelope, 235 mm * 120 mm.
                     */
                    japaneseEnvelopeChouNumber3Rotated= 86,
                    /**
                     * Specifies the paper size is Japanese Chou #4 envelope, 90 mm * 205 mm.
                     */
                    japaneseEnvelopeChouNumber4= 74,
                    /**
                     * Specifies the paper size is Japanese rotated Chou #4 envelope, 205 mm * 90 mm.
                     */
                    japaneseEnvelopeChouNumber4Rotated= 87,
                    /**
                     * Specifies the paper size is Japanese Kaku #2 envelope, 240 mm * 332 mm.
                     */
                    japaneseEnvelopeKakuNumber2= 71,
                    /**
                     * Specifies the paper size is Japanese rotated Kaku #2 envelope, 332 mm * 240 mm.
                     */
                    japaneseEnvelopeKakuNumber2Rotated= 84,
                    /**
                     * Specifies the paper size is Japanese Kaku #3 envelope, 216 mm * 277 mm.
                     */
                    japaneseEnvelopeKakuNumber3= 72,
                    /**
                     * Specifies the paper size is Japanese rotated Kaku #3 envelope, 277 mm * 216 mm.
                     */
                    japaneseEnvelopeKakuNumber3Rotated= 85,
                    /**
                     * Specifies the paper size is Japanese You #4 envelope, 235 mm * 105 mm.
                     */
                    japaneseEnvelopeYouNumber4= 91,
                    /**
                     * Specifies the paper size is Japanese You #4 rotated envelope, 105 mm * 235 mm.
                     */
                    japaneseEnvelopeYouNumber4Rotated= 92,
                    /**
                     * Specifies the paper size is 100 mm * 148 mm.
                     */
                    japanesePostcard= 43,
                    /**
                     * Specifies the paper size is 148 mm * 100 mm.
                     */
                    japanesePostcardRotated= 81,
                    /**
                     * Specifies the paper size is 17 in. * 11 in.
                     */
                    ledger= 4,
                    /**
                     * Specifies the paper size is 8.5 in. * 14 in.
                     */
                    legal= 5,
                    /**
                     * Specifies the paper size is legal extra paper (9.275 in. * 15 in.).
                     * This value is specific to the PostScript driver and is used only by Linotronic printers in order to conserve paper.
                     */
                    legalExtra= 51,
                    /**
                     * Specifies the paper size is 8.5 in. * 11 in.
                     */
                    letter= 1,
                    /**
                     * Specifies the paper size is letter extra paper (9.275 in. * 12 in.).
                     * This value is specific to the PostScript driver and is used only by Linotronic printers in order to conserve paper.
                     */
                    letterExtra= 50,
                    /**
                     * Specifies the paper size 9.275 in. * 12 in.
                     */
                    letterExtraTransverse= 56,
                    /**
                     * Specifies the paper size is 8.5 in. * 12.69 in.
                     */
                    letterPlus= 59,
                    /**
                     * Specifies the paper size is 11 in. * 8.5 in.
                     */
                    letterRotated= 75,
                    /**
                     * Specifies the paper size is 8.5 in. * 11 in.
                     */
                    letterSmall= 2,
                    /**
                     * Specifies the paper size is 8.275 in. * 11 in.
                     */
                    letterTransverse= 54,
                    /**
                     * Specifies the paper size is 3.875 in. * 7.5 in.
                     */
                    monarchEnvelope= 37,
                    /**
                     * Specifies the paper size is 8.5 in. * 11 in.
                     */
                    note= 18,
                    /**
                     * Specifies the paper size is 4.125 in. * 9.5 in.
                     */
                    number10Envelope= 20,
                    /**
                     * Specifies the paper size is 4.5 in. * 10.375 in.
                     */
                    number11Envelope= 21,
                    /**
                     * Specifies the paper size is 4.75 in. * 11 in.
                     */
                    number12Envelope= 22,
                    /**
                     * Specifies the paper size is 5 in. * 11.5 in.
                     */
                    number14Envelope= 23,
                    /**
                     * Specifies the paper size is 3.875 in. * 8.875 in.
                     */
                    number9Envelope= 19,
                    /**
                     * Specifies the paper size is 3.625 in. * 6.5 in.
                     */
                    personalEnvelope= 38,
                    /**
                     * Specifies the paper size is 146 mm * 215 mm.
                     */
                    prc16K= 93,
                    /**
                     * Specifies the paper size is 146 mm * 215 mm.
                     */
                    prc16KRotated= 106,
                    /**
                     * Specifies the paper size is 97 mm * 151 mm.
                     */
                    prc32K= 94,
                    /**
                     * Specifies the paper size is 97 mm * 151 mm.
                     */
                    prc32KBig= 95,
                    /**
                     * Specifies the paper size is 97 mm * 151 mm.
                     */
                    prc32KBigRotated= 108,
                    /**
                     * Specifies the paper size is 97 mm * 151 mm.
                     */
                    prc32KRotated= 107,
                    /**
                     * Specifies the paper size is 102 mm * 165 mm.
                     */
                    prcEnvelopeNumber1= 96,
                    /**
                     * Specifies the paper size is 324 mm * 458 mm.
                     */
                    prcEnvelopeNumber10= 105,
                    /**
                     * Specifies the paper size is 458 mm * 324 mm.
                     */
                    prcEnvelopeNumber10Rotated= 118,
                    /**
                     * Specifies the paper size is 165 mm * 102 mm.
                     */
                    prcEnvelopeNumber1Rotated= 109,
                    /**
                     * Specifies the paper size is 102 mm * 176 mm.
                     */
                    prcEnvelopeNumber2= 97,
                    /**
                     * Specifies the paper size is 176 mm * 102 mm.
                     */
                    prcEnvelopeNumber2Rotated= 110,
                    /**
                     * Specifies the paper size is 125 mm * 176 mm.
                     */
                    prcEnvelopeNumber3= 98,
                    /**
                     * Specifies the paper size is 176 mm * 125 mm.
                     */
                    prcEnvelopeNumber3Rotated= 111,
                    /**
                     * Specifies the paper size is 110 mm * 208 mm.
                     */
                    prcEnvelopeNumber4= 99,
                    /**
                     * Specifies the paper size is 208 mm * 110 mm.
                     */
                    prcEnvelopeNumber4Rotated= 112,
                    /**
                     * Specifies the paper size is 110 mm * 220 mm.
                     */
                    prcEnvelopeNumber5= 100,
                    /**
                     * Specifies the paper size is 220 mm * 110 mm.
                     */
                    prcEnvelopeNumber5Rotated= 113,
                    /**
                     * Specifies the paper size is 120 mm * 230 mm.
                     */
                    prcEnvelopeNumber6= 101,
                    /**
                     * Specifies the paper size is 230 mm * 120 mm.
                     */
                    prcEnvelopeNumber6Rotated= 114,
                    /**
                     * Specifies the paper size is 160 mm * 230 mm.
                     */
                    prcEnvelopeNumber7= 102,
                    /**
                     * Specifies the paper size is 230 mm * 160 mm.
                     */
                    prcEnvelopeNumber7Rotated= 115,
                    /**
                     * Specifies the paper size is 120 mm * 309 mm.
                     */
                    prcEnvelopeNumber8= 103,
                    /**
                     * Specifies the paper size is 309 mm * 120 mm.
                     */
                    prcEnvelopeNumber8Rotated= 116,
                    /**
                     * Specifies the paper size is 229 mm * 324 mm.
                     */
                    prcEnvelopeNumber9= 104,
                    /**
                     * Specifies the paper size is 324 mm * 229 mm.
                     */
                    prcEnvelopeNumber9Rotated= 117,
                    /**
                     * Specifies the paper size is 215 mm * 275 mm.
                     */
                    quarto= 15,
                    /**
                     * Specifies the paper size is 10 in. * 11 in.
                     */
                    standard10x11= 45,
                    /**
                     * Specifies the paper size is 10 in. * 14 in.
                     */
                    standard10x14= 16,
                    /**
                     * Specifies the paper size is 11 in. * 17 in.
                     */
                    standard11x17= 17,
                    /**
                     * Specifies the paper size is 12 in. * 11 in.
                     */
                    standard12x11= 90,
                    /**
                     * Specifies the paper size is 15 in. * 11 in.
                     */
                    standard15x11= 46,
                    /**
                     * Specifies the paper size is 9 in. * 11 in.
                     */
                    standard9x11= 44,
                    /**
                     * Specifies the paper size is 5.5 in. * 8.5 in.
                     */
                    statement= 6,
                    /**
                     * Specifies the paper size is 11 in. * 17 in.
                     */
                    tabloid= 3,
                    /**
                     * Specifies the paper size is 11.69 in. * 18 in.
                     */
                    tabloidExtra= 52,
                    /**
                     * Specifies the paper size is 14.875 in. * 11 in.
                     */
                    usStandardFanfold= 39
                }

                /**
                 * Specifics the type of centering for the printed page.
                 * @enum {number}
                 * @example
                 * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                 * printInfo.columnStart(0);
                 * printInfo.columnEnd(2);
                 * printInfo.centering(GCTYPE.Spread.Sheets.Print.PrintCentering.horizontal);
                 * activeSheet.printInfo(printInfo);
                 * spread.print(0);
                 */
                export enum PrintCentering{
                    /**
                     * Does not center the printed page at all.
                     */
                    none= 0,
                    /**
                     * Centers the printed layout horizontally on the page.
                     */
                    horizontal= 1,
                    /**
                     * Centers the printed layout vertically on the page.
                     */
                    vertical= 2,
                    /**
                     * Centers the printed layout both horizontally and vertically on the page.
                     */
                    both= 3
                }

                /**
                 * Specifies the order in which pages are printed.
                 * @enum {number}
                 * @example
                 * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                 * printInfo.pageOrder(GCTYPE.Spread.Sheets.Print.PrintPageOrder.auto);
                 * activeSheet.printInfo(printInfo);
                 * spread.print(0);
                 */
                export enum PrintPageOrder{
                    /**
                     * Automatically determines the best order for printing pages.
                     */
                    auto= 0,
                    /**
                     * Prints pages down then across.
                     */
                    downThenOver= 1,
                    /**
                     * Prints pages across then down.
                     */
                    overThenDown= 2
                }

                /**
                 * Specifies the page orientation used for printing.
                 * @enum {number}
                 * @example
                 * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                 * printInfo.bestFitColumns(true);
                 * printInfo.orientation(GCTYPE.Spread.Sheets.Print.PrintPageOrientation.landscape);
                 * printInfo.footerCenter("GrapeCity");
                 * activeSheet.printInfo(printInfo);
                 * spread.print(0);
                 */
                export enum PrintPageOrientation{
                    /**
                     * Prints portrait orientation.
                     */
                    portrait= 1,
                    /**
                     * Prints landscape orientation.
                     */
                    landscape= 2
                }

                /**
                 * Specifies whether the area is visible.
                 * @enum {number}
                 * @example
                 * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                 * printInfo.showColumnHeader(GCTYPE.Spread.Sheets.Print.PrintVisibilityType.hide);
                 * spread.print(0);
                 */
                export enum PrintVisibilityType{
                    /**
                     * Inherits the setting from the Worksheet class.
                     */
                    inherit= 0,
                    /**
                     * Hides the area.
                     */
                    hide= 1,
                    /**
                     * Shows in each page.
                     */
                    show= 2,
                    /**
                     * Shows once.
                     */
                    showOnce= 3
                }


                export class PaperSize{
                    /**
                     * Specifies the paper size.
                     * The constructor has 3 modes.
                     * If there are 2 parameters, the parameters are width and height with a type of number;
                     * If there is 1 parameter, the parameter is kind which is a GCTYPE.Spread.Sheets.Print.PaperKind type;
                     * If there is no parameter, the result is the same as the second mode and the kind option is GCTYPE.Spread.Sheets.Print.PaperKind.letter.
                     * @class
                     * @param {number|GCTYPE.Spread.Sheets.Print.PaperKind} [widthOrKind] The width of the paper, in hundredths of an inch; or the kind of the paper and the type is GCTYPE.Spread.Sheets.Print.PaperKind.
                     * @param {number} [height] The height of the paper, in hundredths of an inch.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.paperSize(new GCTYPE.Spread.Sheets.Print.PaperSize(GCTYPE.Spread.Sheets.Print.PaperKind.a4));
                     * spread.print(0);
                     */
                    constructor(widthOrKind?: number|GCTYPE.Spread.Sheets.Print.PaperKind,  height?: number);
                    /**
                     * Gets the paper size, in hundredths of an inch.
                     * @param {GCTYPE.Spread.Sheets.Print.PaperKind} kind The kind of the paper.
                     * @returns {Object} The size which contains width and height of the paper.<br/>
                     * size.width {number} The width of the size, in hundredths of an inch.<br/>
                     * size.height {number} The height of the size, in hundredths of an inch.
                     */
                    getPageSize(kind: GCTYPE.Spread.Sheets.Print.PaperKind): GCTYPE.Spread.Sheets.Print.PrintSize;
                    /**
                     * Gets or sets the height of the paper, in hundredths of an inch.
                     * @param {number} [value] The height of the paper.
                     * @returns {number | GCTYPE.Spread.Sheets.Print.PaperSize} If no value is set, returns the height of the paper; otherwise, returns the paper size.
                     */
                    height(value?: number): any;
                    /**
                     * Gets or sets the kind of the paper.
                     * @param {GCTYPE.Spread.Sheets.Print.PaperKind} [value] The kind of the paper.
                     * @returns {GCTYPE.Spread.Sheets.Print.PaperKind | GCTYPE.Spread.Sheets.Print.PaperSize} If no value is set, returns the kind of the paper; otherwise, returns the paper size.
                     */
                    kind(value?: GCTYPE.Spread.Sheets.Print.PaperKind): any;
                    /**
                     * Gets or sets the width of the paper, in hundredths of an inch.
                     * @param {number} value The width of the paper.
                     * @returns {number | GCTYPE.Spread.Sheets.Print.PaperSize} If no value is set, returns the width of the paper; otherwise, returns the paper size.
                     */
                    width(value?: number): any;
                }

                export class PrintInfo{
                    /**
                     * Represents the information to use when printing a Worksheet.
                     * @class
                     */
                    constructor();
                    /**
                     * Gets or sets whether column widths are adjusted to fit the longest text width for printing.
                     * @param {boolean} [value] Whether column widths are adjusted to fit the longest text width for printing.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns whether column widths are adjusted to fit the longest text width for printing; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.bestFitColumns(true);
                     * printInfo.orientation(GCTYPE.Spread.Sheets.Print.PrintPageOrientation.landscape);
                     * printInfo.footerCenter("GrapeCity");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    bestFitColumns(value?: boolean): any;
                    /**
                     * Gets or sets whether row heights are adjusted to fit the tallest text height for printing.
                     * @param {boolean} [value] Whether row heights are adjusted to fit the tallest text height for printing.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns whether row heights are adjusted to fit the tallest text height for printing; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.bestFitRows(true);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    bestFitRows(value?: boolean): any;
                    /**
                     * Gets or sets whether to print in black and white.
                     * @param {boolean} [value] Whether to print in black and white.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns whether to print in black and white; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.blackAndWhite(true);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    blackAndWhite(value?: boolean): any;
                    /**
                     * Gets or sets how the printed page is centered.
                     * @param {GCTYPE.Spread.Sheets.Print.PrintCentering} [value] How the printed page is centered.
                     * @returns {GCTYPE.Spread.Sheets.Print.PrintCentering | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns how the printed page is centered; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.columnStart(0);
                     * printInfo.columnEnd(2);
                     * printInfo.centering(GCTYPE.Spread.Sheets.Print.PrintCentering.horizontal);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    centering(value?: GCTYPE.Spread.Sheets.Print.PrintCentering): any;
                    /**
                     * Gets or sets the last column to print when printing a cell range.
                     * @param {number} [value] The last column to print when printing a cell range.
                     * @returns {number | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the last column to print when printing a cell range; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.columnStart(0);
                     * printInfo.columnEnd(2);
                     * printInfo.centering(GCTYPE.Spread.Sheets.Print.PrintCentering.horizontal);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    columnEnd(value?: number): any;
                    /**
                     * Gets or sets the first column to print when printing a cell range.
                     * @param {number} [value] The first column to print when printing a cell range.
                     * @returns {number | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the first column to print when printing a cell range; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.columnStart(0);
                     * printInfo.columnEnd(2);
                     * printInfo.centering(GCTYPE.Spread.Sheets.Print.PrintCentering.horizontal);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    columnStart(value?: number): any;
                    /**
                     * Gets or sets the page number to print on the first page.
                     * @param {number} [value] The page number to print on the first page.
                     * @returns {number | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the page number to print on the first page; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.firstPageNumber(1);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    firstPageNumber(value?: number): any;
                    /**
                     * Gets or sets the number of vertical pages to check when optimizing printing.
                     * @param {number} [value] The number of vertical pages to check when optimizing printing.
                     * @returns {number | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the number of vertical pages to check; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.fitPagesTall(1);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    fitPagesTall(value?: number): any;
                    /**
                     * Gets or sets the number of horizontal pages to check when optimizing the printing.
                     * @param {number} [value] The number of horizontal pages to check when optimizing the printing.
                     * @returns {number | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the number of horizontal pages to check; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.fitPagesWide(1);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    fitPagesWide(value?: number): any;
                    /**
                     * Gets or sets the text and format of the center footer on printed pages.
                     * @param {string} [value] The text and format of the center footer on printed pages.
                     * @returns {string | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the text and format of the center footer on printed pages; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.bestFitColumns(true);
                     * printInfo.orientation(GCTYPE.Spread.Sheets.Print.PrintPageOrientation.landscape);
                     * printInfo.footerCenter("GrapeCity");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    footerCenter(value?: string): any;
                    /**
                     * Gets or sets the image for the center section of the footer.
                     * @param {string} [value] The image for the center section of the footer.
                     * @returns {string | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the image for the center section of the footer; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.footerCenter("&amp;G");
                     * printInfo.footerCenterImage("tsoutline.png");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    footerCenterImage(value?: string): any;
                    /**
                     * Gets or sets the text and format of the left footer on printed pages.
                     * @param {string} [value] The text and format of the left footer on printed pages.
                     * @returns {string | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the text and format of the left footer on printed pages; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.footerLeft("&amp;BFooter");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    footerLeft(value?: string): any;
                    /**
                     * Gets or sets the image for the left section of the footer.
                     * @param {string} [value] The image for the left section of the footer.
                     * @returns {string | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the image for the left section of the footer; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.footerLeft("&amp;G");
                     * printInfo.footerLeftImage("logo.jpg");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    footerLeftImage(value?: string): any;
                    /**
                     * Gets or sets the text and format of the right footer on printed pages.
                     * @param {string} [value] The text and format of the right footer on printed pages.
                     * @returns {string | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the text and format of the right footer on printed pages; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.footerRight("&amp;G");
                     * printInfo.footerRightImage("logo.jpg");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    footerRight(value?: string): any;
                    /**
                     * Gets or sets the image for the right section of the footer.
                     * @param {string} [value] The image for the right section of the footer.
                     * @returns {string | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the image for the right section of the footer; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.footerRight("&amp;G");
                     * printInfo.footerRightImage("logo.jpg");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    footerRightImage(value?: string): any;
                    /**
                     * Gets or sets the text and format of the center header on printed pages.
                     * @param {string} [value] The text and format of the center header on printed pages.
                     * @returns {string | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the text and format of the center header on printed pages; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerCenter("&amp;SThis is text.");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    headerCenter(value?: string): any;
                    /**
                     * Gets or sets the image for the center section of the header.
                     * @param {string} [value] The image for the center section of the header.
                     * @returns {string | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the image for the center section of the header; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerCenter("&amp;G");
                     * printInfo.headerCenterImage("logo.jpg");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    headerCenterImage(value?: string): any;
                    /**
                     * Gets or sets the text and format of the left header on printed pages.
                     * @param {string} [value] The text and format of the left header on printed pages.
                     * @returns {string | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the text and format of the left header on printed pages; otherwise, returns the print setting information.
                     * @example
                     * activeSheet.printInfo().headerLeft("It is &amp;T.");
                     * spread.print(0);
                     */
                    headerLeft(value?: string): any;
                    /**
                     * Gets or sets the image for the left section of the header.
                     * @param {string} [value] The image for the left section of the header.
                     * @returns {string | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the image for the left section of the header; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeftImage("logo.jpg");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    headerLeftImage(value?: string): any;
                    /**
                     * Gets or sets the text and format of the right header on printed pages.
                     * @param {string} [value] The text and format of the right header on printed pages.
                     * @returns {string | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the text and format of the right header on printed pages; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerRight("&amp;BHeader");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    headerRight(value?: string): any;
                    /**
                     * Gets or sets the image for the right section of the header.
                     * @param {string} [value] The image for the right section of the header.
                     * @returns {string | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the image for the right section of the header; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerRight("&amp;G");
                     * printInfo.headerRightImage("logo.jpg");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    headerRightImage(value?: string): any;
                    /**
                     * Gets or sets the margins for printing, in hundredths of an inch.
                     * @param {Object} [value] The margins for printing.
                     * @param {number} [value.top] - The top margin, in hundredths of an inch.
                     * @param {number} [value.bottom] -  bottom The bottom margin, in hundredths of an inch.
                     * @param {number} [value.left] - left The left margin, in hundredths of an inch.
                     * @param {number} [value.right] - right The right margin, in hundredths of an inch.
                     * @param {number} [value.header] - header The header offset, in hundredths of an inch.
                     * @param {number} [value.footer] - footer The footer offset, in hundredths of an inch.
                     * @returns {GCTYPE.Spread.Sheets.Print.PrintMargins | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the margins for printing; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.headerCenter("Header Center");
                     * printInfo.headerRight("Header Right");
                     * printInfo.footerLeft("Footer Left");
                     * printInfo.footerCenter("Footer Center");
                     * printInfo.footerRight("Footer Right");
                     * printInfo.margin({top:75, bottom:75, left:20, right:20, header:10, footer:20});
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    margin(value?: GCTYPE.Spread.Sheets.Print.PrintMargins): any;
                    /**
                     * Gets or sets the page orientation used for printing.
                     * @param {GCTYPE.Spread.Sheets.Print.PrintPageOrientation} [value] The page orientation used for printing.
                     * @returns {GCTYPE.Spread.Sheets.Print.PrintPageOrientation | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the page orientation used for printing; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.bestFitColumns(true);
                     * printInfo.orientation(GCTYPE.Spread.Sheets.Print.PrintPageOrientation.landscape);
                     * printInfo.footerCenter("GrapeCity");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    orientation(value?: GCTYPE.Spread.Sheets.Print.PrintPageOrientation): any;
                    /**
                     * Gets or sets the order in which pages print.
                     * @param {GCTYPE.Spread.Sheets.Print.PrintPageOrder} [value] The order in which pages print.
                     * @returns {GCTYPE.Spread.Sheets.Print.PrintPageOrder | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns a value that specifies the order in which pages print; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.pageOrder(GCTYPE.Spread.Sheets.Print.PrintPageOrder.auto);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    pageOrder(value?: GCTYPE.Spread.Sheets.Print.PrintPageOrder): any;
                    /**
                     * Gets or sets the page range for printing.
                     * @param {string} [value] The page numbers or page ranges separated by commas counting from the beginning of the document. For example, type "1,3,5-12".
                     * @returns {string | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns a string that provides page numbers or page ranges; otherwise, returns the print setting information.}
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.pageRange("1-3");
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    pageRange(value?: string): any;
                    /**
                     * Gets or sets the paper size for printing.
                     * @param {GCTYPE.Spread.Sheets.Print.PaperSize} [value] The paper size for printing.
                     * @param {number} [value.width] - The width, in hundredths of an inch.
                     * @param {number} [value.height] - The height, in hundredths of an inch.
                     * @param @returns {GCTYPE.Spread.Sheets.Print.PaperSize | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the paper size for printing; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.paperSize(new GCTYPE.Spread.Sheets.Print.PaperSize(300, 300));
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    paperSize(value?: GCTYPE.Spread.Sheets.Print.PaperSize): any;
                    /**
                     * Gets or sets the quality factor for printing.
                     * @param {number} [value] The quality factor for printing is a positive integer between 1 and 8. The greater the quality factor, the better the printing quality. When the quality factor is bigger, the printing efficiency is affected.
                     * @returns {number | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the quality factor for printing; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.qualityFactor(6);
                     * activeSheet.printInfo(printInfo);
                     * spread.print();
                     */
                    qualityFactor(value?: number): any;
                    /**
                     * Gets or sets the last column of a range of columns to print on the left of each page.
                     * @param {number} [value] The last column of a range of columns to print on the left of each page.
                     * @returns {number | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the last column of a range of columns to print on the left of each page; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.repeatColumnStart(0);
                     * printInfo.repeatColumnEnd(2);
                     * printInfo.repeatRowStart(0);
                     * printInfo.repeatRowEnd(2);
                     * activeSheet.printInfo(printInfo);
                     * spread.print();
                     */
                    repeatColumnEnd(value?: number): any;
                    /**
                     * Gets or sets the first column of a range of columns to print on the left of each page.
                     * @param {number} [value] The first column of a range of columns to print on the left of each page.
                     * @returns {number | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the first column of a range of columns to print on the left of each page; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.repeatColumnStart(0);
                     * printInfo.repeatColumnEnd(2);
                     * printInfo.repeatRowStart(0);
                     * printInfo.repeatRowEnd(2);
                     * activeSheet.printInfo(printInfo);
                     * spread.print();
                     */
                    repeatColumnStart(value?: number): any;
                    /**
                     * Gets or sets the last row of a range of rows to print at the top of each page.
                     * @param {number} [value] The last row of a range of rows to print at the top of each page.
                     * @returns {number | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the last row of a range of rows to print at the top of each page; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.repeatColumnStart(0);
                     * printInfo.repeatColumnEnd(2);
                     * printInfo.repeatRowStart(0);
                     * printInfo.repeatRowEnd(2);
                     * activeSheet.printInfo(printInfo);
                     * spread.print();
                     */
                    repeatRowEnd(value?: number): any;
                    /**
                     * Gets or sets the first row of a range of rows to print at the top of each page.
                     * @param {number} [value] The first row of a range of rows to print at the top of each page.
                     * @returns {number | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the first row of a range of rows to print at the top of each page; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.repeatColumnStart(0);
                     * printInfo.repeatColumnEnd(2);
                     * printInfo.repeatRowStart(0);
                     * printInfo.repeatRowEnd(2);
                     * activeSheet.printInfo(printInfo);
                     * spread.print();
                     */
                    repeatRowStart(value?: number): any;
                    /**
                     * Gets or sets the last row to print when printing a cell range.
                     * @param {number} [value] The last row to print when printing a cell range.
                     * @returns {number | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the last row to print when printing a cell range; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.rowStart(0);
                     * printInfo.rowEnd(2);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    rowEnd(value?: number): any;
                    /**
                     * Gets or sets the first row to print when printing a cell range.
                     * @param {number} [value] The first row to print when printing a cell range.
                     * @returns {number | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns the first row to print when printing a cell range; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.headerLeft("Header Left");
                     * printInfo.rowStart(0);
                     * printInfo.rowEnd(2);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    rowStart(value?: number): any;
                    /**
                     * Gets or sets whether to print an outline border around the entire control.
                     * @param {boolean} [value] Whether to print an outline border around the entire control.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns whether to print an outline border around the entire control; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.showBorder(false);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    showBorder(value?: boolean): any;
                    /**
                     * Gets or sets whether to print the column header.
                     * @param {GCTYPE.Spread.Sheets.Print.PrintVisibilityType} [value] Whether to print the column header.
                     * @returns {GCTYPE.Spread.Sheets.Print.PrintVisibilityType | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns whether to print the column header; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.showColumnHeader(GCTYPE.Spread.Sheets.Print.PrintVisibilityType.hide);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    showColumnHeader(value?: GCTYPE.Spread.Sheets.Print.PrintVisibilityType): any;
                    /**
                     * Gets or sets whether to print the grid lines.
                     * @param {boolean} [value] Whether to print the grid lines.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns whether to print the grid lines; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.showGridLine(false);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    showGridLine(value?: boolean): any;
                    /**
                     * Gets or sets whether to print the row header.
                     * @param {GCTYPE.Spread.Sheets.Print.PrintVisibilityType} [value] Whether to print the row header.
                     * @returns {GCTYPE.Spread.Sheets.Print.PrintVisibilityType | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns whether to print the row header; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.showRowHeader(GCTYPE.Spread.Sheets.Print.PrintVisibilityType.hide);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    showRowHeader(value?: GCTYPE.Spread.Sheets.Print.PrintVisibilityType): any;
                    /**
                     * Gets or sets whether to print only rows and columns that contain data.
                     * @param {boolean} [value] Whether to print only rows and columns that contain data.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns whether to print only rows and columns that contain data; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.useMax(true);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    useMax(value?: boolean): any;
                    /**
                     * Gets or set all watermark.
                     * @param {Array.<Object>} [value] The watermark item.
                     * @param {number} [value.x] The watermark begin x position.
                     * @param {number} [value.y] The watermark begin y position.
                     * @param {number} [value.width] The watermark width.
                     * @param {number} [value.height] The watermark height.
                     * @param {string} [value.imageSrc] The watermark image src.
                     * @param {string} [value.page] The watermark page, support "all", "odd", \u201ceven\u201d, "1,3,4,7,8,9,".
                     * @return {Array.<Object>} The watermark item.
                     * @example
                     * // This example shows how to set watermark.
                     * var printInfo = activeSheet.printInfo();
                     * printInfo.watermark([{x:0, y:0, width:100, height:100, imageSrc:".image/watermark.jpg", page:"all"}]);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    watermark(value?: GCTYPE.Spread.Sheets.Print.IWatermarkItem[]): GCTYPE.Spread.Sheets.Print.IWatermarkItem;
                    /**
                     * Gets or sets the zoom factor used for printing.
                     * @param {number} [value] The zoom factor used for printing.
                     * @returns {number | GCTYPE.Spread.Sheets.Print.PrintInfo} If no value is set, returns a value that specifies the amount to enlarge or reduce the printed worksheet; otherwise, returns the print setting information.
                     * @example
                     * var printInfo = new GCTYPE.Spread.Sheets.Print.PrintInfo();
                     * printInfo.zoomFactor(2);
                     * activeSheet.printInfo(printInfo);
                     * spread.print(0);
                     */
                    zoomFactor(value?: number): any;
                }
            }

            module Search{
                /**
                 * Specifies the type of search flags.
                 * @enum {number}
                 * @example
                 * //This example uses the SearchFlags enumeration.
                 * activeSheet.getCell(2,3).value("testSearch");
                 * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                 * searchCondition.searchString = "testSearch";
                 * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                 * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                 * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.ignoreCase| GCTYPE.Spread.Sheets.Search.SearchFlags.useWildCards;
                 * var searchresult= activeSheet.search(searchCondition);
                 * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" +
                 * searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundSheetIndex+"]";
                 * alert(str);
                 */
                export enum SearchFlags{
                    /** Specifies no search flags.
                     * @type {number}
                     */
                    none= 0,
                    /** Determines whether the search considers the case of the letters in the search string.
                     * @type {number}
                     */
                    ignoreCase= 1,
                    /** Determines whether the search considers only an exact match.
                     * @type {number}
                     */
                    exactMatch= 2,
                    /** Determines whether the search considers wildcard characters (*, ?) in the search string.
                     * @type {number}
                     */
                    useWildCards= 4,
                    /** Determines whether to search within a cell range.
                     * @type {number}
                     */
                    blockRange= 8
                }

                /**
                 * Specifies where the search string is found.
                 * @enum {number}
                 * @example
                 * //This example uses the SearchFlags enumeration.
                 * activeSheet.getCell(2,3).value("testSearch");
                 * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                 * searchCondition.searchString = "testSearch";
                 * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                 * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                 * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.ignoreCase| GCTYPE.Spread.Sheets.Search.SearchFlags.useWildCards;
                 * var searchresult= activeSheet.search(searchCondition);
                 * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" +
                 * searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundSheetIndex+"]";
                 * alert(str);
                 */
                export enum SearchFoundFlags{
                    /**
                     * Indicates that no string is found.
                     * @type {number}
                     */
                    none= 0,
                    /**
                     * Indicates that the string is found in the cell text.
                     * @type {number}
                     */
                    cellText= 1,
                    /**
                     * Indicates that the string is found in the cell tag.
                     * @type {number}
                     */
                    cellTag= 4,
                    /**
                     * Indicates that the string is found in the cell formula.
                     * @type {number}
                     */
                    cellFormula= 8
                }

                /**
                 * Specifies the type of search direction.
                 * @enum {number}
                 * @example
                 * //This example uses the SearchFlags enumeration.
                 * activeSheet.getCell(2,3).value("testSearch");
                 * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                 * searchCondition.searchString = "testSearch";
                 * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                 * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                 * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                 * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.ignoreCase| GCTYPE.Spread.Sheets.Search.SearchFlags.useWildCards;
                 * var searchresult= activeSheet.search(searchCondition);
                 * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" +
                 * searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundSheetIndex+"]";
                 * alert(str);
                 */
                export enum SearchOrder{
                    /** Determines whether the search goes by column, row coordinates.
                     * @type {number}
                     */
                    zOrder= 0,
                    /** Determines whether the search goes by row, column coordinates.
                     * @type {number}
                     */
                    nOrder= 1
                }


                export class SearchCondition{
                    /**
                     * Defines the search condition.
                     * @class
                     * @example
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.ignoreCase| GCTYPE.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", * foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    constructor();
                    /** The index of the column at which to end.
                     * @type {number}
                     * @example
                     * //This example searches a block of cells.
                     * activeSheet.getCell(0,0).text("testSearch");
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.columnStart = 1;
                     * searchCondition.columnEnd = 10;
                     * searchCondition.rowStart = 1;
                     * searchCondition.rowEnd = 10;
                     * searchCondition.sheetArea = GCTYPE.Spread.Sheets.SheetArea.viewport;
                     * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.blockRange;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    columnEnd: number;
                    /** The index of the column at which to start.
                     * @type {number}
                     * @example
                     * //This example searches a block of cells.
                     * activeSheet.getCell(0,0).text("testSearch");
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.columnStart = 1;
                     * searchCondition.columnEnd = 10;
                     * searchCondition.rowStart = 1;
                     * searchCondition.rowEnd = 10;
                     * searchCondition.sheetArea = GCTYPE.Spread.Sheets.SheetArea.viewport;
                     * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.blockRange;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    columnStart: number;
                    /** Index of the sheet on which to end searching.
                     * @type {number}
                     * @example
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.ignoreCase| GCTYPE.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    endSheetIndex: number;
                    /** The index of the row at which to end.
                     * @type {number}
                     * @example
                     * //This example searches a block of cells.
                     * activeSheet.getCell(0,0).text("testSearch");
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.columnStart = 1;
                     * searchCondition.columnEnd = 10;
                     * searchCondition.rowStart = 1;
                     * searchCondition.rowEnd = 10;
                     * searchCondition.sheetArea = GCTYPE.Spread.Sheets.SheetArea.viewport;
                     * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.blockRange;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    rowEnd: number;
                    /** The index of the row at which to start.
                     * @type {number}
                     * @example
                     * //This example searches a block of cells.
                     * activeSheet.getCell(0,0).text("testSearch");
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.columnStart = 1;
                     * searchCondition.columnEnd = 10;
                     * searchCondition.rowStart = 1;
                     * searchCondition.rowEnd = 10;
                     * searchCondition.sheetArea = GCTYPE.Spread.Sheets.SheetArea.viewport;
                     * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.blockRange;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    rowStart: number;
                    /** The enumeration that specifies the options of the search.
                     * @type {GCTYPE.Spread.Sheets.Search.SearchFlags}
                     * @example
                     * //This example sets the searchFlags property.
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.ignoreCase| GCTYPE.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    searchFlags: GCTYPE.Spread.Sheets.Search.SearchFlags;
                    /** The enumeration that specifies whether the search goes by coordinates of (column, row) or (row, column).
                     * @type {GCTYPE.Spread.Sheets.Search.SearchOrder}
                     * @example
                     * //This example sets the searchFlags property.
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.ignoreCase| GCTYPE.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    searchOrder: GCTYPE.Spread.Sheets.Search.SearchOrder;
                    /** The string for which to search.
                     * @type {string}
                     * @example
                     * //This example sets the searchFlags property.
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.ignoreCase| GCTYPE.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    searchString: string;
                    /** The enumeration that indicates whether the search includes the content in the cell notes, tags, or text.
                     * @type {GCTYPE.Spread.Sheets.Search.SearchFoundFlags}
                     * @example
                     * //This example sets the searchFlags property.
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.ignoreCase| GCTYPE.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    searchTarget: GCTYPE.Spread.Sheets.Search.SearchFoundFlags;
                    /** The area of the sheet for search.
                     * @type {GCTYPE.Spread.Sheets.SheetArea}
                     * @example
                     * //This example searches a block of cells.
                     * activeSheet.getCell(0,0).text("testSearch");
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.columnStart = 1;
                     * searchCondition.columnEnd = 10;
                     * searchCondition.rowStart = 1;
                     * searchCondition.rowEnd = 10;
                     * searchCondition.sheetArea = GCTYPE.Spread.Sheets.SheetArea.viewport;
                     * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.blockRange;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    sheetArea: GCTYPE.Spread.Sheets.SheetArea;
                    /** Index of the sheet on which to start searching.
                     * @type {number}
                     * @example
                     * //This example searches a block of cells.
                     * activeSheet.getCell(0,0).text("testSearch");
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.columnStart = 1;
                     * searchCondition.columnEnd = 10;
                     * searchCondition.rowStart = 1;
                     * searchCondition.rowEnd = 10;
                     * searchCondition.sheetArea = GCTYPE.Spread.Sheets.SheetArea.viewport;
                     * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.blockRange;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    startSheetIndex: number;
                }

                export class SearchResult{
                    /**
                     * Defines the search result.
                     * @class
                     */
                    constructor();
                    /** The index of the column at which a match is found.
                     * @type {number}
                     * @example
                     * //This example gets the foundColumnIndex property.
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.ignoreCase| GCTYPE.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    foundColumnIndex: number;
                    /** The index of the row at which a match is found.
                     * @type {number}
                     * @example
                     * //This example gets the foundColumnIndex property.
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.ignoreCase| GCTYPE.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    foundRowIndex: number;
                    /** The index of the sheet in which a match is found.
                     * @type {number}
                     * @example
                     * //This example gets the foundColumnIndex property.
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.ignoreCase| GCTYPE.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    foundSheetIndex: number;
                    /** The found string.
                     * @type {object}
                     * @example
                     * //This example gets the foundColumnIndex property.
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.ignoreCase| GCTYPE.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    foundString: Object;
                    /**
                     * An enumeration that specifies what is matched.
                     * @type {GCTYPE.Spread.Sheets.Search.SearchFoundFlags}
                     * @example
                     * //This example gets the foundColumnIndex property.
                     * activeSheet.getCell(5,4).text("testSearch");
                     * var searchCondition = new GCTYPE.Spread.Sheets.Search.SearchCondition();
                     * searchCondition.searchString = "testSearch";
                     * searchCondition.startSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.endSheetIndex = spread.getActiveSheetIndex();
                     * searchCondition.searchOrder = GCTYPE.Spread.Sheets.Search.SearchOrder.nOrder;
                     * searchCondition.searchTarget = GCTYPE.Spread.Sheets.Search.SearchFoundFlags.cellText;
                     * searchCondition.searchFlags = GCTYPE.Spread.Sheets.Search.SearchFlags.ignoreCase| GCTYPE.Spread.Sheets.Search.SearchFlags.useWildCards;
                     * var searchresult= spread.search(searchCondition);
                     * var str ="[searchFoundFlag:"+ searchresult.searchFoundFlag+",\r\n foundSheetIndex:"+searchresult.foundSheetIndex+",foundRowIndex:" + searchresult.foundRowIndex+", foundColumnIndex:"+searchresult.foundColumnIndex+", foundString:"+searchresult.foundString+"]";
                     * alert(str);
                     */
                    searchFoundFlag: GCTYPE.Spread.Sheets.Search.SearchFoundFlags;
                }
            }

            module Shapes{

                export interface IControlInfo{
                    x: number | string; // A number value or a formula string (starts with =) will get a number value
                    y: number | string; // A number value or a formula string (starts with =) will get a number value
                    xBehavior: 0 | 1;   // 0 if can do adjust in x (horizontal), otherwise 1
                    yBehavior: 0 | 1;   // 0 if can do adjust in y (vertical), otherwise 1
                }


                export interface IGradientColorStopOption{
                    color: string;
                    position: number;
                    transparency?: number;
                    brightness?: number;
                }


                export interface IGradientFillOption{
                    type: GCTYPE.Spread.Sheets.Shapes.GradientFillType;
                    stops: GCTYPE.Spread.Sheets.Shapes.IGradientColorStopOption[];
                    angle?: number;
                    direction?: GCTYPE.Spread.Sheets.Shapes.LinearGradientFillDirection | GCTYPE.Spread.Sheets.Shapes.RadialGradientFillDirection;
                }


                export interface IPictureFillOption{
                    src: string;
                    tilePictureAsTexture?: false;
                    transparency?: number;
                    offsetLeft?: number;
                    offsetRight?: number;
                    offsetTop?: number;
                    offsetBottom?: number;
                }


                export interface IPointInfo{
                    x: number | string; // A number value or a formula string (starts with =) will get a number value
                    y: number | string; // A number value or a formula string (starts with =) will get a number value
                }


                export interface IShapeBorder{
                    color: string;
                    lineStyle: GCTYPE.Spread.Sheets.Shapes.PresetLineDashStyle;
                    width: number;
                    capType: GCTYPE.Spread.Sheets.Shapes.LineCapStyle;
                    joinType: GCTYPE.Spread.Sheets.Shapes.LineJoinStyle;
                    compoundType: GCTYPE.Spread.Sheets.Shapes.CompoundType;
                }


                export interface IShapeConnector{
                    name: string;
                    index: number;
                    shape?: GCTYPE.Spread.Sheets.Shapes.Shape;
                }


                export interface IShapeFill{
                    type?: GCTYPE.Spread.Sheets.Shapes.ShapeFillType | string;
                    color?: string;
                    transparency?: number | string;
                }


                export interface IShapeFillOption{
                    type?: GCTYPE.Spread.Sheets.Shapes.ShapeFillType;
                    color?: string;
                    transparency?: number; // 0 ~ 1
                }


                export interface IShapeGradientFill{
                    type: GCTYPE.Spread.Sheets.Shapes.GradientFillType | string;
                    stops: GCTYPE.Spread.Sheets.Shapes.IShapeGradientFillColorStop[];
                    angle?: number | string;
                    direction?: GCTYPE.Spread.Sheets.Shapes.LinearGradientFillDirection | GCTYPE.Spread.Sheets.Shapes.RadialGradientFillDirection | string;
                }


                export interface IShapeGradientFillColorStop{
                    color: string;
                    position: number | string;
                    transparency?: number | string;
                    brightness?: number | string;
                }


                export interface IShapeLine{
                    color?: string;
                    lineStyle?: GCTYPE.Spread.Sheets.Shapes.PresetLineDashStyle | string;
                    width?: number | string;
                    capType?: GCTYPE.Spread.Sheets.Shapes.LineCapStyle | string;
                    joinType?: GCTYPE.Spread.Sheets.Shapes.LineJoinStyle | string;
                    compoundType?: GCTYPE.Spread.Sheets.Shapes.CompoundType | string;
                    transparency?: number | string;
                    beginArrowheadStyle?: GCTYPE.Spread.Sheets.Shapes.ArrowheadStyle;
                    beginArrowheadWidth?: GCTYPE.Spread.Sheets.Shapes.ArrowheadWidth;
                    beginArrowheadLength?: GCTYPE.Spread.Sheets.Shapes.ArrowheadLength;
                    endArrowheadStyle?: GCTYPE.Spread.Sheets.Shapes.ArrowheadStyle;
                    endArrowheadWidth?: GCTYPE.Spread.Sheets.Shapes.ArrowheadWidth;
                    endArrowheadLength?: GCTYPE.Spread.Sheets.Shapes.ArrowheadLength;
                }


                export interface IShapeLineArrowConfig{
                    type: GCTYPE.Spread.Sheets.Shapes.ArrowheadStyle;
                    widthType: GCTYPE.Spread.Sheets.Shapes.ArrowheadWidth;
                    lengthType: GCTYPE.Spread.Sheets.Shapes.ArrowheadLength;
                }


                export interface IShapeLineArrowOption{
                    beginArrow?: GCTYPE.Spread.Sheets.Shapes.IShapeLineArrowConfig;
                    endArrow?: GCTYPE.Spread.Sheets.Shapes.IShapeLineArrowConfig;
                }


                export interface IShapeModel{
                    id?: string;
                    left?: number | string; // A number value or a formula string (starts with =) will get a number value
                    top?: number | string; // A number value or a formula string (starts with =) will get a number value
                    width?: number | string; // A number value or a formula string (starts with =) will get a number value
                    height?: number | string; // A number value or a formula string (starts with =) will get a number value
                    angle?: number | string; // A number value or a formula string (starts with =) will get a number value
                    options?: GCTYPE.Spread.Sheets.Shapes.IShapeOptions;
                    path: string[][];
                    controls?: GCTYPE.Spread.Sheets.Shapes.IControlInfo[];
                    connectionPoints?: GCTYPE.Spread.Sheets.Shapes.IPointInfo[];
                    variables?: Object;    // a key-value pairs object, value can be a number or formula string (starts with =), can be referred by variables[key] in formula
                    textRect?: {left: number, top: number, bottom: number, right: number }; // specify the rectangle for shape text
                }


                export interface IShapeOptions{
                    fill?: GCTYPE.Spread.Sheets.Shapes.IShapeFillOption | GCTYPE.Spread.Sheets.Shapes.IGradientFillOption | GCTYPE.Spread.Sheets.Shapes.IPictureFillOption | GCTYPE.Spread.Sheets.Shapes.ITextureFillOption;
                    textFormatOptions?: GCTYPE.Spread.Sheets.Shapes.IShapeTextFormatOption;
                    stroke?: GCTYPE.Spread.Sheets.Shapes.IShapeStrokeOption;
                    endPoints?: GCTYPE.Spread.Sheets.Shapes.IShapeLineArrowOption
                }


                export interface IShapePictureFill{
                    src: string;
                    tilePictureAsTexture?: false | string;
                    transparency?: number | string;
                    offsetLeft?: number | string;
                    offsetRight?: number | string;
                    offsetTop?: number | string;
                    offsetBottom?: number | string;
                }


                export interface IShapeStrokeOption{
                    type: 0 | 1;   // 0: none, 1: solid
                    color?: string;
                    width?: number;
                    capType?: 0 | 1 | 2;    // 0: round, 1: square, 2: butt
                    joinType?: 0 | 1 | 2;   // 0: round, 1: miter, 2: bevel
                    compoundType?: 0 | 1 | 2 | 3 | 4;     // 0: simple, 1: double, 2: thickThin, 3: thinThick, 4: triple
                    lineStyle?: GCTYPE.Spread.Sheets.Shapes.PresetLineDashStyle;
                }


                export interface IShapeTextEffect{
                    color?: string;
                    transparency?: number | string;
                    font?: string;
                }


                export interface IShapeTextFormatOption{
                    text?: string;
                    fill?: GCTYPE.Spread.Sheets.Shapes.IShapeFillOption;
                    font?: string;     // css font string
                    margins?: [number, number, number, number];
                    textDirection?:  "horizontal" | "vertical" | "rotate90" | "rotate270";
                    horizontalAlignment?: 0 | 1 | 2;   // 0: left, 1: center, 2: right
                    verticalAlignment?: 0 | 1 | 2;     // 0: top, 1: center, 2: bottom
                    wrapTextInShape?: boolean;
                    allowTextToOverflowShape?: boolean;
                }


                export interface IShapeTextFrame{
                    vAlign?: GCTYPE.Spread.Sheets.VerticalAlign | string;
                    hAlign?: GCTYPE.Spread.Sheets.HorizontalAlign | string;
                }


                export interface IShapeTextureFill{
                    src: string;
                    tilePictureAsTexture: true | string;
                    transparency?: number | string;
                    offsetX?: number | string;
                    offsetY?: number | string;
                    scaleX?: number | string;
                    scaleY?: number | string;
                    alignment?: GCTYPE.Spread.Sheets.Shapes.TextureFillAlignment | string;
                    mirrorType?: GCTYPE.Spread.Sheets.Shapes.TextureFillMirrorType | string;
                }


                export interface ITextureFillOption{
                    src: string;
                    tilePictureAsTexture: true;
                    transparency?: number;
                    offsetX?: number;
                    offsetY?: number;
                    scaleX?: number;
                    scaleY?: number;
                    alignment?: GCTYPE.Spread.Sheets.Shapes.TextureFillAlignment;
                    mirrorType?: GCTYPE.Spread.Sheets.Shapes.TextureFillMirrorType;
                }

                /**
                 * Specifies the length of the arrowhead at the end of a line.
                 * @enum {number}
                 */
                export enum ArrowheadLength{
                    /**
                     * Short
                     */
                    short= 0,
                    /**
                     * Medium
                     */
                    medium= 1,
                    /**
                     * Long
                     */
                    long= 2
                }

                /**
                 * Specifies the style of the arrowhead at the end of a line.
                 * @enum {number}
                 */
                export enum ArrowheadStyle{
                    /**
                     * No arrowhead
                     */
                    none= 0,
                    /**
                     * Triangular
                     */
                    triangle= 1,
                    /**
                     * Stealth-shaped
                     */
                    stealth= 2,
                    /**
                     * Diamond-shaped
                     */
                    diamond= 3,
                    /**
                     * Oval-shaped
                     */
                    oval= 4,
                    /**
                     * Open
                     */
                    open= 5
                }

                /**
                 * Specifies the width of the arrowhead at the end of a line.
                 * @enum {number}
                 */
                export enum ArrowheadWidth{
                    /**
                     * Narrow
                     */
                    narrow= 0,
                    /**
                     * Medium
                     */
                    medium= 1,
                    /**
                     * Wide
                     */
                    wide= 2
                }

                /**
                 * Defines all the types of build-in shapes.
                 * @enum {number}
                 */
                export enum AutoShapeType{
                    /**
                     * Specifies a rectangle.
                     */
                    rectangle= 1,
                    /**
                     * Specifies a parallelogram.
                     */
                    parallelogram= 2,
                    /**
                     * Specifies a trapezoid.
                     */
                    trapezoid= 3,
                    /**
                     * Specifies a diamond.
                     */
                    diamond= 4,
                    /**
                     * Specifies a rounded rectangle.
                     */
                    roundedRectangle= 5,
                    /**
                     * Specifies an octagon.
                     */
                    octagon= 6,
                    /**
                     * Specifies an isosceles triangle.
                     */
                    isoscelesTriangle= 7,
                    /**
                     * Specifies a right triangle.
                     */
                    rightTriangle= 8,
                    /**
                     * Specifies an oval.
                     */
                    oval= 9,
                    /**
                     * Specifies a hexagon.
                     */
                    hexagon= 10,
                    /**
                     * Specifies a cross.
                     */
                    cross= 11,
                    /**
                     * Specifies a pentagon.
                     */
                    regularPentagon= 12,
                    /**
                     * Specifies a can.
                     */
                    can= 13,
                    /**
                     * Specifies a cube.
                     */
                    cube= 14,
                    /**
                     * Specifies a bevel.
                     */
                    bevel= 15,
                    /**
                     * Specifies a folded corner.
                     */
                    foldedCorner= 16,
                    /**
                     * Specifies a smiley face.
                     */
                    smileyFace= 17,
                    /**
                     * Specifies a donut.
                     */
                    donut= 18,
                    /**
                     * Specifies the "No" symbol.
                     */
                    noSymbol= 19,
                    /**
                     * Specifies a block arc.
                     */
                    blockArc= 20,
                    /**
                     * Specifies a heart.
                     */
                    heart= 21,
                    /**
                     * Specifies a lightning bolt.
                     */
                    lightningBolt= 22,
                    /**
                     * Specifies a sun.
                     */
                    sun= 23,
                    /**
                     * Specifies a moon.
                     */
                    moon= 24,
                    /**
                     * Specifies an arc.
                     */
                    arc= 25,
                    /**
                     * Specifies a double bracket.
                     */
                    doubleBracket= 26,
                    /**
                     * Specifies a double brace.
                     */
                    doubleBrace= 27,
                    /**
                     * Specifies a plaque.
                     */
                    plaque= 28,
                    /**
                     * Specifies the left bracket.
                     */
                    leftBracket= 29,
                    /**
                     * Specifies the right bracket.
                     */
                    rightBracket= 30,
                    /**
                     * Specifies the left brace.
                     */
                    leftBrace= 31,
                    /**
                     * Specifies the right brace.
                     */
                    rightBrace= 32,
                    /**
                     * Specifies a block arrow that points right.
                     */
                    rightArrow= 33,
                    /**
                     * Specifies a block arrow that points left.
                     */
                    leftArrow= 34,
                    /**
                     * Specifies a block arrow that points up.
                     */
                    upArrow= 35,
                    /**
                     * Specifies a block arrow that points down.
                     */
                    downArrow= 36,
                    /**
                     * Specifies a block arrow with arrowheads that point both left and right.
                     */
                    leftRightArrow= 37,
                    /**
                     * Specifies a block arrow that points up and down.
                     */
                    upDownArrow= 38,
                    /**
                     * Specifies block arrows that point up, down, left, and right.
                     */
                    quadArrow= 39,
                    /**
                     * Specifies a block arrow with arrowheads that point left, right, and up.
                     */
                    leftRightUpArrow= 40,
                    /**
                     * Specifies a block arrow that follows a curved 90-degree angle.
                     */
                    bentArrow= 41,
                    /**
                     * Specifies a block arrow forming a U shape.
                     */
                    uTurnArrow= 42,
                    /**
                     * Specifies a block arrow with arrowheads that point left and up.
                     */
                    leftUpArrow= 43,
                    /**
                     * Specifies a block arrow that follows a sharp 90-degree angle. Points up by default.
                     */
                    bentUpArrow= 44,
                    /**
                     * Specifies a block arrow that curves right
                     */
                    curvedRightArrow= 45,
                    /**
                     * Specifies a block arrow that curves left.
                     */
                    curvedLeftArrow= 46,
                    /**
                     * Specifies a block arrow that curves up.
                     */
                    curvedUpArrow= 47,
                    /**
                     * Specifies a block arrow that curves down.
                     */
                    curvedDownArrow= 48,
                    /**
                     * Specifies a block arrow that points right with stripes at the tail.
                     */
                    stripedRightArrow= 49,
                    /**
                     * Specifies a notched block arrow that points right
                     */
                    notchedRightArrow= 50,
                    /**
                     * Specifies a pentagon.
                     */
                    pentagon= 51,
                    /**
                     * Specifies a chevron.
                     */
                    chevron= 52,
                    /**
                     * Specifies a callout with an arrow that points right.
                     */
                    rightArrowCallout= 53,
                    /**
                     * Specifies a callout with an arrow that points left.
                     */
                    leftArrowCallout= 54,
                    /**
                     * Specifies a callout with an arrow that points up.
                     */
                    upArrowCallout= 55,
                    /**
                     * Specifies a callout with an arrow that points down.
                     */
                    downArrowCallout= 56,
                    /**
                     * Specifies a callout with arrowheads that point both left and right.
                     */
                    leftRightArrowCallout= 57,
                    /**
                     * Specifies a callout with arrows that point up and down.
                     */
                    upDownArrowCallout= 58,
                    /**
                     * Specifies a callout with arrows that point up, down, left, and right.
                     */
                    quadArrowCallout= 59,
                    /**
                     * Specifies a block arrow that follows a curved 180-degree angle.
                     */
                    circularArrow= 60,
                    /**
                     * Specifies a process flowchart symbol.
                     */
                    flowchartProcess= 61,
                    /**
                     * Specifies an alternate process flowchart symbol.
                     */
                    flowchartAlternateProcess= 62,
                    /**
                     * Specifies a decision flowchart symbol.
                     */
                    flowchartDecision= 63,
                    /**
                     * Specifies a data flowchart symbol.
                     */
                    flowchartData= 64,
                    /**
                     * Specifies a predefined process flowchart symbol.
                     */
                    flowchartPredefinedProcess= 65,
                    /**
                     * Specifies an internal storage flowchart symbol.
                     */
                    flowchartInternalStorage= 66,
                    /**
                     * Specifies a document flowchart symbol.
                     */
                    flowchartDocument= 67,
                    /**
                     * Specifies a multi-document flowchart symbol.
                     */
                    flowchartMultidocument= 68,
                    /**
                     * Specifies a terminator flowchart symbol.
                     */
                    flowchartTerminator= 69,
                    /**
                     * Specifies a preparation flowchart symbol.
                     */
                    flowchartPreparation= 70,
                    /**
                     * Specifies a manual input flowchart symbol.
                     */
                    flowchartManualInput= 71,
                    /**
                     * Specifies a manual operation flowchart symbol.
                     */
                    flowchartManualOperation= 72,
                    /**
                     * Specifies a connector flowchart symbol.
                     */
                    flowchartConnector= 73,
                    /**
                     * Specifies an off-page connector flowchart symbol.
                     */
                    flowchartOffpageConnector= 74,
                    /**
                     * Specifies a card flowchart symbol.
                     */
                    flowchartCard= 75,
                    /**
                     * Specifies a punched tape flowchart symbol.
                     */
                    flowchartPunchedTape= 76,
                    /**
                     * Specifies a summing junction flowchart symbol.
                     */
                    flowchartSummingJunction= 77,
                    /**
                     * Specifies the "Or" flowchart symbol.
                     */
                    flowchartOr= 78,
                    /**
                     * Specifies a collate flowchart symbol.
                     */
                    flowchartCollate= 79,
                    /**
                     * Specifies a sort flowchart symbol.
                     */
                    flowchartSort= 80,
                    /**
                     * Specifies an extract flowchart symbol.
                     */
                    flowchartExtract= 81,
                    /**
                     * Specifies a merge flowchart symbol.
                     */
                    flowchartMerge= 82,
                    /**
                     * Specifies a stored data flowchart symbol.
                     */
                    flowchartStoredData= 83,
                    /**
                     * Specifies a delay flowchart symbol.
                     */
                    flowchartDelay= 84,
                    /**
                     * Specifies a sequential access storage flowchart symbol.
                     */
                    flowchartSequentialAccessStorage= 85,
                    /**
                     * Specifies a magnetic disk flowchart symbol.
                     */
                    flowchartMagneticDisk= 86,
                    /**
                     * Specifies a direct access storage flowchart symbol.
                     */
                    flowchartDirectAccessStorage= 87,
                    /**
                     * Specifies a display flowchart symbol.
                     */
                    flowchartDisplay= 88,
                    /**
                     * Specifies an explosion.
                     */
                    explosion1= 89,
                    /**
                     * Specifies an explosion.
                     */
                    explosion2= 90,
                    /**
                     * Specifies a 4-point star.
                     */
                    shape4pointStar= 91,
                    /**
                     * Specifies a 5-point star.
                     */
                    shape5pointStar= 92,
                    /**
                     * Specifies an 8-point star.
                     */
                    shape8pointStar= 93,
                    /**
                     * Specifies a 16-point star.
                     */
                    shape16pointStar= 94,
                    /**
                     * Specifies a 24-point star.
                     */
                    shape24pointStar= 95,
                    /**
                     * Specifies a 32-point star.
                     */
                    shape32pointStar= 96,
                    /**
                     * Specifies a ribbon banner with a center area above the ribbon ends.
                     */
                    upRibbon= 97,
                    /**
                     * Specifies a ribbon banner with a center area below the ribbon ends.
                     */
                    downRibbon= 98,
                    /**
                     * Specifies a ribbon banner that curves up.
                     */
                    curvedUpRibbon= 99,
                    /**
                     * Specifies a ribbon banner that curves down.
                     */
                    curvedDownRibbon= 100,
                    /**
                     * Specifies a vertical scroll shape.
                     */
                    verticalScroll= 101,
                    /**
                     * Specifies a horizontal scroll shape.
                     */
                    horizontalScroll= 102,
                    /**
                     * Specifies a wave shape.
                     */
                    wave= 103,
                    /**
                     * Specifies a double wave shape.
                     */
                    doubleWave= 104,
                    /**
                     * Specifies a rectangular callout.
                     */
                    rectangularCallout= 105,
                    /**
                     * Specifies a rounded rectangle-shaped callout.
                     */
                    roundedRectangularCallout= 106,
                    /**
                     * Specifies an oval-shaped callout.
                     */
                    ovalCallout= 107,
                    /**
                     * Specifies a cloud callout.
                     */
                    cloudCallout= 108,
                    /**
                     * Specifies a callout with border and horizontal callout lines.
                     */
                    lineCallout1= 109,
                    /**
                     * Specifies a callout with a diagonal straight line.
                     */
                    lineCallout2= 110,
                    /**
                     * Specifies a callout with an angled line.
                     */
                    lineCallout3= 111,
                    /**
                     * Specifies a callout with callout line segments forming a U-shape.
                     */
                    lineCallout4= 112,
                    /**
                     * Specifies a callout with a horizontal accent bar.
                     */
                    lineCallout1AccentBar= 113,
                    /**
                     * Specifies a callout with a diagonal callout line and accent bar.
                     */
                    lineCallout2AccentBar= 114,
                    /**
                     * Specifies a callout with an angled callout line and accent bar.
                     */
                    lineCallout3AccentBar= 115,
                    /**
                     * Specifies a callout with an accent bar and callout line segments forming a U-shape.
                     */
                    lineCallout4AccentBar= 116,
                    /**
                     * Specifies a callout with a horizontal line.
                     */
                    lineCallout1NoBorder= 117,
                    /**
                     * Specifies a callout with no border and a diagonal callout line.
                     */
                    lineCallout2NoBorder= 118,
                    /**
                     * Specifies a callout with no border and an angled callout line.
                     */
                    lineCallout3NoBorder= 119,
                    /**
                     * Specifies a callout with no border and callout line segments forming a U-shape.
                     */
                    lineCallout4NoBorder= 120,
                    /**
                     * Specifies a callout with a border and horizontal accent bar.
                     */
                    lineCallout1BorderandAccentBar= 121,
                    /**
                     * Specifies a callout with border, diagonal straight line, and accent bar.
                     */
                    lineCallout2BorderandAccentBar= 122,
                    /**
                     * Specifies a callout with border, angled callout line, and accent bar.
                     */
                    lineCallout3BorderandAccentBar= 123,
                    /**
                     * Specifies a callout with border, accent bar, and callout line segments forming a U-shape.
                     */
                    lineCallout4BorderandAccentBar= 124,
                    /**
                     * Specifies a button with no default picture or text. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonCustom= 125,
                    /**
                     * Specifies the Home button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonHome= 126,
                    /**
                     * Specifies the Help button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonHelp= 127,
                    /**
                     * Specifies the Information button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonInformation= 128,
                    /**
                     * Specifies the Back or Previous button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonBackorPrevious= 129,
                    /**
                     * Specifies the Forward or Next button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonForwardorNext= 130,
                    /**
                     * Specifies the Beginning button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonBeginning= 131,
                    /**
                     * Specifies the End button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonEnd= 132,
                    /**
                     * Specifies the Return button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonReturn= 133,
                    /**
                     * Specifies the Document button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonDocument= 134,
                    /**
                     * Specifies the Sound button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonSound= 135,
                    /**
                     * Specifies the Movie button. Supports mouse-click and mouse-over actions.
                     */
                    actionButtonMovie= 136,
                    /**
                     * Specifies a balloon.
                     */
                    balloon= 137,
                    /**
                     * Specifies an offline storage flowchart symbol.
                     */
                    flowchartOfflineStorage= 138,
                    /**
                     * Specifies a ribbon with an arrow at both ends.
                     */
                    leftRightRibbon= 139,
                    /**
                     * Specifies a rectangle with two triangle-shapes removed; a diagonal stripe.
                     */
                    diagonalStripe= 140,
                    /**
                     * Specifies a circle (\u2018pie\u2019) with a portion missing.
                     */
                    pie= 141,
                    /**
                     * Specifies a trapezoid with asymmetrical non-parallel sides.
                     */
                    nonIsoscelesTrapezoid= 142,
                    /**
                     * Specifies a decagon.
                     */
                    decagon= 143,
                    /**
                     * Specifies a heptagon.
                     */
                    heptagon= 144,
                    /**
                     * Specifies a dodecagon
                     */
                    dodecagon= 145,
                    /**
                     * Specifies a 6-point star.
                     */
                    star6Point= 146,
                    /**
                     * Specifies a 7-point star.
                     */
                    star7Point= 147,
                    /**
                     * Specifies a 10-point star.
                     */
                    star10Point= 148,
                    /**
                     * Specifies a 12-point star.
                     */
                    star12Point= 149,
                    /**
                     * Specifies a rectangle with one rounded corner.
                     */
                    round1Rectangle= 150,
                    /**
                     * Specifies a rectangle with two-rounded corners that share a side.
                     */
                    round2SameRectangle= 151,
                    /**
                     * Specifies a rectangle with two rounded corners, diagonally-opposed.
                     */
                    round2DiagRectangle= 152,
                    /**
                     * Specifies a rectangle with one snipped corner and one rounded corner.
                     */
                    snipRoundRectangle= 153,
                    /**
                     * Specifies a rectangle with one snipped corner.
                     */
                    snip1Rectangle= 154,
                    /**
                     * Specifies a rectangle with two snipped corners that share a side.
                     */
                    snip2SameRectangle= 155,
                    /**
                     * Specifies a rectangle with two snipped corners, diagonally-opposed.
                     */
                    snip2DiagRectangle= 156,
                    /**
                     * Specifies a rectangular picture frame.
                     */
                    frame= 157,
                    /**
                     * Specifies half of a rectangular picture frame.
                     */
                    halfFrame= 158,
                    /**
                     * Specifies a water droplet.
                     */
                    tear= 159,
                    /**
                     * Specifies a circle with a line connecting two points on the perimeter through the interior of the circle; a circle with a chord.
                     */
                    chord= 160,
                    /**
                     * Specifies a rectangle with a rectangular-shaped hole.
                     */
                    corner= 161,
                    /**
                     * Specifies the addition symbol \u2018+\u2019.
                     */
                    mathPlus= 162,
                    /**
                     * Specifies the subtraction symbol \u2018-\u2018.
                     */
                    mathMinus= 163,
                    /**
                     * Specifies the multiplication symbol \u2018x\u2019.
                     */
                    mathMultiply= 164,
                    /**
                     * Specifies the division symbol \u2018\xf7\u2019.
                     */
                    mathDivide= 165,
                    /**
                     * Specifies the equivalence symbol \u2018=\u2019.
                     */
                    mathEqual= 166,
                    /**
                     * Specifies the non-equivalence symbol \u2018\u2260\u2019.
                     */
                    mathNotEqual= 167,
                    /**
                     * Specifies four right triangles aligning along a rectangular path with four \u2018snipped\u2019 corners.
                     */
                    cornerTabs= 168,
                    /**
                     * Specifies four small squares that define a rectangular shape.
                     */
                    squareTabs= 169,
                    /**
                     * Specifies four quarter-circles defining a rectangular shape.
                     */
                    plaqueTabs= 170,
                    /**
                     * Specifies a gear with six teeth.
                     */
                    gear6= 171,
                    /**
                     * Specifies a gear with nine teeth
                     */
                    gear9= 172,
                    /**
                     * Specifies a funnel.
                     */
                    funnel= 173,
                    /**
                     * Specifies a quarter of a circular shape.
                     */
                    pieWedge= 174,
                    /**
                     * Specifies a circular arrow pointing counter-clockwise.
                     */
                    leftCircularArrow= 175,
                    /**
                     * Specifies a circular arrow pointing clockwise and counter-clockwise; a curved arrow with points at both ends.
                     */
                    leftRightCircularArrow= 176,
                    /**
                     * Specifies a curved arrow.
                     */
                    swooshArrow= 177,
                    /**
                     * Specifies a cloud shape.
                     */
                    cloud= 178,
                    /**
                     * Specifies a square divided into four parts along diagonal lines.
                     */
                    chartX= 179,
                    /**
                     * Specifies a square divided six parts along vertical and diagonal lines.
                     */
                    chartStar= 180,
                    /**
                     * Specifies a square divided vertically and horizontally into four quarters.
                     */
                    chartPlus= 181,
                    /**
                     * Specifies an inverse line.
                     */
                    lineInverse= 182,
                    /**
                     * Specifies an inverse line.
                     */
                    line= 183
                }

                /**
                 * Specifies the shape line compound type.
                 * @enum {number}
                 */
                export enum CompoundType{
                    /**
                     * Specifies only display one line around shape path
                     */
                    simple= 0,
                    /**
                     * Specifies two lines display at both sides of shape path
                     */
                    double= 1,
                    /**
                     * Specifies two lines, one thick line display at shape outter range, another thin line display at shape inner range
                     */
                    thickThin= 2,
                    /**
                     * Specifies two lines, one thin line display at shape outter range, another thick line display at shape inner range
                     */
                    thinThick= 3,
                    /**
                     * Specifies three lines, one thick line display around shape path, the other two thin line display at inner and outter shape range
                     */
                    triple= 4
                }

                /**
                 * Defines the type of Connector.
                 * @enum {number}
                 */
                export enum ConnectorType{
                    /**
                     * Specifies a straight line connector.
                     */
                    straight= 0,
                    /**
                     * Specifies an elbow connector.
                     */
                    elbow= 1
                }

                /**
                 * Defines gradient fill type of shape.
                 * @enum {number}
                 */
                export enum GradientFillType{
                    /**
                     * Linear Gradient Fill
                     */
                    linear= 0,
                    /**
                     * Radial Gradient Fill
                     */
                    radial= 1
                }

                /**
                 * Specifies shape horizontal alignment.
                 * @enum {number}
                 */
                export enum HorizontalAlign{
                    /**
                     * Left
                     */
                    left= 0,
                    /**
                     * Center
                     */
                    center= 1,
                    /**
                     * Right
                     */
                    right= 2
                }

                /**
                 * Defines linear gradient fill direction of shape.
                 * @enum {number}
                 */
                export enum LinearGradientFillDirection{
                    /**
                     * Linear Right
                     */
                    linearRight= 0,
                    /**
                     * Top Left To Bottom Right
                     */
                    topLeftToBottomRight= 45,
                    /**
                     * Linear Down
                     */
                    linearDown= 90,
                    /**
                     * Top Right To Bottom Right
                     */
                    topRightToBottomLeft= 135,
                    /**
                     * Linear Left
                     */
                    linearLeft= 180,
                    /**
                     * Bottom Right To TopLeft
                     */
                    bottomRightToTopLeft= 225,
                    /**
                     * Linear Up
                     */
                    linearUp= 270,
                    /**
                     * Bottom Left To Top Right
                     */
                    bottomLeftToTopRight= 315
                }

                /**
                 * Specifies the cap type for a line.
                 * @enum {number}
                 */
                export enum LineCapStyle{
                    /**
                     * Specifies the end of the line is flat.
                     */
                    flat= 2,
                    /**
                     * Specifies the end of the line is capped with a square shape.
                     */
                    square= 1,
                    /**
                     * Specifies the end of the line is rounded.
                     */
                    round= 0
                }

                /**
                 * Specifies the corners style of two intersecting lines.
                 * @enum {number}
                 */
                export enum LineJoinStyle{
                    /**
                     * Specifies the corners where the two lines intersect are rounded.
                     */
                    round= 0,
                    /**
                     * Specifies the corners where the two lines intersect are squared off.
                     */
                    miter= 1,
                    /**
                     * Specifies the corners where the two lines intersect are cut off at a 45 degree angle.
                     */
                    bevel= 2
                }

                /**
                 * Specifies the dash style for a line.
                 * @enum {number}
                 */
                export enum PresetLineDashStyle{
                    /**
                     * Line is solid.
                     */
                    solid= 0,
                    /**
                     * Line is made up of square dots.
                     */
                    squareDot= 1,
                    /**
                     * Line consists of dashes only.
                     */
                    dash= 2,
                    /**
                     * Line consists of long dashes.
                     */
                    longDash= 3,
                    /**
                     * Line is a dash-dot pattern.
                     */
                    dashDot= 4,
                    /**
                     * Line is a long dash-dot pattern.
                     */
                    longDashDot= 5,
                    /**
                     * Line is a long dash-dot-dot pattern.
                     */
                    longDashDotDot= 6,
                    /**
                     * Line is a system dash pattern.
                     */
                    sysDash= 7,
                    /**
                     * Line is a system dot pattern.
                     */
                    sysDot= 8,
                    /**
                     * Line is a system dash-dot pattern.
                     */
                    sysDashDot= 9,
                    /**
                     * Line is a dash-dot-dot pattern.
                     */
                    dashDotDot= 10
                }

                /**
                 * Defines radial gradient fill direction of shape.
                 * @enum {number}
                 */
                export enum RadialGradientFillDirection{
                    /**
                     * From Center
                     */
                    fromCenter= 0,
                    /**
                     * From Top Left
                     */
                    fromTopLeft= 1,
                    /**
                     * From Top Right
                     */
                    fromTopRight= 2,
                    /**
                     * From Bottom Left
                     */
                    fromBottomLeft= 3,
                    /**
                     * From Bottom Right
                     */
                    fromBottomRight= 4
                }

                /**
                 * Defines fill type of shape.
                 * @enum {number}
                 */
                export enum ShapeFillType{
                    /**
                     * No Fill
                     */
                    none= 0,
                    /**
                     * Solid Fill
                     */
                    solid= 1
                }

                /**
                 * Specifies shape snap basis.
                 * @enum {number}
                 */
                export enum SnapMode{
                    /**
                     * When resize or move shape, not snap to any refernce position.
                     */
                    none= 0,
                    /**
                     * When resize or move shape, close to the grid line, shape will be snap to grid line.
                     */
                    grid= 1,
                    /**
                     * When resize or move shape, close to other shape boundary, shape will be snap to boundary.
                     */
                    shape= 2
                }

                /**
                 * Defines texture fill aligmnet of shape.
                 * @enum {number}
                 */
                export enum TextureFillAlignment{
                    /**
                     * Top Left
                     */
                    topLeft= 0,
                    /**
                     * Top
                     */
                    top= 1,
                    /**
                     * Top Right
                     */
                    topRight= 2,
                    /**
                     * Left
                     */
                    left= 3,
                    /**
                     * Center
                     */
                    center= 4,
                    /**
                     * Right
                     */
                    right= 5,
                    /**
                     * Bottom Left
                     */
                    bottomLeft= 6,
                    /**
                     * Bottom
                     */
                    bottom= 7,
                    /**
                     * Bottom Right
                     */
                    bottomRight= 8
                }

                /**
                 * Defines texture fill mirrorType of shape.
                 * @enum {number}
                 */
                export enum TextureFillMirrorType{
                    /**
                     * None
                     */
                    none= 0,
                    /**
                     * Horizontal
                     */
                    horizontal= 1,
                    /**
                     * Vertical
                     */
                    vertical= 2,
                    /**
                     * Both
                     */
                    both= 3
                }

                /**
                 * Specifies shape vertical alignment.
                 * @enum {number}
                 */
                export enum VerticalAlign{
                    /**
                     * Top
                     */
                    top= 0,
                    /**
                     * Middle
                     */
                    middle= 1,
                    /**
                     * Bottom
                     */
                    bottom= 2
                }


                export class CameraShape extends GCTYPE.Spread.Sheets.Shapes.ShapeBase{
                    /**
                     * @param {GCTYPE.Spread.Sheets.Worksheet} worksheet The host worksheet of the shape.
                     * @param {string} name The name of the camera shape. If leave blank an unique name will be generated.
                     * @param {string} range The range of the shape generated from, it should be a range formula, like Sheet1!A1:A8.
                     * @param {number} left The <i>x</i> location of the shape.
                     * @param {number} top The <i>y</i> location of the shape.
                     * @param {number} width The width of the camera shape, if leave blank the default value should be same as the original range width.
                     * @param {number} height The height of the camera shape, if leave blank the default value should be same as the original range height.
                     */
                    constructor(worksheet: GCTYPE.Spread.Sheets.Worksheet,  name: string,  range: string,  left?: number,  top?: number,  width?: number,  height?: number);
                    /**
                     * Gets or sets the double-click command of the shape.
                     * @param {string | Function} [value] The behavior when double clicking the camera shape rather than jump to cell range source, if value is a function, it won't be serialized. The default command is 'openUrl'.
                     * @return {string | Function | void} If no value is set, returns the current double-click command settings of the shape.
                     * @example
                     * var shape = sheet.shapes.addCameraShape("shape1", 'Sheet1!A1:A8', 100, 50, 100, 150);
                     * shape.doubleClickCommand(null);
                     */
                    doubleClickCommand(value?: string | Function): string | Function | void;
                    /**
                     * Gets or sets the cell range of the camera shape.
                     * @param {string} value The cell range of the camera shape specified by cell range formula (like Sheet1!A1:A8).
                     * @returns {string | void} If no value is set, returns the cell range of the camera shape.
                     * @example
                     * var shape = sheet.shapes.addCameraShape("shape1", 'Sheet1!A1:A8', 100, 50, 100, 150);
                     * shape.range('Sheet2!A2:B8');
                     */
                    range(value?: string): string | void;
                    /**
                     * Gets or sets the rotated angle of the camera shape (unit in degree).
                     * @param {number | string} value The rotated angle of the camera shape (unit in degree) specified by a number or formula (starts with =) can get a number value.
                     * @returns {number | void} If no value is set, returns the rotated angle of the camera shape (unit in degree).
                     * @example
                     * var shape = sheet.shapes.addCameraShape("shape1", 'Sheet1!A1:A8', 100, 50, 100, 150);
                     * var n = shape.rotate();
                     * shape.rotate(n + 30);
                     */
                    rotate(value?: number | string): number | void;
                    /**
                     * Gets or sets the style of the camera shape.
                     * @param {GCTYPE.Spread.Sheets.Shapes.ShapeStyle} value The shape style.
                     * @return {GCTYPE.Spread.Sheets.Shapes.ShapeStyle | void} If no value is set, returns the current style of the shape.
                     * @example
                     * //This sample sets style for the shape.
                     * var shape = sheet.shapes.addCameraShape("shape1", 'Sheet1!A1:A8', 100, 50, 100, 150);
                     * var oldStyle = shape.style();
                     * oldStyle.fill.color = "red";
                     * oldStyle.fill.transparency = 0.5;
                     * oldStyle.line.color = "green";
                     * oldStyle.line.lineStyle = GCTYPE.Spread.Sheets.Shapes.PresetLineDashStyle.dashDot;
                     * oldStyle.line.width = 5;
                     * oldStyle.line.capType = GCTYPE.Spread.Sheets.Shapes.LineCapStyle.square;
                     * oldStyle.line.joinType = GCTYPE.Spread.Sheets.Shapes.LineJoinStyle.miter;
                     * oldStyle.line.transparency = 0.5;
                     * shape.style(oldStyle);
                     */
                    style(value?: GCTYPE.Spread.Sheets.Shapes.ShapeStyle): any;
                }

                export class ConnectorShape extends GCTYPE.Spread.Sheets.Shapes.ShapeBase{
                    /**
                     * Represents a ConnectorShape.
                     * @param {GCTYPE.Spread.Sheets.Worksheet} worksheet The host sheet of the shape.
                     * @param {string} name The name of shape.
                     * @param {GCTYPE.Spread.Sheets.Shapes.ConnectorType} connectorType The type of the connector shape.
                     * @param {number} beginX The <i>x</i> location of the start point for the connector shape.
                     * @param {number} beginY The <i>y</i> location of the start point for the connector shape.
                     * @param {number} endX  The <i>x</i> location of the end point for the connector shape.
                     * @param {number} endY The <i>y</i> location of the end point for the connector shape.
                     */
                    constructor(worksheet: GCTYPE.Spread.Sheets.Worksheet,  name: string,  connectorType?: GCTYPE.Spread.Sheets.Shapes.ConnectorType,  beginX?: number,  beginY?: number,  endX?: number,  endY?: number);
                    /**
                     * Gets or sets the adjustment values of the connector shape.
                     * @param {number[]} arrayValue The adjustment values in array.
                     * @return {number[] | void} if no value is set, returns the current adjustment values of the shape.
                     * @example
                     * var myConnector = sheet.shapes.addConnector("myConnector", GCTYPE.Spread.Sheets.Shapes.ConnectorType.elbow, 50, 50, 200, 500);
                     * var adjustments = myConnector.adjustments();
                     * console.log(adjustments);
                     * adjustments = [-0.8];
                     * myConnector.adjustments(adjustments);
                     */
                    adjustments(arrayValue?: number[]): any;
                    /**
                     * Gets or sets the end connector info of the connectorShape.
                     * @param {object} connector The end connector info of the connectorShape.
                     * @param {string} connector.name The name of the end connector.
                     * @param {number} connector.index The connect point index of the end connector.
                     * @returns {object} connectorInfo - If no value is set, returns the end connector info of the connectorShape. When the connectorShape has no end connector returns null.
                     * connectorInfo.name {string} The name of the end connector.
                     * connectorInfo.index {number} The connect point index of the end connector.
                     * connectorInfo.shape {GCTYPE.Spread.Sheets.Shapes.Shape} The end connector.
                     * @example
                     * var shape1 = sheet.shapes.add("myShape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.rectangle, 62 * 9, 0, 200, 200);
                     * var shape2 = sheet.shapes.addConnector("myShape", GCTYPE.Spread.Sheets.Shapes.ConnectorType.straight, 220, 120, 300, 120);
                     * var endConnector = shape.endConnector();
                     * shape2.endConnector({name: shape1.name(), index: 2});
                     */
                    endConnector(connector?: GCTYPE.Spread.Sheets.Shapes.IShapeConnector): GCTYPE.Spread.Sheets.Shapes.IShapeConnector;
                    /**
                     * Gets the formula string from the shape by the path.
                     * @param {string} path The path which can accept a formula string, it could be one of "x", "y", "width", "height",
                     * "style.line.color", "style.line.lineStyle", "style.line.width", "style.line.capType", "style.line.joinType", "style.line.compoundType", "style.line.transparency".
                     * @returns {string} Returns the formula string from the shape by the path.
                     * @example
                     * sheet.name("Sheet1");
                     * sheet.setValue(0, 1, "red");
                     * var myConnector = sheet.shapes.addConnector("myConnector", GCTYPE.Spread.Sheets.Shapes.ConnectorType.elbow, 50, 50, 200, 500);
                     * myConnector.setFormula("style.line.color", "=Sheet1!B1");
                     * myConnector.getFormula("style.line.color");//returns "=Sheet1!B1"
                     */
                    getFormula(path: string): string;
                    /**
                     * Sets the formula string to the shape by the path.
                     * @param {string} path The path which can accept a formula string, it could be one of "x", "y", "width", "height",
                     * "style.line.color", "style.line.lineStyle", "style.line.width", "style.line.capType", "style.line.joinType", "style.line.compoundType", "style.line.transparency".
                     * @param {string} formula The formula string.
                     * @example
                     * sheet.name("Sheet1");
                     * sheet.setValue(0, 1, "red");
                     * var myConnector = sheet.shapes.addConnector("myConnector", GCTYPE.Spread.Sheets.Shapes.ConnectorType.elbow, 50, 50, 200, 500);
                     * myConnector.setFormula("style.line.color", "=Sheet1!B1");
                     */
                    setFormula(path: string,  formula: string): void;
                    /**
                     * Gets or sets the start connector info of the connectorShape.
                     * @param {object} connector The start connector info of the connectorShape.
                     * @param {string} connector.name The name of the start connector.
                     * @param {number} connector.index The connect point index of the start connector.
                     * @returns {object} connectorInfo - If no value is set, returns the start connector info of the connectorShape. When the connectorShape has no start connector returns return null.
                     * connectorInfo.name {string} The name of the start connector.
                     * connectorInfo.index {number} The connect point index of the start connector.
                     * connectorInfo.shape {GCTYPE.Spread.Sheets.Shapes.Shape} The start connector.
                     * @example
                     * var shape1 = sheet.shapes.add("myShape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.rectangle, 62 * 9, 0, 200, 200);
                     * var shape2 = sheet.shapes.addConnector("myShape", GCTYPE.Spread.Sheets.Shapes.ConnectorType.straight, 220, 120, 300, 120);
                     * var startConnector = shape.startConnector();
                     * shape2.startConnector({name: shape1.name(), index: 2});
                     */
                    startConnector(connector?: GCTYPE.Spread.Sheets.Shapes.IShapeConnector): GCTYPE.Spread.Sheets.Shapes.IShapeConnector;
                    /**
                     * Gets or sets the style of the connector shape.
                     * @param {GCTYPE.Spread.Sheets.Shapes.ShapeStyle} value The connector shape style.
                     * @return {GCTYPE.Spread.Sheets.Shapes.ShapeStyle | void} If no value is set, returns the current style of the connector shape.
                     *
                     * @example
                     * //This sample sets style for the connector shape.
                     * var shape = sheet.shapes.addConnector("Shape1", GCTYPE.Spread.Sheets.Shapes.ConnectorType.straight, 100, 60, 200, 160);
                     * var oldStyle = shape.style();
                     * oldStyle.line.color = "red";
                     * oldStyle.line.lineStyle = GCTYPE.Spread.Sheets.Shapes.PresetLineDashStyle.dashDot;
                     * oldStyle.line.width = 5;
                     * oldStyle.line.capType = GCTYPE.Spread.Sheets.Shapes.LineCapStyle.square;
                     * oldStyle.line.joinType = GCTYPE.Spread.Sheets.Shapes.LineJoinStyle.miter;
                     * oldStyle.line.compoundType = GCTYPE.Spread.Sheets.Shapes.CompoundType.double;
                     * oldStyle.line.transparency = 0.5;
                     * oldStyle.line.beginArrowheadStyle = GCTYPE.Spread.Sheets.Shapes.ArrowheadStyle.triangle;
                     * oldStyle.line.beginArrowheadWidth = GCTYPE.Spread.Sheets.Shapes.ArrowheadWidth.narrow;
                     * oldStyle.line.beginArrowheadLength = GCTYPE.Spread.Sheets.Shapes.ArrowheadLength.short;
                     * oldStyle.line.endArrowheadStyle = GCTYPE.Spread.Sheets.Shapes.ArrowheadStyle.diamond;
                     * oldStyle.line.endArrowheadWidth = GCTYPE.Spread.Sheets.Shapes.ArrowheadWidth.wide;
                     * oldStyle.line.endArrowheadLength = GCTYPE.Spread.Sheets.Shapes.ArrowheadLength.long;
                     * shape.style(oldStyle);
                     */
                    style(value?: GCTYPE.Spread.Sheets.Shapes.ShapeStyle): GCTYPE.Spread.Sheets.Shapes.ShapeStyle | void;
                    /**
                     * Gets the connector type of the connectorShape.
                     * @returns {GCTYPE.Spread.Sheets.Shapes.ConnectorType} returns the connector type of the shape.
                     * @example
                     * var shape = sheet.shapes.addConnector("myShape", GCTYPE.Spread.Sheets.Shapes.ConnectorType.straight, 220, 120, 300, 120);
                     * var shapeName = shape.type();
                     */
                    type(): GCTYPE.Spread.Sheets.Shapes.ConnectorType;
                }

                export class GroupShape extends GCTYPE.Spread.Sheets.Shapes.ShapeBase{
                    /**
                     * Represents a groupShape.
                     * @class
                     * @param {GCTYPE.Spread.Sheets.Worksheet} worksheet The host sheet of the groupShape.
                     * @param {string} [name] The name of groupShape
                     */
                    constructor(worksheet: GCTYPE.Spread.Sheets.Worksheet,  name?: string);
                    /**
                     * add a shape to groupShape.
                     * @param {GCTYPE.Spread.Sheets.Shapes.Shape} shape The shape which added to groupShape.
                     * @returns {void}
                     */
                    add(value?: GCTYPE.Spread.Sheets.Shapes.Shape): void;
                    /**
                     * get all shapes of group shape.
                     * @returns {Array.<GCTYPE.Spread.Sheets.Shapes.Shape>} all shapes
                     * @example
                     * // This sample shows how to get all shapes in group shape.
                     * var shape1 = sheet.shapes.add("myShape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.rectangle, 62 * 9, 0, 200, 200);
                     * var shape2 = sheet.shapes.add("myShape2", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.rectangle, 20, 20, 200, 200);
                     * var groupShape = sheet.shapes.group([shape1, shape2]);
                     * var shapes = groupShape.all();
                     */
                    all(): GCTYPE.Spread.Sheets.Shapes.Shape[];
                    /**
                     * Get shape of shapes in groupShape by name.
                     * @param {string} name The name of shape in groupShape.
                     * @return {GCTYPE.Spread.Sheets.Shapes.Shape} The Shape instance if the name belongs to a shape of group shapes; otherwise, <c>null</c>.
                     */
                    find(name?: string): GCTYPE.Spread.Sheets.Shapes.Shape;
                    /**
                     * Gets the formula string from the shape by the path.
                     * @param {string} path The path which can accept a formula string, it could be one of "x", "y", "width", "height", "rotate".
                     * @returns {string} Returns the formula string from the shape by the path.
                     * @example
                     * sheet.name("Sheet1");
                     * sheet.setValue(0, 1, 30);
                     * var shape1 = sheet.shapes.add("myShape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.rectangle, 62 * 9, 0, 200, 200);
                     * var shape2 = sheet.shapes.add("myShape2", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.rectangle, 20, 20, 200, 200);
                     * var shape = sheet.shapes.group([shape1, shape2]);
                     * shape.setFormula("rotate", "=Sheet1!B1");
                     * shape.getFormula("rotate");//returns "=Sheet1!B1"
                     */
                    getFormula(path: string): string;
                    /**
                     * remove a shape from groupShape.
                     * @param {GCTYPE.Spread.Sheets.Shapes.Shape} shape The shape which remove to groupShape.
                     * @returns {void}
                     */
                    remove(value?: GCTYPE.Spread.Sheets.Shapes.Shape): void;
                    /**
                     * Gets or sets the rotate of groupShape.
                     * @param {number|string} value The rotate of the groupShape.The unit of measurement is the angle.
                     * @return {number | void} If the parameter 'value' is null or undefined,it will return the rotate of the groupShape.
                     * @example
                     * var shape1 = sheet.shapes.add("myShape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.rectangle, 62 * 9, 0, 200, 200);
                     * var shape2 = sheet.shapes.add("myShape2", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.rectangle, 20, 20, 200, 200);
                     * var shape = sheet.shapes.group([shape1, shape2]);
                     * shape.rotate(60);
                     * var angle = shape.rotate();
                     */
                    rotate(value?: number | string): number | void;
                    /**
                     * Sets the formula string to the shape by the path.
                     * @param {string} path The path which can accept a formula string, it could be one of "x", "y", "width", "height", "rotate".
                     * @param {string} formula The formula string.
                     * @example
                     * sheet.name("Sheet1");
                     * sheet.setValue(0, 1, 30);
                     * var shape1 = sheet.shapes.add("myShape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.rectangle, 62 * 9, 0, 200, 200);
                     * var shape2 = sheet.shapes.add("myShape2", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.rectangle, 20, 20, 200, 200);
                     * var shape = sheet.shapes.group([shape1, shape2]);
                     * shape.setFormula("rotate", "=Sheet1!B1");
                     */
                    setFormula(path: string,  formula: string): void;
                    /**
                     *  Get or set the z-index for a shape in a groupShape.
                     * @param shapeName {string} The name of the shape.
                     * @param zIndex {number} The z-index for the shape. The zIndex should be between 0 to all shapes length(not contains). A shape with greater zIndex is always in front of a shape with a lower zIndex.
                     * @returns {number|void}
                     * @example
                     * //This is a sample shows how to use zIndex in groupShape.
                     * var shape1 = activeSheet.shapes.add("shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                     * var shape2 = activeSheet.shapes.add("shape2", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 150, 50, 100, 150);
                     * var style = shape1.style();
                     * style.fill.color = "red";
                     * shape1.style(style);
                     * var myGroup = activeSheet.shapes.group([shape1, shape2]);
                     * myGroup.zIndex("shape2"); // 1
                     * myGroup.zIndex("shape2", 0);
                     */
                    zIndex(shapeName: string,  zIndex?: number): any;
                }

                export class Shape extends GCTYPE.Spread.Sheets.Shapes.ShapeBase{
                    /**
                     *
                     * @param {GCTYPE.Spread.Sheets.Worksheet} worksheet The host worksheet of the shape.
                     * @param {string} name The name of the shape. If leave blank an unique name will be generated.
                     * @param {GCTYPE.Spread.Sheets.Shapes.AutoShapeType | Object} autoShapeTypeOrModel The type of the shape (for one of the buildin types) or the model for custom shape.
                     * @param {number} left The <i>x</i> location of the shape.
                     * @param {number} top The <i>y</i> location of the shape.
                     * @param {number} width The width of the shape.
                     * @param {number} height The height of the shape.
                     */
                    constructor(worksheet: GCTYPE.Spread.Sheets.Worksheet,  name: string,  autoShapeTypeOrModel: GCTYPE.Spread.Sheets.Shapes.AutoShapeType | GCTYPE.Spread.Sheets.Shapes.IShapeModel,  left?: number,  top?: number,  width?: number,  height?: number);
                    /**
                     * Gets or sets the adjustment values of the shape.
                     * @param {Array.<number>} arrayValue The adjustment values in array.
                     * @return {Array.<number> | void} if no value is set, returns the current adjustment values of the shape.
                     * @example
                     * var blockArc = sheet.shapes.add("", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.blockArc, 100, 60, 200, 160);
                     * var adjustments = blockArc.adjustments();
                     * console.log(adjustments);
                     * adjustments[0] = 150;
                     * adjustments[1] = 15;
                     * adjustments[2] = 0.35;
                     * blockArc.adjustments(adjustments);
                     * blockArc.isSelected(true);
                     */
                    adjustments(arrayValue?: number[]): number[] | void;
                    /**
                     * Gets the formula string from the shape by the path.
                     * @param {string} path The path which can accept a formula string, it could be one of "x", "y", "width", "height", "rotate", "text",
                     * "style.fill.color", "style.fill.transparency",
                     * "style.fill.src", "style.fill.tilePictureAsTexture",
                     * "style.fill.offsetLeft", "style.fill.offsetRight", "style.fill.offsetTop", "style.fill.offsetBottom",
                     * "style.fill.offsetX", "style.fill.offsetY", "style.fill.scaleX", "style.fill.scaleY", "style.fill.alignment", "style.fill.mirrorType",
                     * "style.fill.type", "style.fill.angle", "style.fill.direction",
                     * "style.fill.stops.0.color", "style.fill.stops.0.position", "style.fill.stops.0.transparency", "style.fill.stops.0.brightness",
                     * "style.line.color", "style.line.lineStyle", "style.line.width", "style.line.capType", "style.line.joinType", "style.line.compoundType",  "style.line.transparency",
                     * "style.textEffect.color", "style.textEffect.transparency", "style.textEffect.font",
                     * "style.textFrame.vAlign", "style.textFrame.hAlign".
                     * @returns {string} Returns the formula string from the shape by the path.
                     * @example
                     * sheet.name("Sheet1");
                     * sheet.setValue(0, 1, "This is a rectangle.");
                     * var shape1 = sheet.shapes.add("myShape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.rectangle, 100, 100, 200, 200);
                     * shape1.setFormula("text", "=Sheet1!B1");
                     * shape1.getFormula("text");//returns "=Sheet1!B1"
                     */
                    getFormula(path: string): string;
                    /**
                     * Gets or sets the rotated angle of the shape (unit in degree).
                     * @param {number | string} value The rotated angle of the shape (unit in degree) specified by a number or formula (starts with =) can get a number value.
                     * @returns {number | void} If no value is set, returns the rotated angle of the shape (unit in degree).
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.rotate();
                     * heart.rotate(n + 30);
                     */
                    rotate(value?: number | string): number | void;
                    /**
                     * Sets the formula string to the shape by the path.
                     * @param {string} path The path which can accept a formula string, it could be one of "x", "y", "width", "height", "rotate", "text",
                     * "style.fill.color", "style.fill.transparency",
                     * "style.fill.src", "style.fill.tilePictureAsTexture",
                     * "style.fill.offsetLeft", "style.fill.offsetRight", "style.fill.offsetTop", "style.fill.offsetBottom",
                     * "style.fill.offsetX", "style.fill.offsetY", "style.fill.scaleX", "style.fill.scaleY", "style.fill.alignment", "style.fill.mirrorType",
                     * "style.fill.type", "style.fill.angle", "style.fill.direction",
                     * "style.fill.stops.0.color", "style.fill.stops.0.position", "style.fill.stops.0.transparency", "style.fill.stops.0.brightness",
                     * "style.line.color", "style.line.lineStyle", "style.line.width", "style.line.capType", "style.line.joinType", "style.line.compoundType", "style.line.transparency",
                     * "style.textEffect.color", "style.textEffect.transparency", "style.textEffect.font",
                     * "style.textFrame.vAlign", "style.textFrame.hAlign".
                     * @param {string} formula The formula string.
                     * @example
                     * sheet.name("Sheet1");
                     * sheet.setValue(0, 1, "This is a rectangle.");
                     * var shape1 = sheet.shapes.add("myShape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.rectangle, 100, 100, 200, 200);
                     * shape1.setFormula("text", "=Sheet1!B1");
                     */
                    setFormula(path: string,  formula: string): void;
                    /**
                     * Gets or sets the style of the shape.
                     * @param {GCTYPE.Spread.Sheets.Shapes.ShapeStyle} value The shape style.
                     * @return {GCTYPE.Spread.Sheets.Shapes.ShapeStyle | void} If no value is set, returns the current style of the shape.
                     * @example
                     * //This sample sets style for the shape.
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var oldStyle = heart.style();
                     * oldStyle.fill.color = "red";
                     * oldStyle.fill.transparency = 0.5;
                     * oldStyle.line.color = "green";
                     * oldStyle.line.lineStyle = GCTYPE.Spread.Sheets.Shapes.PresetLineDashStyle.dashDot;
                     * oldStyle.line.width = 5;
                     * oldStyle.line.capType = GCTYPE.Spread.Sheets.Shapes.LineCapStyle.square;
                     * oldStyle.line.joinType = GCTYPE.Spread.Sheets.Shapes.LineJoinStyle.miter;
                     * oldStyle.line.compoundType = GCTYPE.Spread.Sheets.Shapes.CompoundType.double;
                     * oldStyle.line.transparency = 0.5;
                     * oldStyle.textEffect.color = "yellow";
                     * oldStyle.textEffect.transparency = 0.5;
                     * oldStyle.textEffect.font = "20px Arial";
                     * oldStyle.textFrame.vAlign = GCTYPE.Spread.Sheets.VerticalAlign.center;
                     * oldStyle.textFrame.hAlign = GCTYPE.Spread.Sheets.HorizontalAlign.center;
                     * heart.style(oldStyle);
                     * heart.text("Heart");
                     */
                    style(value?: GCTYPE.Spread.Sheets.Shapes.ShapeStyle): any;
                    /**
                     * Gets or sets the text of the shape.
                     * @param {string} value The text of the shape specified by a string or formula (starts with =) can get a string.
                     * @returns {string | void} If no value is set, returns the text of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * heart.text("My Shape");
                     * var s = heart.text();
                     */
                    text(value?: string): any;
                    /**
                     * Gets or sets the type of the shape.
                     * @param {GCTYPE.Spread.Sheets.Shapes.AutoShapeType} value The type of the shape.
                     * @returns {GCTYPE.Spread.Sheets.Shapes.AutoShapeType | void} If no value is set, returns the type of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.type();
                     * heart.type(GCTYPE.Spread.Sheets.Shapes.AutoShapeType.cloud);
                     */
                    type(value?: GCTYPE.Spread.Sheets.Shapes.AutoShapeType): any;
                }

                export class ShapeBase{
                    /**
                     * Represents the base class for Shape, GroupShape and ConnectorShape.
                     * @class
                     */
                    constructor();
                    /**
                     * Gets or sets whether to disable moving the shape.
                     * @param {boolean} value The setting for whether to disable moving the shape.
                     * @returns {boolean | void} If no value is set, returns the setting for whether to disable moving the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var state = heart.allowMove();
                     * heart.allowMove(!state);
                     */
                    allowMove(value?: boolean): any;
                    /**
                     * Gets or sets whether to disable resizing the shape.
                     * @param {boolean} value The setting for whether to disable resizing the shape.
                     * @returns {boolean | void} If no value is set, returns the setting for whether to disable resizing the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var state = heart.allowResize();
                     * heart.allowResize(!state);
                     */
                    allowResize(value?: boolean): any;
                    /**
                     * Gets or sets whether to disable rotating the shape.
                     * @param {boolean} value The setting for whether to disable rotating the shape.
                     * @returns {boolean | void} If no value is set, returns the setting for whether to disable rotating the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var state = heart.allowRotate();
                     * heart.allowRotate(!state);
                     */
                    allowRotate(value?: boolean): any;
                    /**
                     * Gets or sets the alternative text of the shape for screen readers.
                     * @param {string} value The alternative text of the shape.
                     * @returns {string} The alternative text of the shape.
                     */
                    alt(value?: string): string | void;
                    /**
                     * Gets or sets whether this shape is printable.
                     * @param {boolean} value The value that indicates whether this shape is printable.
                     * @returns {boolean | void} If no value is set, returns whether this shape is printable.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var state = heart.canPrint();
                     * heart.canPrint(!state);
                     */
                    canPrint(value?: boolean): any;
                    /**
                     * Gets or sets whether the shape moves when hiding or showing, resizing, or moving rows or columns.
                     * @param {boolean} value The value indicates whether the shape moves when hiding or showing, resizing, or moving rows or columns.
                     * @returns {boolean | void} If no value is set, returns whether this shape dynamically moves.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var state = heart.dynamicMove();
                     * heart.dynamicMove(!state);
                     */
                    dynamicMove(value?: boolean): any;
                    /**
                     * Gets or sets whether the size of the shape changes when hiding or showing, resizing, or moving rows or columns.
                     * @param {boolean} value The value indicates whether the size of the shape changes when hiding or showing, resizing, or moving rows or columns.
                     * @returns {boolean | void} If no value is set, returns whether this shape dynamically changes size.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var state = heart.dynamicSize();
                     * heart.dynamicSize(!state);
                     */
                    dynamicSize(value?: boolean): any;
                    /**
                     * Gets or sets the end column index of the shape position.
                     * @param {number} value The end column index of the shape position.
                     * @returns {number | void} If no value is set, returns the end column index of the shape position.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.endColumn();
                     * heart.endColumn(n + 1);
                     */
                    endColumn(value?: number): any;
                    /**
                     * Gets or sets the offset relative to the end column of the shape.
                     * @param {number} value The offset relative to the end column of the shape.
                     * @returns {number | void} If no value is set, returns the offset relative to the end column of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.endColumnOffset();
                     * heart.endColumnOffset(0);
                     */
                    endColumnOffset(value?: number): any;
                    /**
                     * Gets or sets the end row index of the shape position.
                     * @param {number} value The end row index of the shape position.
                     * @returns {number | void} If no value is set, returns the end row index of the shape position.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.endRow();
                     * heart.endRow(n + 2);
                     */
                    endRow(value?: number): any;
                    /**
                     * Gets or sets the offset relative to the end row of the shape.
                     * @param {number} value The offset relative to the end row of the shape.
                     * @returns {number | void} If no value is set, returns the offset relative to the end row of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.endRowOffset();
                     * heart.endRowOffset(0);
                     */
                    endRowOffset(value?: number): any;
                    /**
                     * Gets the formula string from the shape by the path.
                     * @param {string} path The path which can accept a formula string, it could be one of "x", "y", "width", "height".
                     * @returns {string} Returns the formula string from the shape by the path.
                     * @example
                     * sheet.name("Sheet1");
                     * sheet.setValue(0, 1, 150);
                     * var shape1 = sheet.shapes.add("myShape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.rectangle, 100, 100, 200, 200);
                     * shape1.setFormula("x", "=Sheet1!B1");
                     * shape1.getFormula("x");//returns "=Sheet1!B1"
                     */
                    getFormula(path: string): string;
                    /**
                     * Gets or sets the height of the shape.
                     * @param {number | string} value The height of the shape specified by a number or formula (starts with =) can get a number value.
                     * @returns {number | void} If no value is set, returns the height of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.height();
                     * heart.height(n + 50);
                     */
                    height(value?: number | string): any;
                    /**
                     * Gets or sets the hyperlink of the shape.
                     * @param {object} [value] The hyperlink settings.
                     * @param {string} [value.url] The location that the hyperlink points to.
                     * @param {string} [value.tooltip] The tooltip message which shows when hover over the cell with hyperlink.
                     * @param {number} [value.target] The way that user open the hyperlinked document. Default is 0 (blank).
                     * @param {string | function} [value.command] The behaviour when clicking the hyperlink rather than default opening url.
                     * @return {object | void} If no value is set, returns the current hyperlink settings of the shape.
                     * @example
                     * var shape = sheet.shapes.add("myShape", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.rectangle, 62 * 9, 0, 200, 200);
                     * shape.hyperlink({url: "http://www.grapecity.com", target: 0, tooltip: 'goes to grapecity'});
                     */
                    hyperlink(value?: GCTYPE.Spread.Sheets.IHyperlink): IHyperlink | void;
                    /**
                     * Gets or sets whether this shape is locked.
                     * @param {boolean} value The value that indicates whether this shape is locked.
                     * @returns {boolean | void} If no value is set, returns whether this shape is locked.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var state = heart.isLocked();
                     * heart.isLocked(!state);
                     */
                    isLocked(value?: boolean): any;
                    /**
                     * Gets or sets whether this shape is selected.
                     * @param {boolean} value The value that indicates whether this shape is selected.
                     * @returns {boolean | void} If no value is set, returns whether this shape is selected.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var state = heart.isSelected();
                     * heart.isSelected(!state);
                     */
                    isSelected(value?: boolean): any;
                    /**
                     * Gets or sets whether this shape is visible.
                     * @param {boolean} value The value that indicates whether this shape is visible.
                     * @returns {boolean | void} If no value is set, returns whether this shape is visible.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var state = heart.isVisible();
                     * heart.isVisible(!state);
                     */
                    isVisible(value?: boolean): any;
                    /**
                     * Gets or sets the name of the shape.
                     * @param {string} value The name of the shape.
                     * @returns {string | void} If no value is set, returns the name of the shape.
                     * @example
                     * var shape1 = sheet.shapes.add("myShape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.rectangle, 62 * 9, 0, 200, 200);
                     * var shape2 = sheet.shapes.add("myShape2", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.rectangle, 20, 20, 200, 200);
                     * var shape = sheet.shapes.group([shape1, shape2]);
                     * shape.name("myGroupShape");
                     * var shapeName = shape.name();
                     */
                    name(value?: string): any;
                    /**
                     * Sets the formula string to the shape by the path.
                     * @param {string} path The path which can accept a formula string, it could be one of "x", "y", "width", "height".
                     * @param {string} formula The formula string.
                     * @example
                     * sheet.name("Sheet1");
                     * sheet.setValue(0, 1, 150);
                     * var shape1 = sheet.shapes.add("myShape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.rectangle, 100, 100, 200, 200);
                     * shape1.setFormula("x", "=Sheet1!B1");
                     */
                    setFormula(path: string,  formula: string): void;
                    /**
                     * Gets or sets whether to show handle of shape.
                     * @param {boolean} value The setting for whether to show handle of shape.
                     * @returns {boolean | void} If no value is set, returns the setting for whether to show handle of shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var state = heart.showHandle();
                     * heart.showHandle(!state);
                     */
                    showHandle(value?: boolean): boolean | void;
                    /**
                     * Gets or sets the starting column index of the shape position.
                     * @param {number} value The starting column index of the shape position.
                     * @returns {number | void} If no value is set, returns the starting column index of the shape position.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.startColumn();
                     * heart.startColumn(n + 2);
                     */
                    startColumn(value?: number): any;
                    /**
                     * Gets or sets the offset relative to the start column of the shape.
                     * @param {number} value The offset relative to the start column of the shape.
                     * @returns {number | void} If no value is set, returns the offset relative to the start column of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.startColumnOffset();
                     * heart.startColumnOffset(0);
                     */
                    startColumnOffset(value?: number): any;
                    /**
                     * Gets or sets the starting row index of the shape position.
                     * @param {number} value The starting row index of the shape position.
                     * @returns {number | void} If no value is set, returns the starting row index of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.startRow();
                     * heart.startRow(n + 2);
                     */
                    startRow(value?: number): any;
                    /**
                     * Gets or sets the offset relative to the start row of the shape.
                     * @param {number} value The offset relative to the start row of the shape.
                     * @returns {number | void} If no value is set, returns the offset relative to the start row of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.startRowOffset();
                     * heart.startRowOffset(0);
                     */
                    startRowOffset(value?: number): any;
                    /**
                     * Gets or sets the width of the shape.
                     * @param {number | string} value The width of the shape specified by a number or formula (starts with =) can get a number value.
                     * @returns {number | void} If no value is set, returns the width of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.width();
                     * heart.width(n + 50);
                     */
                    width(value?: number | string): any;
                    /**
                     * Gets or sets the horizontal location of the shape.
                     * @param {number | string} value The horizontal location of the shape specified by a number or formula (starts with =) can get a number value.
                     * @return {number | void} If no value is set, returns the horizontal location of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.x();
                     * heart.x(n + 50);
                     */
                    x(value?: number | string): number | void;
                    /**
                     * Gets or sets the vertical location of the shape.
                     * @param {number | string} value The vertical location of the shape specified by a number or formula (starts with =) can get a number value.
                     * @return {number | void} If no value is set, returns the vertical location of the shape.
                     * @example
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var n = heart.y();
                     * heart.y(n + 50);
                     */
                    y(value?: number | string): any;
                }

                export class ShapeCollection{
                    /**
                     * Represents a shape manager that managers all shapes in a sheet.
                     * @class
                     * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The worksheet.
                     */
                    constructor(sheet: GCTYPE.Spread.Sheets.Worksheet);
                    /**
                     * Add a new shape to shape collection
                     * @param {string} name The name of the shape. If leave blank an unique name will be generated.
                     * @param {GCTYPE.Spread.Sheets.Shapes.AutoShapeType | Object} autoShapeTypeOrModel The type of the shape (for one of the buildin types) or the model for custom shape.
                     * @param {number} left The <i>x</i> location of the shape.
                     * @param {number} top The <i>y</i> location of the shape.
                     * @param {number} width The width of the shape.
                     * @param {number} height The height of the shape.
                     * @return {GCTYPE.Spread.Sheets.Shapes.Shape} The shape that has been added to the sheet.
                     * @example
                     * // This example shows how to add a new shape
                     * var shape = activeSheet.shapes.add("shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                     */
                    add(name: string,  autoShapeTypeOrModel: GCTYPE.Spread.Sheets.Shapes.AutoShapeType | GCTYPE.Spread.Sheets.Shapes.IShapeModel,  left?: number,  top?: number,  width?: number,  height?: number): GCTYPE.Spread.Sheets.Shapes.Shape;
                    /**
                     * Add a new camera shape to shape collection
                     * @param {string} name The name of the camera shape. If leave blank an unique name will be generated.
                     * @param {string} range The range of the shape generated from, it should be a range formula, like Sheet1!A1:A8.
                     * @param {number} [left] The <i>x</i> location of the camera shape, if leave blank the default value will be 0.
                     * @param {number} [top] The <i>y</i> location of the camera shape, if leave blank the default value will be 0.
                     * @param {number} [width] The width of the camera shape, if leave blank the default value should be same as the original range width.
                     * @param {number} [height] The height of the camera shape, if leave blank the default value should be same as the original range height.
                     * @return {GCTYPE.Spread.Sheets.Shapes.CameraShape} The shape that has been added to the sheet.
                     * @example
                     * // This example shows how to add a new camera shape
                     * var shape = activeSheet.shapes.addCameraShape("camera shape 1", 'Sheet1!A1:A8', 100, 50, 100, 150);
                     */
                    addCameraShape(name: string,  range: string,  left?: number,  top?: number,  width?: number,  height?: number): GCTYPE.Spread.Sheets.Shapes.CameraShape;
                    /**
                     * Add a Connector Shape to shape collection
                     * @param {string} name The name of the shape. If leave blank an unique name will be generated.
                     * @param {GCTYPE.Spread.Sheets.Shapes.ConnectorType} connectorType The type of the connector.
                     * @param {number} beginX The <i>x</i> location of the start point for the connector shape.
                     * @param {number} beginY The <i>y</i> location of the start point for the connector shape.
                     * @param {number} endX  The <i>x</i> location of the end point for the connector shape.
                     * @param {number} endY The <i>y</i> location of the end point for the connector shape.
                     * @return {GCTYPE.Spread.Sheets.Shapes.ConnectorShape} The connector shape that has been added to the sheet.
                     * @example
                     * //This example shows how to add a connector shape
                     * var shape1 = activeSheet.shapes.addConnector("shape1", GCTYPE.Spread.Sheets.Shapes.ConnectorType.elbow, 200, 50, 300, 200);
                     */
                    addConnector(name: string,  connectorType: GCTYPE.Spread.Sheets.Shapes.ConnectorType,  beginX?: number,  beginY?: number,  endX?: number,  endY?: number): GCTYPE.Spread.Sheets.Shapes.ConnectorShape;
                    /**
                     * get all shapes
                     * @returns {Array.<GCTYPE.Spread.Sheets.Shapes.Shape>} all shapes
                     * @example
                     * // This sample shows how to get all shapes in shape collection
                     * activeSheet.shapes.add("shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                     * activeSheet.shapes.addConnector("shape2", GCTYPE.Spread.Sheets.Shapes.ConnectorType.elbow, 200, 50, 300, 200);
                     * var shapes = activeSheet.shapes.all();
                     */
                    all(): GCTYPE.Spread.Sheets.Shapes.Shape[];
                    /**
                     * clear all shapes
                     * @example
                     * //This example shows how to clear all shapes in shape collection
                     * activeSheet.shapes.add("shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                     * activeSheet.shapes.addConnector("shape2", GCTYPE.Spread.Sheets.Shapes.ConnectorType.elbow, 200, 50, 300, 200);
                     * activeSheet.shapes.clear();
                     */
                    clear(): void;
                    /**
                     * Get a shape with name
                     * @param {string} name The name of the shape.
                     * @returns {GCTYPE.Spread.Sheets.Shapes.Shape} The Shape
                     * @example
                     * //This example shows how to get a shape with name.
                     * activeSheet.shapes.add("shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                     * activeSheet.shapes.get("shape1");
                     */
                    get(name: string): GCTYPE.Spread.Sheets.Shapes.Shape;
                    /**
                     * Groups the Shapes.
                     * @param {Array.<GCTYPE.Spread.Sheets.Shapes.Shape>} shapes The shapes to group.
                     * @returns {GCTYPE.Spread.Sheets.Shapes.Shape} The Shape group.
                     * @example
                     * //This sample shows how to group some shapes
                     * var shape1 = activeSheet.shapes.add("shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                     * var shape2 = activeSheet.shapes.addConnector("shape2", GCTYPE.Spread.Sheets.Shapes.ConnectorType.elbow, 200, 50, 300, 200);
                     * var shapes = [shape1, shape2];
                     * var groupShape = activeSheet.shapes.group(shapes)
                     */
                    group(shapes: GCTYPE.Spread.Sheets.Shapes.Shape[]): GCTYPE.Spread.Sheets.Shapes.GroupShape;
                    /**
                     * remove a shape
                     * @param {string} name The name of the shape.
                     * @example
                     * //This example shows how to remove a shape
                     * activeSheet.shapes.add("shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                     * activeSheet.shapes.remove("shape1");
                     */
                    remove(name: string): void;
                    /**
                     * Gets or sets whether to align shape to grid line or the other shapes.
                     * @param {GCTYPE.Spread.Sheets.SnapMode} value Whether to snap shapes to the grid line or other shapes.
                     * @returns {GCTYPE.Spread.Sheets.SnapMode | void} If no value is set, returns which snapMode use.
                     * @example
                     * sheet1.shapes.SnapMode(GCTYPE.Spread.Sheets.Shapes.SnapMode.grid);
                     * var snapMode = sheet1.shapes.snapMode();
                     */
                    snapMode(value?: GCTYPE.Spread.Sheets.Shapes.SnapMode): GCTYPE.Spread.Sheets.Shapes.SnapMode | void;
                    /**
                     * Separate a groupShape to some shapes
                     * @param {GCTYPE.Spread.Sheets.Shapes.GroupShape} groupShape The groupShape to separate.
                     * @example
                     * //This sample shows how to separate a groupShape to some shapes
                     * var shape1 = activeSheet.shapes.add("shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                     * var shape2 = activeSheet.shapes.addConnector("shape2", GCTYPE.Spread.Sheets.Shapes.ConnectorType.elbow, 200, 50, 300, 200);
                     * var shapes = [shape1, shape2];
                     * var groupShape = activeSheet.shapes.group(shapes);
                     * activeSheet.shapes.ungroup(groupShape);
                     */
                    ungroup(groupShape: GCTYPE.Spread.Sheets.Shapes.GroupShape): void;
                    /**
                     *  Get or set the z-index for a shape
                     * @param shapeName {string} The name of the shape
                     * @param zIndex {number} The z-index for the shape. The zIndex should be between 0 to all shapes length(not contains). A shape with greater zIndex is always in front of a shape with a lower zIndex.
                     * @example
                     * //This is a sample shows how to use zIndex.
                     * var shape1 = activeSheet.shapes.add("shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 50, 100, 150);
                     * var style = shape1.style();
                     * style.fill.color = "red";
                     * shape1.style(style);
                     * var shape2 = activeSheet.shapes.addConnector("shape2", GCTYPE.Spread.Sheets.Shapes.ConnectorType.elbow, 100, 50, 200, 200);
                     * activeSheet.shapes.zIndex("shape2"); // 1
                     * activeSheet.shapes.zIndex("shape2", 0);
                     */
                    zIndex(shapeName: string,  zIndex: number): number;
                }

                export class ShapeStyle{
                    /**
                     * Represents a shape style.
                     * @param {Object} style The style is an object that has same structure with a ShapeStyle instance, it is optional.
                     * @class
                     */
                    constructor(style?: Object);
                    /**
                     * Indicates the fill options.
                     * @property {GCTYPE.Spread.Sheets.Shapes.ShapeFillType} [type] - The fill type, it is ShapeFillType enum or formula(starts with =).
                     * @property {string} [color] - The background color, it is a color string or formula(starts with =).
                     * @property {number | string} [transparency] - The background color transparency, it is a number that is between 0 and 1 or formula(starts with =).
                     * @type {Object}
                     * @example
                     * //This sample sets background color and background color transparency for the shape.
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var oldStyle = heart.style();
                     * oldStyle.fill = {
                     *     type: GCTYPE.Spread.Sheets.Shapes.ShapeFillType.solid,
                     *     color: "red",
                     *     transparency: 0.5
                     * };
                     * heart.style(oldStyle);
                     *
                     * //This sample sets gradient background for the shape.
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var oldStyle = heart.style();
                     * oldStyle.fill = {
                     *     type: GCTYPE.Spread.Sheets.Shapes.GradientFillType.linear,
                     *     angle: 45,
                     *     stops: [
                     *         { color: 'blue', position: 0},
                     *         { color: 'pink', position: 1}
                     *     ]
                     * };
                     * heart.style(oldStyle);
                     *
                     * //This sample sets picture background for the shape.
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var oldStyle = heart.style();
                     * oldStyle.fill = { src: "data:image/svg+xml;base64....." };
                     * heart.style(oldStyle);
                     *
                     * //This sample sets background color and background color transparency with formula for the shape.
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * sheet.setValue(0, 1, 1);
                     * sheet.setValue(1, 1, "red");
                     * sheet.setValue(2, 1, 0.5);
                     * var oldStyle = heart.style();
                     * oldStyle.fill = {
                     *     type: "=Sheet1!B1",
                     *     color: "=Sheet1!B2",
                     *     transparency: "=Sheet1!B3"
                     * };
                     * heart.style(oldStyle);
                     *
                     * //This sample sets gradient background with formula for the shape.
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var oldStyle = heart.style();
                     * oldStyle.fill = {
                     *     type: "=Sheet1!A1",
                     *     angle: "=Sheet1!B1",
                     *     stops: [
                     *         { color: "=Sheet1!A2", position: "=Sheet1!B2"},
                     *         { color: "=Sheet1!A3", position: "=Sheet1!B3"}
                     *     ]
                     * };
                     * heart.style(oldStyle);
                     */
                    fill: GCTYPE.Spread.Sheets.Shapes.IShapeFill | GCTYPE.Spread.Sheets.Shapes.IShapeGradientFill | GCTYPE.Spread.Sheets.Shapes.IShapePictureFill | GCTYPE.Spread.Sheets.Shapes.IShapeTextureFill;
                    /**
                     * Indicates the line options.
                     * @property {string} [color] - The line color, it is a color string or formula(starts with =).
                     * @property {GCTYPE.Spread.Sheets.Shapes.PresetLineDashStyle | string} [lineStyle] - The line style, it is PresetLineDashStyle enum or formula(starts with =).
                     * @property {number | string} [width] - The line width, it is a number or formula(starts with =).
                     * @property {GCTYPE.Spread.Sheets.Shapes.LineCapStyle | string} [capType] - The line cap type, it is LineCapStyle enum or formula(starts with =).
                     * @property {GCTYPE.Spread.Sheets.Shapes.LineJoinStyle | string} [joinType] - The line join type, it is LineJoinStyle enum or formula(starts with =).
                     * @property {GCTYPE.Spread.Sheets.Shapes.CompoundType | string} [compoundType] - The line compound type, it is CompoundType enum or formula(starts with =).
                     * @property {number | string} [transparency] - The line color transparency, it is a number that is between 0 and 1 or formula(starts with =).
                     * @property {GCTYPE.Spread.Sheets.Shapes.ArrowheadStyle} [beginArrowheadStyle] - The begin arrowhead style, it is ArrowheadStyle enum.
                     * @property {GCTYPE.Spread.Sheets.Shapes.ArrowheadWidth} [beginArrowheadWidth] - The begin arrowhead width, it is ArrowheadWidth enum.
                     * @property {GCTYPE.Spread.Sheets.Shapes.ArrowheadLength} [beginArrowheadLength] - The begin arrowhead length, it is ArrowheadLength enum.
                     * @property {GCTYPE.Spread.Sheets.Shapes.ArrowheadStyle} [endArrowheadStyle] - The end arrowhead style, it is ArrowheadStyle enum.
                     * @property {GCTYPE.Spread.Sheets.Shapes.ArrowheadWidth} [endArrowheadWidth] - The end arrowhead width, it is ArrowheadWidth enum.
                     * @property {GCTYPE.Spread.Sheets.Shapes.ArrowheadLength} [endArrowheadLength] - The end arrowhead length, it is ArrowheadLength enum.
                     * @type {Object}
                     * @example
                     * //This sample sets line color, line style, line width, cap type, join type and line color transparency for the shape.
                     * var shape = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * //var shape = sheet.shapes.addConnector("Shape1", GCTYPE.Spread.Sheets.Shapes.ConnectorType.straight, 100, 60, 200, 160);
                     * var oldStyle = shape.style();
                     * oldStyle.line.color = "red";
                     * oldStyle.line.lineStyle = GCTYPE.Spread.Sheets.Shapes.PresetLineDashStyle.dashDot;
                     * oldStyle.line.width = 5;
                     * oldStyle.line.capType = GCTYPE.Spread.Sheets.Shapes.LineCapStyle.square;
                     * oldStyle.line.joinType = GCTYPE.Spread.Sheets.Shapes.LineJoinStyle.miter;
                     * oldStyle.line.compoundType = GCTYPE.Spread.Sheets.Shapes.CompoundType.double;
                     * oldStyle.line.transparency = 0.5;
                     * shape.style(oldStyle);
                     *
                     * //This sample sets line color, line style, line width, cap type, join type and line color transparency with formula for the shape.
                     * var shape = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * //var shape = sheet.shapes.addConnector("Shape1", GCTYPE.Spread.Sheets.Shapes.ConnectorType.straight, 100, 60, 200, 160);
                     * sheet.setValue(0, 1, "red");
                     * sheet.setValue(1, 1, 4);
                     * sheet.setValue(2, 1, 5);
                     * sheet.setValue(3, 1, 1);
                     * sheet.setValue(4, 1, 1);
                     * sheet.setValue(5, 1, 0.5);
                     * var oldStyle = shape.style();
                     * oldStyle.line.color = "=Sheet1!B1";
                     * oldStyle.line.lineStyle = "=Sheet1!B2";
                     * oldStyle.line.width = "=Sheet1!B3";
                     * oldStyle.line.capType = "=Sheet1!B4";
                     * oldStyle.line.joinType = "=Sheet1!B5";
                     * oldStyle.line.transparency = "=Sheet1!B6";
                     * oldStyle.line.compoundType = "=Sheet1!B7";
                     * shape.style(oldStyle);
                     *
                     * //This sample sets line's begin arrowhead style, width, length and end arrowhead style, width, height for the shape.
                     * var shape = sheet.shapes.addConnector("Shape1", GCTYPE.Spread.Sheets.Shapes.ConnectorType.straight, 100, 60, 200, 160);
                     * var oldStyle = shape.style();
                     * oldStyle.line.beginArrowheadStyle = GCTYPE.Spread.Sheets.Shapes.ArrowheadStyle.triangle;
                     * oldStyle.line.beginArrowheadWidth = GCTYPE.Spread.Sheets.Shapes.ArrowheadWidth.narrow;
                     * oldStyle.line.beginArrowheadLength = GCTYPE.Spread.Sheets.Shapes.ArrowheadLength.short;
                     * oldStyle.line.endArrowheadStyle = GCTYPE.Spread.Sheets.Shapes.ArrowheadStyle.diamond;
                     * oldStyle.line.endArrowheadWidth = GCTYPE.Spread.Sheets.Shapes.ArrowheadWidth.wide;
                     * oldStyle.line.endArrowheadLength = GCTYPE.Spread.Sheets.Shapes.ArrowheadLength.long;
                     * shape.style(oldStyle);
                     */
                    line: GCTYPE.Spread.Sheets.Shapes.IShapeLine;
                    /**
                     * Indicates the text effect options.
                     * @property {string} [color] - The font color, it is a color string or formula(starts with =).
                     * @property {number | string} [transparency] - The font color transparency, it is a number that is between 0 and 1 or formula(starts with =).
                     * @property {string} [font] - The font, it is a font string or formula(starts with =).
                     * @type {Object}
                     * @example
                     * //This sample sets the font color, font color transparency and font for the shape.
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var oldStyle = heart.style();
                     * oldStyle.textEffect.color = "red";
                     * oldStyle.textEffect.transparency = 0.5;
                     * oldStyle.textEffect.font = "20px Arial";
                     * heart.style(oldStyle);
                     * heart.text("Heart");
                     *
                     * //This sample sets the font color, font color transparency and font with formula for the shape.
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * sheet.setValue(0, 1, "red");
                     * sheet.setValue(1, 1, 0.5);
                     * sheet.setValue(2, 1, "20px Arial");
                     * var oldStyle = heart.style();
                     * oldStyle.textEffect.color = "=Sheet1!B1";
                     * oldStyle.textEffect.transparency = "=Sheet1!B2";
                     * oldStyle.textEffect.font = "=Sheet1!B3";
                     * heart.style(oldStyle);
                     * heart.text("Heart");
                     */
                    textEffect: GCTYPE.Spread.Sheets.Shapes.IShapeTextEffect;
                    /**
                     * Indicates the text frame options.
                     * @property {GCTYPE.Spread.Sheets.VerticalAlign | string} [vAlign] - The text vertical alignment, it is VerticalAlign enum or formula(starts with =).
                     * @property {GCTYPE.Spread.Sheets.HorizontalAlign | string} [hAlign] - The text horizontal alignment, it is HorizontalAlign enum or formula(starts with =).
                     * @type {Object}
                     * @example
                     * //This sample sets the text horizontal alignment and vertical alignment for the shape.
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * var oldStyle = heart.style();
                     * oldStyle.textFrame.vAlign = GCTYPE.Spread.Sheets.VerticalAlign.center;
                     * oldStyle.textFrame.hAlign = GCTYPE.Spread.Sheets.HorizontalAlign.center;
                     * heart.style(oldStyle);
                     * heart.text("Heart");
                     *
                     * //This sample sets the text horizontal alignment and vertical alignment with formula for the shape.
                     * var heart = sheet.shapes.add("Shape1", GCTYPE.Spread.Sheets.Shapes.AutoShapeType.heart, 100, 60, 200, 160);
                     * sheet.setValue(0, 1, 1);
                     * sheet.setValue(1, 1, 1);
                     * var oldStyle = heart.style();
                     * oldStyle.textFrame.vAlign = "=Sheet1!B1";
                     * oldStyle.textFrame.hAlign = "=Sheet1!B2";
                     * heart.style(oldStyle);
                     * heart.text("Heart");
                     */
                    textFrame: GCTYPE.Spread.Sheets.Shapes.IShapeTextFrame;
                }
            }

            module Slicers{

                export class ItemSlicer{
                    /**
                     * Represents an item slicer.
                     * @param {string} name The name of the item slicer.
                     * @param {GCTYPE.Spread.Slicers.GeneralSlicerData} slicerData An instance of the GeneralSlicerData or TableSlicerData.
                     * @param {string} columnName The column name that relates to the item slicer.
                     * @class GCTYPE.Spread.Sheets.Slicers.ItemSlicer
                     * @example
                     * //This example creates an item slicer.
                     * //create table
                     * var dataSource = [
                     *     { Name: "Bob", City: "NewYork", Birthday: "1968/6/8" },
                     *     { Name: "Betty", City: "NewYork", Birthday: "1972/7/3" },
                     *     { Name: "Alice", City: "Washington", Birthday: "2012/2/15" },
                     * ];
                     * var table = activeSheet.tables.addFromDataSource("table1", 1, 1, dataSource);
                     * var slicerData = new GCTYPE.Spread.Sheets.Slicers.TableSlicerData(table)
                     * //Set slicer data to item slicer.
                     * var slicer = new GCTYPE.Spread.Sheets.Slicers.ItemSlicer("slicer", slicerData, "Name");
                     * //Add the item slicer to the dom tree.
                     * //The "slicerHost" is the div you want to add the slicer's dom to.
                     * $("#slicerHost").append(slicer.getDOMElement());
                     */
                    constructor(name: string,  slicerData: GCTYPE.Spread.Slicers.GeneralSlicerData,  columnName: string);
                    /**
                     * Gets or sets the caption name of the item slicer.
                     * @param {string} [value] The caption name of the item slicer.
                     * @returns {string | GCTYPE.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns the caption name of the item slicer; otherwise, returns the item slicer.
                     */
                    captionName(value?: string): any;
                    /**
                     * Gets or sets the column count of the item slicer.
                     * @param {number} [value] The column count of the item slicer.
                     * @returns {number | GCTYPE.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns the column count of the item slicer; otherwise, returns the item slicer.
                     */
                    columnCount(value?: number): any;
                    /**
                     * Gets the dom element of the item slicer.
                     * @returns {HTMLElement} The dom element of the item slicer.
                     */
                    getDOMElement(): HTMLElement;
                    /**
                     * Gets or sets the height of the item slicer.
                     * @param {number} [value] The height of the item slicer.
                     * @returns {number | GCTYPE.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns the height of the item slicer; otherwise, returns the item slicer.
                     */
                    height(value?: number): any;
                    /**
                     * Gets or sets the item height of the item slicer.
                     * @param {number} [value] The item height of the item slicer.
                     * @returns {number | GCTYPE.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns the item height of the item slicer; otherwise, returns the item slicer.
                     */
                    itemHeight(value?: number): any;
                    /**
                     * Gets or sets the name of the item slicer.
                     * @param {string} [value] The name of the item slicer.
                     * @returns {string | GCTYPE.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns the name of the item slicer; otherwise, returns the item slicer.
                     */
                    name(value?: string): any;
                    /**
                     * Gets or sets whether to show the header of the item slicer.
                     * @param {boolean} [value] The show header setting of the item slicer.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns whether to show the header of the item slicer; otherwise, returns the item slicer.
                     */
                    showHeader(value?: boolean): any;
                    /**
                     * Gets or sets whether to show the no data items of the item slicer.
                     * @param {boolean} [value] The show no data items setting of the slicer.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns whether to show the no data items of the item slicer; otherwise, returns the item slicer.
                     */
                    showNoDataItems(value?: boolean): any;
                    /**
                     * Gets or sets whether to show the no data items last.
                     * @param {boolean} [value] The show no data items in last setting of the slicer.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns whether to show the no data items last; otherwise, returns the item slicer.
                     */
                    showNoDataItemsInLast(value?: boolean): any;
                    /**
                     * Gets or sets the sort state of the item slicer.
                     * @param {GCTYPE.Spread.Sheets.SortState} [value] The sort state of the item slicer.
                     * @returns {GCTYPE.Spread.Sheets.SortState | GCTYPE.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns the sort state of the item slicer; otherwise, returns the item slicer.
                     */
                    sortState(value?: GCTYPE.Spread.Sheets.SortState): any;
                    /**
                     * Gets or sets the style of the item slicer.
                     * @param {Object} value The style of the item slicer.
                     * @returns {Object | GCTYPE.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns The style of the item slicer; otherwise, returns the item slicer.
                     * @example
                     * The style is json data, its json schema is as follows:
                     * {
                     *      "$schema" : "http://json-schema.org/draft-04/schema#",
                     *      "title" : "style",
                     *      "type" : "object",
                     *      "properties" : {
                     *          "wholeSlicerStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          },
                     *          "headerStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          },
                     *          "selectedItemWithDataStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          },
                     *          "selectedItemWithNoDataStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          },
                     *          "unSelectedItemWithDataStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          },
                     *          "unSelectedItemWithNoDataStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          },
                     *          "hoveredSelectedItemWithDataStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          },
                     *          "hoveredSelectedItemWithNoDataStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          },
                     *          "hoveredUnSelectedItemWithDataStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          },
                     *          "hoveredUnSelectedItemWithNoDataStyle" : {
                     *              "$ref" : "#/definitions/StyleInfo"
                     *          }
                     *      },
                     *      "definitions" : {
                     *          "StyleInfo" : {
                     *              "type" : "object",
                     *              "properties" : {
                     *                      "backColor" : {
                     *                              "type" : "string"
                     *                      },
                     *                      "foreColor" : {
                     *                              "type" : "string"
                     *                      },
                     *                      "font" : {
                     *                              "type" : "string"
                     *                      },
                     *                      "borderLeft" : {
                     *                              "$ref" : "#/definitions/SlicerBorder"
                     *                      },
                     *                      "borderTop" : {
                     *                              "$ref" : "#/definitions/SlicerBorder"
                     *                      },
                     *                      "borderRight" : {
                     *                              "$ref" : "#/definitions/SlicerBorder"
                     *                      },
                     *                      "borderBottom" : {
                     *                              "$ref" : "#/definitions/SlicerBorder"
                     *                      },
                     *                  "textDecoration":{
                     *                      "type" : "string"
                     *                  }
                     *              }
                     *          },
                     *          "SlicerBorder":{
                     *              "type":"object",
                     *              "properties":{
                     *                  "borderWidth":{
                     *                          "type":"number"
                     *                  },
                     *                  "borderStyle":{
                     *                          "type":"string"
                     *                  },
                     *                  "borderColor":{
                     *                          "type":"string"
                     *                  }
                     *           }
                     *          }
                     *      }
                     *  }
                     */
                    style(value?: any): any;
                    /**
                     * Gets or sets whether to visually distinguish the items with no data.
                     * @param {boolean} [value] The setting for items with no data.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns whether to visually distinguish the items with no data; otherwise, returns the item slicer.
                     */
                    visuallyNoDataItems(value?: boolean): any;
                    /**
                     * Gets or sets the width of the item slicer.
                     * @param {number} [value] The width of the item slicer.
                     * @returns {number | GCTYPE.Spread.Sheets.Slicers.ItemSlicer} If no value is set, returns the width of the item slicer; otherwise, returns the item slicer.
                     */
                    width(value?: number): any;
                }

                export class Slicer extends GCTYPE.Spread.Sheets.FloatingObjects.FloatingObject{
                    /**
                     * Represents a slicer.
                     * @class GCTYPE.Spread.Sheets.Slicer
                     * @param {string} name The slicer name.
                     * @param {GCTYPE.Spread.Sheets.Tables.Table} table The table that relates to the slicer.
                     * @param {string} columnName The name of the table's column.
                     */
                    constructor(name: string,  table: GCTYPE.Spread.Sheets.Tables.Table,  columnName: string);
                    /**
                     * Gets or sets the caption name of the slicer.
                     * @param {string} [value] The caption name of the slicer.
                     * @returns {string | GCTYPE.Spread.Sheets.Slicers.Slicer} If no value is set, returns the caption name of the slicer; otherwise, returns the slicer.
                     * @example
                     * //This example uses the captionName method.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //slicer style
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.light4();
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.captionName("S1");
                     * slicer.style(style1);
                     */
                    captionName(value?: string): any;
                    /**
                     * Gets or sets the column count for the slicer.
                     * @param {number} [value] The column count of the slicer.
                     * @returns {number | GCTYPE.Spread.Sheets.Slicers.Slicer} If no value is set, returns the column count for the slicer; otherwise, returns the slicer.
                     */
                    columnCount(value?: number): any;
                    /**
                     * Gets or sets whether to disable resizing and moving the slicer.
                     * @param {boolean} [value] The setting for whether to disable resizing and moving the slicer.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Slicers.Slicer} If no value is set, returns whether to disable resizing and moving the slicer; otherwise, returns the slicer.
                     * @example
                     * //This example prevents moving or resizing the slicer.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //slicer style
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.light4();
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Height");
                     * //change the slicer properties.
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.disableResizingAndMoving(true);
                     * slicer.style(style1);
                     */
                    disableResizingAndMoving(value?: boolean): any;
                    /**
                     * Gets or sets the item height for the slicer.
                     * @param {number} [value] The item height of the slicer.
                     * @returns {number | GCTYPE.Spread.Sheets.Slicers.Slicer} If no value is set, returns the item height for the slicer; otherwise, returns the slicer.
                     */
                    itemHeight(value?: number): any;
                    /**
                     * Gets or sets the name of the slicer.
                     * @param {string} [value] The name of the slicer.
                     * @returns {string | GCTYPE.Spread.Sheets.Slicers.Slicer} If no value is set, returns the name of the slicer; otherwise, returns the slicer.
                     */
                    name(value?: string): any;
                    /**
                     * Gets or sets whether to show the slicer header.
                     * @param {boolean} [value] The show header setting of the slicer.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Slicers.Slicer} If no value is set, returns whether to show the slicer header; otherwise, returns the slicer.
                     * @example
                     * //This example hides the slicer header.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //slicer style
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.light4();
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Height");
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.showHeader(false);
                     * slicer.style(style1);
                     * //add the slicer to the sheet
                     * activeSheet.slicers.add(slicer);
                     */
                    showHeader(value?: boolean): any;
                    /**
                     * Gets or sets whether to show the no data items of the slicer.
                     * @param {boolean} [value] The show no data items setting of the slicer.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Slicers.Slicer} If no value is set, returns whether to show the no data items of the slicer; otherwise, returns the slicer.
                     */
                    showNoDataItems(value?: boolean): any;
                    /**
                     * Gets or sets whether to show the no data items last.
                     * @param {boolean} [value] The show no data items last setting of the slicer.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Slicers.Slicer} If no value is set, returns whether to show the no data items last; otherwise, returns the slicer.
                     */
                    showNoDataItemsInLast(value?: boolean): any;
                    /**
                     * Gets or sets the sort state of the slicer.
                     * @param {GCTYPE.Spread.Sheets.SortState} [value] The sort state of the slicer.
                     * @returns {GCTYPE.Spread.Sheets.SortState | GCTYPE.Spread.Sheets.Slicers.Slicer} If no value is set, returns the sort state of the slicer; otherwise, returns the slicer.
                     * @example
                     * //This example sets the sort order of the items in the slicer.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * // slicer style
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.light4();
                     * //add a slicer to the sheet and return the slicer instance
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Height");
                     * //set slicer properties
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.sortState(GCTYPE.Spread.Sheets.SortState.descending);
                     * slicer.style(style1);
                     */
                    sortState(value?: GCTYPE.Spread.Sheets.SortState): any;
                    /**
                     * Gets or sets the style of the slicer.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerStyle} value The style of the slicer.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyle | GCTYPE.Spread.Sheets.Slicers.Slicer} If no value is set, returns The style of the slicer; otherwise, returns the slicer.
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * // slicer style
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.light4();
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     * //change the slicer properties.
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    style(value?: GCTYPE.Spread.Sheets.Slicers.SlicerStyle): any;
                    /**
                     * Gets or sets whether to visually distinguish the items with no data.
                     * @param {boolean} [value] The setting for items with no data.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Slicers.Slicer} If no value is set, returns whether to visually distinguish the items with no data; otherwise, returns the slicer.
                     */
                    visuallyNoDataItems(value?: boolean): any;
                }

                export class SlicerBorder{
                    /**
                     * Represents the slicer border.
                     * @param {number} borderWidth The border width.
                     * @param {string} borderStyle The border style.
                     * @param {string} borderColor The border color.
                     * @class
                     * @example
                     * //This example sets a border style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //style info
                     * var hstyle = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    constructor(borderWidth: number,  borderStyle: string,  borderColor: string);
                    /**
                     * Gets or sets the border color.
                     * @param {string} [value] The border color.
                     * @returns {string | GCTYPE.Spread.Sheets.Slicers.SlicerBorder}  If no value is set, returns the border color; otherwise, returns the slicer border.
                     */
                    borderColor(value?: string): any;
                    /**
                     * Gets or sets the border style.
                     * @param {string} [value] The border style.
                     * @returns {string | GCTYPE.Spread.Sheets.Slicers.SlicerBorder}  If no value is set, returns the border style; otherwise, returns the slicer border.
                     */
                    borderStyle(value?: string): any;
                    /**
                     * Gets or sets the border width.
                     * @param {number} [value] The border width.
                     * @returns {number | GCTYPE.Spread.Sheets.Slicers.SlicerBorder}  If no value is set, returns the border width; otherwise, returns the slicer border.
                     */
                    borderWidth(value?: number): any;
                }

                export class SlicerCollection{
                    /**
                     * Represents a slicer manager that managers all slicers in a sheet.
                     * @class
                     * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The worksheet.
                     */
                    constructor(sheet: GCTYPE.Spread.Sheets.Worksheet);
                    /**
                     * Adds a slicer to the sheet.
                     * @param {string} name The name of the slicer.
                     * @param {string} tableName The name of the table that relates to the slicer.
                     * @param {string} columnName The name of the table column that relates to the slicer.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerStyle} style The style of the slicer.
                     * @return {GCTYPE.Spread.Sheets.Slicers.Slicer} The slicer that has been added to the sheet.
                     * @example
                     * //This example uses the add method.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     */
                    add(name: string,  tableName: string,  columnName: string,  style: GCTYPE.Spread.Sheets.Slicers.SlicerStyle): GCTYPE.Spread.Sheets.Slicers.Slicer;
                    /**
                     * Gets all of the slicers in the sheet with the indicated table name and column name.
                     * @param {string} tableName The name of the table.
                     * @param {string} columnName The name of the column.
                     * @returns {Array.<GCTYPE.Spread.Sheets.Slicers.Slicer>} The slicer collection.
                     */
                    all(tableName: string,  columnName: string): GCTYPE.Spread.Sheets.Slicers.Slicer[];
                    /**
                     * Removes all of the slicers from the sheet.
                     */
                    clear(): void;
                    /**
                     * Gets a slicer in the sheet by the name.
                     * @param {string} name The name of the slicer.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.Slicer} The slicer that has the indicated name.
                     */
                    get(name: string): GCTYPE.Spread.Sheets.Slicers.Slicer;
                    /**
                     * Removes a slicer from the sheet using the indicated slicer name.
                     * @param {string} name The name of the slicer.
                     */
                    remove(name: string): void;
                }

                export class SlicerStyle{
                    /**
                     * Represents the slicer style settings.
                     * @class
                     */
                    constructor();
                    /**
                     * Gets or sets the style of the slicer header.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo} [value] The style of the slicer header.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo | GCTYPE.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the slicer header; otherwise, returns the slicer style.
                     * @example
                     * //This example sets the header backcolor.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //slicer info
                     * var hstyle = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.headerStyle(hstyle);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    headerStyle(value?: GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                    /**
                     * Gets or sets the style of the hovered selected item with data.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo} [value] The style of the hovered selected item with data.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo | GCTYPE.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the hovered selected item with data; otherwise, returns the slicer style.
                     * @example
                     * //This example sets the hoveredSelectedItemWithDataStyle method.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * // slicer info
                     * var hstyle = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    hoveredSelectedItemWithDataStyle(value?: GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                    /**
                     * Gets or sets the style of the hovered selected item with no data.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo} [value] The style of the hovered selected item with no data.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo | GCTYPE.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the hovered selected item with no data; otherwise, returns the slicer style.
                     * @example
                     * //This example uses the hoveredSelectedItemWithNoDataStyle method.
                     * var datasource = [
                     *     { Name: "Apple", Category: "Fruit" },
                     *     { Name: "Orange", Category: "Fruit" },
                     *     { Name: "Broccoli", Category: "Vegetable" },
                     *     { Name: "Kiwi", Category: "Fruit" },
                     *     { Name: "Rice", Category: "Cereal" },
                     *     { Name: "Strawberry", Category: "Fruit" },
                     *     { Name: "Yogurt", Category: "Dairy" },
                     *     { Name: "Plum", Category: "Fruit" },
                     *     { Name: "Celery", Category: "Vegetable" },
                     *     { Name: "Grape", Category: "Fruit" },
                     *     { Name: "Oats", Category: "Cereal" },
                     *     { Name: "Quinoa", Category: "Cereal" },
                     *     { Name: "Maize", Category: "Cereal" },
                     *     { Name: "Okra", Category: "Vegetable" },
                     *     { Name: "Corn", Category: "Vegetable" },
                     *     { Name: "Wheat", Category: "Cereal" },
                     *     { Name: "Barley", Category: "Cereal" },
                     *     { Name: "Cream", Category: "Dairy" },
                     *     { Name: "Millet", Category: "Cereal" },
                     *     { Name: "Rye", Category: "Cereal" },
                     *     { Name: "Artichoke", Category: "Vegetable" },
                     *     { Name: "Buckwheat", Category: "Cereal" },
                     *     { Name: "Gooseberry", Category: "Fruit" },
                     *     { Name: "Amaranth", Category: "Cereal" },
                     *     { Name: "Carrot", Category: "Vegetable" },
                     *     { Name: "Cheese", Category: "Dairy" },
                     *     { Name: "Fig", Category: "Fruit" },
                     *     { Name: "Milk", Category: "Dairy" },
                     *     { Name: "Butter", Category: "Dairy" },
                     *                ];
                     * //add table
                     * var table = activeSheet.tables.addFromDataSource("table1", 1, 1, datasource);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Category");
                     *  //change the slicer properties.
                     * slicer.width(200);
                     * slicer.height(200);
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(300, 50));
                     * var slicer2 = activeSheet.slicers.add("slicer2", table.name(), "Name");
                     * var hstyle = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var hstyle1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * hstyle1.backColor("yellow");
                     * var hstyle2 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2.backColor("green");
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.hoveredUnSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * style1.selectedItemWithDataStyle(hstyle2);
                     * slicer.style(style1);
                     * // slicer style
                     * var hstyle2nd = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2nd.backColor("red");
                     * hstyle2nd.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "double", "orange"));
                     * var hstyle12nd = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle12nd.borderTop(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(2, "double", "blue"));
                     * hstyle12nd.backColor("yellow");
                     * var hstyle22nd = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle22nd.backColor("magenta");
                     * var style1two = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1two.hoveredSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.hoveredUnSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.unSelectedItemWithNoDataStyle(hstyle12nd);
                     * style1two.selectedItemWithNoDataStyle(hstyle22nd);
                     * slicer2.style(style1two);
                     * activeSheet.getColumn(1).width(100);
                     * activeSheet.getColumn(2).width(100);
                     * activeSheet.getColumn(3).width(100);
                     */
                    hoveredSelectedItemWithNoDataStyle(value?: GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                    /**
                     * Gets or sets the style of the hovered unselected item with data.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo} [value] The style of the hovered unselected item with data.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo | GCTYPE.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the hovered unselected item with data; otherwise, returns the slicer style.
                     * @example
                     * //This example uses the hoveredUnSelectedItemWithDataStyle method.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * // slicer style
                     * var hstyle = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredUnSelectedItemWithDataStyle(hstyle);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    hoveredUnSelectedItemWithDataStyle(value?: GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                    /**
                     * Gets or sets the style of the hovered unselected item with no data.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo} [value] The style of the hovered unselected item with no data.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo | GCTYPE.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the hovered unselected item with no data; otherwise, returns the slicer style.
                     * @example
                     * //This example uses the hoveredUnSelectedItemWithNoDataStyle method.
                     * var datasource = [
                     *     { Name: "Apple", Category: "Fruit" },
                     *     { Name: "Orange", Category: "Fruit" },
                     *     { Name: "Broccoli", Category: "Vegetable" },
                     *     { Name: "Kiwi", Category: "Fruit" },
                     *     { Name: "Rice", Category: "Cereal" },
                     *     { Name: "Strawberry", Category: "Fruit" },
                     *     { Name: "Yogurt", Category: "Dairy" },
                     *     { Name: "Plum", Category: "Fruit" },
                     *     { Name: "Celery", Category: "Vegetable" },
                     *     { Name: "Grape", Category: "Fruit" },
                     *     { Name: "Oats", Category: "Cereal" },
                     *     { Name: "Quinoa", Category: "Cereal" },
                     *     { Name: "Maize", Category: "Cereal" },
                     *     { Name: "Okra", Category: "Vegetable" },
                     *     { Name: "Corn", Category: "Vegetable" },
                     *     { Name: "Wheat", Category: "Cereal" },
                     *     { Name: "Barley", Category: "Cereal" },
                     *     { Name: "Cream", Category: "Dairy" },
                     *     { Name: "Millet", Category: "Cereal" },
                     *     { Name: "Rye", Category: "Cereal" },
                     *     { Name: "Artichoke", Category: "Vegetable" },
                     *     { Name: "Buckwheat", Category: "Cereal" },
                     *     { Name: "Gooseberry", Category: "Fruit" },
                     *     { Name: "Amaranth", Category: "Cereal" },
                     *     { Name: "Carrot", Category: "Vegetable" },
                     *     { Name: "Cheese", Category: "Dairy" },
                     *     { Name: "Fig", Category: "Fruit" },
                     *     { Name: "Milk", Category: "Dairy" },
                     *     { Name: "Butter", Category: "Dairy" },
                     *               ];
                     * var table = activeSheet.tables.addFromDataSource("table1", 1, 1, datasource);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Category");
                     *  //change the slicer properties.
                     * slicer.width(200);
                     * slicer.height(200);
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(300, 50));
                     * var slicer2 = activeSheet.slicers.add("slicer2", table.name(), "Name");
                     * var hstyle = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var hstyle1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * hstyle1.backColor("yellow");
                     * var hstyle2 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2.backColor("green");
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.hoveredUnSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * style1.selectedItemWithDataStyle(hstyle2);
                     * slicer.style(style1);
                     * var hstyle2nd = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2nd.backColor("red");
                     * hstyle2nd.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "double", "orange"));
                     * var hstyle12nd = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle12nd.borderTop(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(2, "double", "blue"));
                     * hstyle12nd.backColor("yellow");
                     * var hstyle22nd = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle22nd.backColor("magenta");
                     * var style1two = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1two.hoveredSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.hoveredUnSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.unSelectedItemWithNoDataStyle(hstyle12nd);
                     * style1two.selectedItemWithNoDataStyle(hstyle22nd);
                     * slicer2.style(style1two);
                     * activeSheet.getColumn(1).width(100);
                     * activeSheet.getColumn(2).width(100);
                     * activeSheet.getColumn(3).width(100);
                     */
                    hoveredUnSelectedItemWithNoDataStyle(value?: GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                    /**
                     * Gets or sets the name of the style.
                     * @param {string} [value] The slicer style name.
                     * @returns {string | GCTYPE.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the name of the style; otherwise, returns the slicer style.
                     */
                    name(value?: string): any;
                    /**
                     * Gets or sets the style of the selected item with data.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo} [value] The style of the selected item with data.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo | GCTYPE.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the selected item with data; otherwise, returns the slicer style.
                     * @example
                     * //This example uses the hoveredUnSelectedItemWithNoDataStyle method.
                     * var datasource = [
                     *     { Name: "Apple", Category: "Fruit" },
                     *     { Name: "Orange", Category: "Fruit" },
                     *     { Name: "Broccoli", Category: "Vegetable" },
                     *     { Name: "Kiwi", Category: "Fruit" },
                     *     { Name: "Rice", Category: "Cereal" },
                     *     { Name: "Strawberry", Category: "Fruit" },
                     *     { Name: "Yogurt", Category: "Dairy" },
                     *     { Name: "Plum", Category: "Fruit" },
                     *     { Name: "Celery", Category: "Vegetable" },
                     *     { Name: "Grape", Category: "Fruit" },
                     *     { Name: "Oats", Category: "Cereal" },
                     *     { Name: "Quinoa", Category: "Cereal" },
                     *     { Name: "Maize", Category: "Cereal" },
                     *     { Name: "Okra", Category: "Vegetable" },
                     *     { Name: "Corn", Category: "Vegetable" },
                     *     { Name: "Wheat", Category: "Cereal" },
                     *     { Name: "Barley", Category: "Cereal" },
                     *     { Name: "Cream", Category: "Dairy" },
                     *     { Name: "Millet", Category: "Cereal" },
                     *     { Name: "Rye", Category: "Cereal" },
                     *     { Name: "Artichoke", Category: "Vegetable" },
                     *     { Name: "Buckwheat", Category: "Cereal" },
                     *     { Name: "Gooseberry", Category: "Fruit" },
                     *     { Name: "Amaranth", Category: "Cereal" },
                     *     { Name: "Carrot", Category: "Vegetable" },
                     *     { Name: "Cheese", Category: "Dairy" },
                     *     { Name: "Fig", Category: "Fruit" },
                     *     { Name: "Milk", Category: "Dairy" },
                     *     { Name: "Butter", Category: "Dairy" },
                     *               ];
                     * var table = activeSheet.tables.addFromDataSource("table1", 1, 1, datasource);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Category");
                     *  //change the slicer properties.
                     * slicer.width(200);
                     * slicer.height(200);
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(300, 50));
                     * var slicer2 = activeSheet.slicers.add("slicer2", table.name(), "Name");
                     * var hstyle = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var hstyle1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * hstyle1.backColor("yellow");
                     * var hstyle2 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2.backColor("green");
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.hoveredUnSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * style1.selectedItemWithDataStyle(hstyle2);
                     * slicer.style(style1);
                     * var hstyle2nd = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2nd.backColor("red");
                     * hstyle2nd.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "double", "orange"));
                     * var hstyle12nd = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle12nd.borderTop(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(2, "double", "blue"));
                     * hstyle12nd.backColor("yellow");
                     * var hstyle22nd = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle22nd.backColor("magenta");
                     * var style1two = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1two.hoveredSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.hoveredUnSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.unSelectedItemWithNoDataStyle(hstyle12nd);
                     * style1two.selectedItemWithNoDataStyle(hstyle22nd);
                     * slicer2.style(style1two);
                     * activeSheet.getColumn(1).width(100);
                     * activeSheet.getColumn(2).width(100);
                     * activeSheet.getColumn(3).width(100);
                     */
                    selectedItemWithDataStyle(value?: GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                    /**
                     * Gets or sets the style of the selected item with no data.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo} [value] The style of the selected item with no data.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo | GCTYPE.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the selected item with no data; otherwise, returns the slicer style.
                     * @example
                     * //This example uses the hoveredUnSelectedItemWithNoDataStyle method.
                     * var datasource = [
                     *     { Name: "Apple", Category: "Fruit" },
                     *     { Name: "Orange", Category: "Fruit" },
                     *     { Name: "Broccoli", Category: "Vegetable" },
                     *     { Name: "Kiwi", Category: "Fruit" },
                     *     { Name: "Rice", Category: "Cereal" },
                     *     { Name: "Strawberry", Category: "Fruit" },
                     *     { Name: "Yogurt", Category: "Dairy" },
                     *     { Name: "Plum", Category: "Fruit" },
                     *     { Name: "Celery", Category: "Vegetable" },
                     *     { Name: "Grape", Category: "Fruit" },
                     *     { Name: "Oats", Category: "Cereal" },
                     *     { Name: "Quinoa", Category: "Cereal" },
                     *     { Name: "Maize", Category: "Cereal" },
                     *     { Name: "Okra", Category: "Vegetable" },
                     *     { Name: "Corn", Category: "Vegetable" },
                     *     { Name: "Wheat", Category: "Cereal" },
                     *     { Name: "Barley", Category: "Cereal" },
                     *     { Name: "Cream", Category: "Dairy" },
                     *     { Name: "Millet", Category: "Cereal" },
                     *     { Name: "Rye", Category: "Cereal" },
                     *     { Name: "Artichoke", Category: "Vegetable" },
                     *     { Name: "Buckwheat", Category: "Cereal" },
                     *     { Name: "Gooseberry", Category: "Fruit" },
                     *     { Name: "Amaranth", Category: "Cereal" },
                     *     { Name: "Carrot", Category: "Vegetable" },
                     *     { Name: "Cheese", Category: "Dairy" },
                     *     { Name: "Fig", Category: "Fruit" },
                     *     { Name: "Milk", Category: "Dairy" },
                     *     { Name: "Butter", Category: "Dairy" },
                     *               ];
                     * var table = activeSheet.tables.addFromDataSource("table1", 1, 1, datasource);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Category");
                     *  //change the slicer properties.
                     * slicer.width(200);
                     * slicer.height(200);
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(300, 50));
                     * var slicer2 = activeSheet.slicers.add("slicer2", table.name(), "Name");
                     * var hstyle = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var hstyle1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * hstyle1.backColor("yellow");
                     * var hstyle2 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2.backColor("green");
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.hoveredUnSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * style1.selectedItemWithDataStyle(hstyle2);
                     * slicer.style(style1);
                     * var hstyle2nd = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2nd.backColor("red");
                     * hstyle2nd.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "double", "orange"));
                     * var hstyle12nd = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle12nd.borderTop(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(2, "double", "blue"));
                     * hstyle12nd.backColor("yellow");
                     * var hstyle22nd = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle22nd.backColor("magenta");
                     * var style1two = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1two.hoveredSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.hoveredUnSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.unSelectedItemWithNoDataStyle(hstyle12nd);
                     * style1two.selectedItemWithNoDataStyle(hstyle22nd);
                     * slicer2.style(style1two);
                     * activeSheet.getColumn(1).width(100);
                     * activeSheet.getColumn(2).width(100);
                     * activeSheet.getColumn(3).width(100);
                     */
                    selectedItemWithNoDataStyle(value?: GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                    /**
                     * Gets or sets the style of the unselected item with data.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo} [value] The style of the unselected item with data.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo | GCTYPE.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the unselected item with data; otherwise, returns the slicer style.
                     * @example
                     * //This example uses the hoveredUnSelectedItemWithNoDataStyle method.
                     * var datasource = [
                     *     { Name: "Apple", Category: "Fruit" },
                     *     { Name: "Orange", Category: "Fruit" },
                     *     { Name: "Broccoli", Category: "Vegetable" },
                     *     { Name: "Kiwi", Category: "Fruit" },
                     *     { Name: "Rice", Category: "Cereal" },
                     *     { Name: "Strawberry", Category: "Fruit" },
                     *     { Name: "Yogurt", Category: "Dairy" },
                     *     { Name: "Plum", Category: "Fruit" },
                     *     { Name: "Celery", Category: "Vegetable" },
                     *     { Name: "Grape", Category: "Fruit" },
                     *     { Name: "Oats", Category: "Cereal" },
                     *     { Name: "Quinoa", Category: "Cereal" },
                     *     { Name: "Maize", Category: "Cereal" },
                     *     { Name: "Okra", Category: "Vegetable" },
                     *     { Name: "Corn", Category: "Vegetable" },
                     *     { Name: "Wheat", Category: "Cereal" },
                     *     { Name: "Barley", Category: "Cereal" },
                     *     { Name: "Cream", Category: "Dairy" },
                     *     { Name: "Millet", Category: "Cereal" },
                     *     { Name: "Rye", Category: "Cereal" },
                     *     { Name: "Artichoke", Category: "Vegetable" },
                     *     { Name: "Buckwheat", Category: "Cereal" },
                     *     { Name: "Gooseberry", Category: "Fruit" },
                     *     { Name: "Amaranth", Category: "Cereal" },
                     *     { Name: "Carrot", Category: "Vegetable" },
                     *     { Name: "Cheese", Category: "Dairy" },
                     *     { Name: "Fig", Category: "Fruit" },
                     *     { Name: "Milk", Category: "Dairy" },
                     *     { Name: "Butter", Category: "Dairy" },
                     *               ];
                     * var table = activeSheet.tables.addFromDataSource("table1", 1, 1, datasource);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Category");
                     *  //change the slicer properties.
                     * slicer.width(200);
                     * slicer.height(200);
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(300, 50));
                     * var slicer2 = activeSheet.slicers.add("slicer2", table.name(), "Name");
                     * var hstyle = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var hstyle1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * hstyle1.backColor("yellow");
                     * var hstyle2 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2.backColor("green");
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.hoveredUnSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * style1.selectedItemWithDataStyle(hstyle2);
                     * slicer.style(style1);
                     * var hstyle2nd = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2nd.backColor("red");
                     * hstyle2nd.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "double", "orange"));
                     * var hstyle12nd = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle12nd.borderTop(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(2, "double", "blue"));
                     * hstyle12nd.backColor("yellow");
                     * var hstyle22nd = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle22nd.backColor("magenta");
                     * var style1two = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1two.hoveredSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.hoveredUnSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.unSelectedItemWithNoDataStyle(hstyle12nd);
                     * style1two.selectedItemWithNoDataStyle(hstyle22nd);
                     * slicer2.style(style1two);
                     * activeSheet.getColumn(1).width(100);
                     * activeSheet.getColumn(2).width(100);
                     * activeSheet.getColumn(3).width(100);
                     */
                    unSelectedItemWithDataStyle(value?: GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                    /**
                     * Gets or sets the style of the unselected item with no data.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo} [value] The style of the unselected item with no data.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo | GCTYPE.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the unselected item with no data; otherwise, returns the slicer style.
                     * @example
                     * //This example uses the hoveredUnSelectedItemWithNoDataStyle method.
                     * var datasource = [
                     *     { Name: "Apple", Category: "Fruit" },
                     *     { Name: "Orange", Category: "Fruit" },
                     *     { Name: "Broccoli", Category: "Vegetable" },
                     *     { Name: "Kiwi", Category: "Fruit" },
                     *     { Name: "Rice", Category: "Cereal" },
                     *     { Name: "Strawberry", Category: "Fruit" },
                     *     { Name: "Yogurt", Category: "Dairy" },
                     *     { Name: "Plum", Category: "Fruit" },
                     *     { Name: "Celery", Category: "Vegetable" },
                     *     { Name: "Grape", Category: "Fruit" },
                     *     { Name: "Oats", Category: "Cereal" },
                     *     { Name: "Quinoa", Category: "Cereal" },
                     *     { Name: "Maize", Category: "Cereal" },
                     *     { Name: "Okra", Category: "Vegetable" },
                     *     { Name: "Corn", Category: "Vegetable" },
                     *     { Name: "Wheat", Category: "Cereal" },
                     *     { Name: "Barley", Category: "Cereal" },
                     *     { Name: "Cream", Category: "Dairy" },
                     *     { Name: "Millet", Category: "Cereal" },
                     *     { Name: "Rye", Category: "Cereal" },
                     *     { Name: "Artichoke", Category: "Vegetable" },
                     *     { Name: "Buckwheat", Category: "Cereal" },
                     *     { Name: "Gooseberry", Category: "Fruit" },
                     *     { Name: "Amaranth", Category: "Cereal" },
                     *     { Name: "Carrot", Category: "Vegetable" },
                     *     { Name: "Cheese", Category: "Dairy" },
                     *     { Name: "Fig", Category: "Fruit" },
                     *     { Name: "Milk", Category: "Dairy" },
                     *     { Name: "Butter", Category: "Dairy" },
                     *               ];
                     * var table = activeSheet.tables.addFromDataSource("table1", 1, 1, datasource);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Category");
                     *  //change the slicer properties.
                     * slicer.width(200);
                     * slicer.height(200);
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(300, 50));
                     * var slicer2 = activeSheet.slicers.add("slicer2", table.name(), "Name");
                     * var hstyle = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var hstyle1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * hstyle1.backColor("yellow");
                     * var hstyle2 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2.backColor("green");
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.hoveredUnSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * style1.selectedItemWithDataStyle(hstyle2);
                     * slicer.style(style1);
                     * var hstyle2nd = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle2nd.backColor("red");
                     * hstyle2nd.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "double", "orange"));
                     * var hstyle12nd = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle12nd.borderTop(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(2, "double", "blue"));
                     * hstyle12nd.backColor("yellow");
                     * var hstyle22nd = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle22nd.backColor("magenta");
                     * var style1two = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1two.hoveredSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.hoveredUnSelectedItemWithNoDataStyle(hstyle2nd);
                     * style1two.unSelectedItemWithNoDataStyle(hstyle12nd);
                     * style1two.selectedItemWithNoDataStyle(hstyle22nd);
                     * slicer2.style(style1two);
                     * activeSheet.getColumn(1).width(100);
                     * activeSheet.getColumn(2).width(100);
                     * activeSheet.getColumn(3).width(100);
                     */
                    unSelectedItemWithNoDataStyle(value?: GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                    /**
                     * Gets or sets the style of the whole slicer.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo} [value] The style of the whole slicer.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo | GCTYPE.Spread.Sheets.Slicers.SlicerStyle} If no value is set, returns the style of the whole slicer; otherwise, returns the slicer style.
                     * @example
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Height");
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * //set customized style
                     * var style = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * var styleInfo1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * styleInfo1.backColor("orange");
                     * styleInfo1.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(2,"solid","green"));
                     * style.wholeSlicerStyle(styleInfo1);
                     * var styleInfo2 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * styleInfo2.backColor("red");
                     * styleInfo2.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(4,"solid","gray"));
                     * style.hoveredSelectedItemWithDataStyle(styleInfo2);
                     * slicer.style(style);
                     */
                    wholeSlicerStyle(value?: GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo): any;
                }

                export class SlicerStyleInfo{
                    /**
                     * Represents slicer style information.
                     * @class
                     * @param {string} [backColor] The background color of the style information.
                     * @param {string} [foreColor] The foreground color of the style information.
                     * @param {string} [font] The font of the style information.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerBorder} [borderLeft] The left border of the style information.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerBorder} [borderTop] The top border of the slicer information.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerBorder} [borderRight] The right border of the style information.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerBorder} [borderBottom] The bottom border of the style information.
                     * @param {GCTYPE.Spread.Sheets.TextDecorationType} [textDecoration] The text decoration of the style information.
                     */
                    constructor(backColor?: string,  foreColor?: string,  font?: string,  borderLeft?: GCTYPE.Spread.Sheets.Slicers.SlicerBorder,  borderTop?: GCTYPE.Spread.Sheets.Slicers.SlicerBorder,  borderRight?: GCTYPE.Spread.Sheets.Slicers.SlicerBorder,  borderBottom?: GCTYPE.Spread.Sheets.Slicers.SlicerBorder,  textDecoration?: GCTYPE.Spread.Sheets.TextDecorationType);
                    /**
                     * Gets or sets the background color of the style information.
                     * @param {string} [value] The background color of the style information.
                     * @returns {string | GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo}  If no value is set, returns the background color of the style information; otherwise, returns the slicer style information.
                     * @example
                     * //This example sets the header backcolor.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //style
                     * var hstyle = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.headerStyle(hstyle);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    backColor(value?: string): any;
                    /**
                     * Gets or sets the bottom border of the style information.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerBorder} [value] The bottom border of the style information.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerBorder | GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo}  If no value is set, returns the bottom border of the style information; otherwise, returns the slicer style information.
                     * @example
                     * //This example sets a border style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //style
                     * var hstyle = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     * //change the slicer properties.
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    borderBottom(value?: GCTYPE.Spread.Sheets.Slicers.SlicerBorder): any;
                    /**
                     * Gets or sets the left border of the style information.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerBorder} [value] The left border of the style information.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerBorder | GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo}  If no value is set, returns the left border of the style information; otherwise, returns the slicer style information.
                     * @example
                     * //This example sets the left border.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //style
                     * var hstyle = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderLeft(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * hstyle.borderRight(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var hstyle1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    borderLeft(value?: GCTYPE.Spread.Sheets.Slicers.SlicerBorder): any;
                    /**
                     * Gets or sets the right border of the style information.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerBorder} [value] The right border of the style information.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerBorder | GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo}  If no value is set, returns the right border of the style information; otherwise, returns the slicer style information.
                     * @example
                     * //This example sets the border.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //style
                     * var hstyle = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderLeft(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * hstyle.borderRight(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var hstyle1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    borderRight(value?: GCTYPE.Spread.Sheets.Slicers.SlicerBorder): any;
                    /**
                     * Gets or sets the top border of the style information.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerBorder} [value] The top border of the style information.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerBorder | GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo}  If no value is set, returns the top border of the style information; otherwise, returns the slicer style information.
                     * @example
                     * //This example sets the border.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //style
                     * var hstyle = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderLeft(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * hstyle.borderRight(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * var hstyle1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    borderTop(value?: GCTYPE.Spread.Sheets.Slicers.SlicerBorder): any;
                    /**
                     * Gets or sets the font of the style information.
                     * @param {string} [value] The font of the style information.
                     * @returns {string | GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo}  If no value is set, returns the font of the style information; otherwise, returns the slicer style information.
                     * @example
                     * //This example sets the font.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //style
                     * var hstyle = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * hstyle.font("8pt Arial");
                     * hstyle.textDecoration(GCTYPE.Spread.Sheets.TextDecorationType.underline);
                     * var hstyle1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    font(value?: string): any;
                    /**
                     * Gets or sets the foreground color of the style information.
                     * @param {string} [value] The foreground color of the style information.
                     * @returns {string | GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo}  If no value is set, returns the foreground color of the style information; otherwise, returns the slicer style information.
                     * @example
                     * //This example sets a header style for the slicer.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //style
                     * var hstyle = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.foreColor("white");
                     * hstyle.backColor("black");
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.headerStyle(hstyle);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    foreColor(value?: string): any;
                    /**
                     * Sets every border of the style information.
                     * @param {GCTYPE.Spread.Sheets.Slicers.SlicerBorder} value The border setting.
                     */
                    setBorders(value: GCTYPE.Spread.Sheets.Slicers.SlicerBorder): void;
                    /**
                     * Gets or sets the text decoration of the style information.
                     * @param {GCTYPE.Spread.Sheets.TextDecorationType} [value] The text decoration of the style information.
                     * @returns {GCTYPE.Spread.Sheets.TextDecorationType | GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo}  If no value is set, returns the text decoration of the style information; otherwise, returns the slicer style information.
                     * @example
                     * //This example underlines the text.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * //style
                     * var hstyle = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle.backColor("red");
                     * hstyle.borderBottom(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(3, "dashed", "green"));
                     * hstyle.font("8pt Arial");
                     * hstyle.textDecoration(GCTYPE.Spread.Sheets.TextDecorationType.underline);
                     * var hstyle1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyleInfo();
                     * hstyle1.borderTop(new GCTYPE.Spread.Sheets.Slicers.SlicerBorder(2, "dashed", "blue"));
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyle();
                     * style1.hoveredSelectedItemWithDataStyle(hstyle);
                     * style1.unSelectedItemWithDataStyle(hstyle1);
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    textDecoration(value?: GCTYPE.Spread.Sheets.TextDecorationType): any;
                }

                export class SlicerStyles{
                    /**
                     * Represents a built-in slicer style collection.
                     * @class
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.light4();
                     * //add a slicer to the sheet and return the slicer instance.
                     * var slicer = activeSheet.slicers.add("slicer1",table.name(),"Name");
                     *  //change the slicer properties.
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    constructor();
                    /**
                     * Gets the dark1 style.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.dark1();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static dark1(): GCTYPE.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the dark2 style.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.dark2();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static dark2(): GCTYPE.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the dark3 style.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.dark3();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static dark3(): GCTYPE.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the dark4 style.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.dark4();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static dark4(): GCTYPE.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the dark5 style.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.dark5();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static dark5(): GCTYPE.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the dark6 style.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.dark6();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static dark6(): GCTYPE.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the light1 style.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.light1();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static light1(): GCTYPE.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the light2 style.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.light2();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static light2(): GCTYPE.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the light3 style.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.light3();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static light3(): GCTYPE.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the light4 style.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.light4();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static light4(): GCTYPE.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the light5 style.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.light5();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static light5(): GCTYPE.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the light6 style.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.light6();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static light6(): GCTYPE.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the other1 style.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.other1();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static other1(): GCTYPE.Spread.Sheets.Slicers.SlicerStyle;
                    /**
                     * Gets the other2 style.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.SlicerStyle}
                     * @example
                     * //This example uses a built-in style.
                     * //create a table
                     * datas = [
                     *     ["1", "NewYork", "1968/6/8", "80", "180"],
                     *     ["4", "NewYork", "1972/7/3", "72", "168"],
                     *     ["4", "NewYork", "1964/3/2", "71", "179"],
                     *     ["5", "Washington", "1972/8/8","80", "171"],
                     *     ["6", "Washington", "1986/2/2", "89", "161"],
                     *     ["7", "Washington", "2012/2/15", "71", "240"]];
                     * var table = activeSheet.tables.addFromDataSource("table1", 2, 2, datas);
                     * dataColumns = ["Name", "City", "Birthday", "Weight", "Height"];
                     * table.setColumnName(0, dataColumns[0]);
                     * table.setColumnName(1, dataColumns[1]);
                     * table.setColumnName(2, dataColumns[2]);
                     * table.setColumnName(3, dataColumns[3]);
                     * table.setColumnName(4, dataColumns[4]);
                     * var style1 = new GCTYPE.Spread.Sheets.Slicers.SlicerStyles.other2();
                     *  //create a slicer
                     * //add the slicer to the sheet
                     * var slicer = activeSheet.slicers.add("slicer1", table.name(),"Height");
                     * slicer.position(new GCTYPE.Spread.Sheets.Point(100, 200));
                     * slicer.style(style1);
                     */
                    static other2(): GCTYPE.Spread.Sheets.Slicers.SlicerStyle;
                }

                export class TableSlicerData extends GCTYPE.Spread.Slicers.GeneralSlicerData{
                    /**
                     * Represents table slicer data.
                     * @extends GCTYPE.Spread.Slicers.GeneralSlicerData
                     * @class GCTYPE.Spread.Sheets.TableSlicerData
                     * @param {GCTYPE.Spread.Sheets.Tables.Table} table The table.
                     * @example
                     * //This example creates a slicer for the table.
                     * //create table
                     * var dataSource = [
                     *     { Name: "Bob", City: "NewYork", Birthday: "1968/6/8" },
                     *     { Name: "Betty", City: "NewYork", Birthday: "1972/7/3" },
                     *     { Name: "Alice", City: "Washington", Birthday: "2012/2/15" },
                     * ];
                     * var table = activeSheet.tables.addFromDataSource("table1", 1, 1, dataSource);
                     * var slicerData = new GCTYPE.Spread.Sheets.Slicers.TableSlicerData(table)
                     * //Set slicer data to item slicer.
                     * var slicer = new GCTYPE.Spread.Sheets.Slicers.ItemSlicer("slicer", slicerData, "Name");
                     * //Add the item slicer to the dom tree.
                     * //The "slicerHost" is the div you want to add the slicer's dom to.
                     * $("#slicerHost").append(slicer.getDOMElement());
                     */
                    constructor(table: GCTYPE.Spread.Sheets.Tables.Table);
                    /**
                     * Filters the data that corresponds to the specified column name and exclusive data indexes.
                     * @param {string} columnName The column name.
                     * @param {object} conditional The filter conditional.
                     * conditional.exclusiveRowIndexes: number array type, visible exclusive row indexes
                     * conditional.ranges: {min:number, max:number} array type, visible ranges.
                     * @param {boolean} [isPreview] Indicates whether filter is in preview mode.
                     */
                    doFilter(columnName: string,  conditional: GCTYPE.Spread.Slicers.ISlicerConditional,  isPreview?: boolean): void;
                    /**
                     * Unfilters the data that corresponds to the specified column name.
                     * @param {string} columnName The column name.
                     */
                    doUnfilter(columnName: string): void;
                    /**
                     * Gets the slicer data of the table.
                     * @returns {GCTYPE.Spread.Sheets.Slicers.TableSlicerData} The slicer data of the table.
                     */
                    getSlicerData(): GCTYPE.Spread.Sheets.Slicers.TableSlicerData;
                    /**
                     * Gets the table of the table slicer data.
                     * @returns {GCTYPE.Spread.Sheets.Tables.Table} The table of the table slicer data.
                     */
                    getTable(): GCTYPE.Spread.Sheets.Tables.Table;
                    /**
                     * Refreshes the table slicer data.
                     */
                    refresh(): void;
                }
            }

            module Sparklines{

                export interface ISparklineSetting{
                    axisColor?: string;
                    firstMarkerColor?: string;
                    highMarkerColor?: string;
                    lastMarkerColor?: string;
                    lowMarkerColor?: string;
                    markersColor?: string;
                    negativeColor?: string;
                    seriesColor?: string;
                    displayEmptyCellsAs?: EmptyValueStyle;
                    rightToLeft?: boolean;
                    displayHidden?: boolean;
                    displayXAxis?: boolean;
                    showFirst?: boolean;
                    showHigh?: boolean;
                    showLast?: boolean;
                    showLow?: boolean;
                    showNegative?: boolean;
                    showMarkers?: boolean;
                    manualMax?: number;
                    manualMin?: number;
                    maxAxisType?: SparklineAxisMinMax;
                    minAxisType?: SparklineAxisMinMax;
                    groupMaxValue?: number;
                    groupMinValue?: number;
                    lineWeight?: number;
                }

                /**
                 * Represents the orientation of the range.
                 * @enum {number}
                 * @example
                 * //This example uses the DataOrientation enumeration.
                 * activeSheet.setValue(0, 0, "Data Range is A2-A9");
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 * var data = new GCTYPE.Spread.Sheets.Range(1, 0, 8, 1);
                 * var setting = new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting();
                 * var s1=  activeSheet.setSparkline(11, 0, data, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.Vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 * var s2 =activeSheet.setSparkline(11, 3, data, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.Vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.column, setting);
                 * var s3=  activeSheet.setSparkline(11, 6, data, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.Vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.winloss, setting);
                 * var group = activeSheet.groupSparkline([s1,s2,s3]);
                 * //activeSheet.ungroupSparkline(group);
                 */
                export enum DataOrientation{
                    /** Specifies the vertical orientation.
                     * @type {number}
                     */
                    vertical= 0,
                    /** Specifies the horizontal orientation.
                     * @type {number}
                     */
                    horizontal= 1
                }

                /**
                 * Specifies how to show an empty value from a data series in the chart.
                 * @enum {number}
                 * @example
                 * //This example uses the EmptyValueStyle enumeration.
                 * var data = new GCTYPE.Spread.Sheets.Range(1, 0, 8, 1);
                 * var setting = new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting
                 * setting.options.showMarkers = true;
                 * setting.options.lineWeight = 3;
                 * setting.options.displayXAxis = true;
                 * setting.options.showFirst = true;
                 * setting.options.showLast = true;
                 * setting.options.showLow = true;
                 * setting.options.showHigh = true;
                 * setting.options.showNegative = true;
                 * setting.options.seriesColor = "Text 2 1";
                 * setting.options.firstMarkerColor = "Text 2 3";
                 * setting.options.negativeColor = "Accent 2 1";
                 * setting.options.markersColor = "Accent 3 1";
                 * setting.options.lowMarkerColor = "Accent 4 1";
                 * setting.options.highMarkerColor = "Accent 6 1";
                 * setting.options.lastMarkerColor = "Accent 6 6";
                 * setting.options.axisColor = "Text 1 1";
                 * setting.options.displayEmptyCellsAs =  GCTYPE.Spread.Sheets.Sparklines.EmptyValueStyle.Zero;
                 * activeSheet.addSpan(13, 0, 4, 3, null);
                 * activeSheet.setSparkline(13, 0, data, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 */
                export enum EmptyValueStyle{
                    /** Leaves gaps for empty values in a data series, which results in a segmented line.
                     * @type {number}
                     */
                    gaps= 0,
                    /** Handles empty values in a data series as zero values, so that the line drops to zero for zero-value data points.
                     * @type {number}
                     */
                    zero= 1,
                    /** Fills gaps with a connecting element instead of leaving gaps for empty values in a data series.
                     * @type {number}
                     */
                    connect= 2
                }

                /**
                 * An enumeration that specifies information about how the vertical axis minimum or maximum is computed for this sparkline group.
                 * @enum {number}
                 * @example
                 * //This example uses the SparklineAxisMinMax enumeration.
                 * activeSheet.setValue(0, 0, "Data Range is A2-A9");
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 * var data = new GCTYPE.Spread.Sheets.Range(1, 0, 8, 1);
                 * var setting = new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting();
                 * setting.options.minAxisType = GCTYPE.Spread.Sheets.Sparklines.SparklineAxisMinMax.custom;
                 * setting.options.manualMin = -2;
                 * setting.options.maxAxisType = GCTYPE.Spread.Sheets.Sparklines.SparklineAxisMinMax.custom;
                 * setting.options.manualMax = 10;
                 * var s1=  activeSheet.setSparkline(11, 0, data, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.Vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 * var s2 =activeSheet.setSparkline(11, 3, data, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.Vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.column, setting);
                 * var s3=  activeSheet.setSparkline(11, 6, data, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.Vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.winloss, setting);
                 * var group = activeSheet.groupSparkline([s1,s2,s3]);
                 */
                export enum SparklineAxisMinMax{
                    /** Specifies that the vertical axis minimum or maximum for each sparkline in this sparkline group is calculated automatically such that the data point with the minimum or maximum value can be displayed in the plot area.
                     * @type {number}
                     */
                    individual= 0,
                    /** Specifies that the vertical axis minimum or maximum is shared across all sparklines in this sparkline group and is calculated automatically such that the data point with the minimum or maximum value can be displayed in the plot area.
                     * @type {number}
                     */
                    group= 1,
                    /** Specifies that the vertical axis minimum or maximum for each sparkline in this sparkline group is specified by the manualMin attribute or the manualMax attribute of the sparkline group.
                     * @type {number}
                     */
                    custom= 2
                }

                /**
                 * Represents the sparkline type.
                 * @enum {number}
                 * @example
                 * //This example uses the SparklineType enumeration.
                 * activeSheet.setValue(0, 0, "Data Range is A2-A9");
                 * activeSheet.setValue(1, 0, 1);
                 * activeSheet.setValue(2, 0, -2);
                 * activeSheet.setValue(3, 0, -1);
                 * activeSheet.setValue(4, 0, 6);
                 * activeSheet.setValue(5, 0, 4);
                 * activeSheet.setValue(6, 0, -4);
                 * activeSheet.setValue(7, 0, 3);
                 * activeSheet.setValue(8, 0, 8);
                 * var data = new GCTYPE.Spread.Sheets.Range(1, 0, 8, 1);
                 * var setting = new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting();
                 * var s1=  activeSheet.setSparkline(11, 0, data, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.Vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.line, setting);
                 * var s2 =activeSheet.setSparkline(11, 3, data, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.Vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.column, setting);
                 * var s3=  activeSheet.setSparkline(11, 6, data, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.Vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.winloss, setting);
                 * var group = activeSheet.groupSparkline([s1,s2,s3]);
                 * //activeSheet.ungroupSparkline(group);
                 */
                export enum SparklineType{
                    /** Specifies the line sparkline.
                     * @type {number}
                     */
                    line= 0,
                    /** Specifies the column sparkline.
                     * @type {number}
                     */
                    column= 1,
                    /** Specifies the win-loss sparkline.
                     * @type {number}
                     */
                    winloss= 2
                }


                export class AreaSparkline extends SparklineEx{
                    /**
                     * Represents the class for the area sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class BoxPlotSparkline extends SparklineEx{
                    /**
                     * Represents the class for the box plot sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class BulletSparkline extends SparklineEx{
                    /**
                     * Represents the class for the bullet sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class CascadeSparkline extends SparklineEx{
                    /**
                     * Represents the class for the cascade sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class ColumnSparkline extends SparklineEx{
                    /**
                     * Represents the class for the column sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class GaugeKPISparkline extends SparklineEx{
                    /**
                     * Represents the class for the gauge KPI sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class HBarSparkline extends SparklineEx{
                    /**
                     * Represents the class for the HBar sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class HistogramSparkline extends SparklineEx{
                    /**
                     * Represents the class for the histogram sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.HistogramSparkline
                     * @class
                     */
                    constructor();
                }

                export class ImageSparkline extends SparklineEx{
                    /**
                     * Represents the class for the image sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.ImageSparkline
                     * @class
                     */
                    constructor();
                }

                export class LineSparkline extends SparklineEx{
                    /**
                     * Represents the class for the line sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class MonthSparkline extends SparklineEx{
                    /**
                     * Represents the class for the month sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class ParetoSparkline extends SparklineEx{
                    /**
                     * Represents the class for the pareto sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class PieSparkline extends SparklineEx{
                    /**
                     * Represents the class for the pie sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class RangeBlockSparkline extends SparklineEx{
                    /**
                     * Represents the class for the range block sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class ScatterSparkline extends SparklineEx{
                    /**
                     * Represents the class for the scatter sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class Sparkline{
                    /**
                     * Represents a Sparkline class.
                     * @param {number} row The row index.
                     * @param {number} column The column index.
                     * @param {GCTYPE.Spread.Sheets.Range} dataReference The data range to which the sparkline refers.
                     * @param {GCTYPE.Spread.Sheets.Sparklines.DataOrientation} dataOrientation The orientation of the data range.
                     * @param {GCTYPE.Spread.Sheets.Sparklines.SparklineType} type The type of sparkline.
                     * @param {GCTYPE.Spread.Sheets.Sparklines.SparklineSetting} setting The setting of the sparkline.
                     * @class
                     */
                    constructor(row?: number,  column?: number,  dataReference?: GCTYPE.Spread.Sheets.Range,  dataOrientation?: GCTYPE.Spread.Sheets.Sparklines.DataOrientation,  type?: GCTYPE.Spread.Sheets.Sparklines.SparklineType,  setting?: GCTYPE.Spread.Sheets.Sparklines.SparklineSetting);
                    /** Gets the column index.
                     * @type {number}
                     */
                    column: number;
                    /** Gets the row index.
                     * @type {number}
                     */
                    row: number;
                    /**
                     * Clones a sparkline.
                     * @returns {GCTYPE.Spread.Sheets.Sparklines.Sparkline} The cloned sparkline.
                     */
                    clone(): GCTYPE.Spread.Sheets.Sparklines.Sparkline;
                    /**
                     * Gets or sets the data object.
                     * @param {GCTYPE.Spread.Sheets.Range} value The sparkline data.
                     * @returns {GCTYPE.Spread.Sheets.Range | GCTYPE.Spread.Sheets.Sparklines.Sparkline} If no value is set, returns the data object; otherwise, returns the sparkline.
                     * @example
                     * //This example uses the data method.
                     * activeSheet.suspendPaint();
                     * activeSheet.setValue(1, 0, 10);
                     * activeSheet.setValue(2, 0, 0);
                     * activeSheet.setValue(3, 0, -3);
                     * activeSheet.setValue(4, 0, -5);
                     * activeSheet.setValue(0, 0, 1);
                     * activeSheet.setValue(0, 1, 2);
                     * activeSheet.setValue(0, 2, 4);
                     * activeSheet.setValue(0, 3, 8);
                     * activeSheet.setValue(0, 4, 6);
                     * activeSheet.setValue(0, 5, new Date(2014, 1, 1));
                     * activeSheet.setValue(1, 5, new Date(2014, 9, 1));
                     * activeSheet.setValue(2, 5, new Date(2014, 7, 1));
                     * activeSheet.setValue(3, 5, new Date(2014, 5, 1));
                     * activeSheet.setValue(4, 5, new Date(2014, 3, 1));
                     * var sparkline = activeSheet.setSparkline(5, 0, new GCTYPE.Spread.Sheets.Range(0, 0, 5, 5), GCTYPE.Spread.Sheets.Sparklines.DataOrientation.horizontal, GCTYPE.Spread.Sheets.Sparklines.SparklineType.line, new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting(), new GCTYPE.Spread.Sheets.Range(0, 5, 5, 1), GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.data(new GCTYPE.Spread.Sheets.Range(0, 0, 5, 5));
                     * sparkline.sparklineType(GCTYPE.Spread.Sheets.Sparklines.SparklineType.line);
                     * sparkline.setting(new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting());
                     * sparkline.dateAxisData(new GCTYPE.Spread.Sheets.Range(0, 5, 5, 1));
                     * sparkline.dataOrientation(GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.dateAxisOrientation(GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.row = 5;
                     * sparkline.column = 0;
                     * sparkline.displayDateAxis(true);
                     * activeSheet.resumePaint();
                     */
                    data(value?: GCTYPE.Spread.Sheets.Range): any;
                    /**
                     * Gets or sets the data orientation.
                     * @param {GCTYPE.Spread.Sheets.Sparklines.DataOrientation} value The sparkline data orientation.
                     * @returns {GCTYPE.Spread.Sheets.Sparklines.DataOrientation | GCTYPE.Spread.Sheets.Sparklines.Sparkline} If no value is set, returns the sparkline data orientation; otherwise, returns the sparkline.
                     * @example
                     * //This example uses the vertical data and the date range to create the sparkline.
                     * var setting = new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting();
                     * setting.options.showMarkers = true;
                     * setting.options.displayXAxis = true;
                     * activeSheet.suspendPaint();
                     * activeSheet.setValue(1, 0, 10);
                     * activeSheet.setValue(2, 0, 0);
                     * activeSheet.setValue(3, 0, -3);
                     * activeSheet.setValue(4, 0, -5);
                     * activeSheet.setValue(0, 0, 1);
                     * activeSheet.setValue(0, 1, 2);
                     * activeSheet.setValue(0, 2, 4);
                     * activeSheet.setValue(0, 3, 8);
                     * activeSheet.setValue(0, 4, 6);
                     * activeSheet.setValue(0, 5, new Date(2014, 1, 1));
                     * activeSheet.setValue(1, 5, new Date(2014, 9, 1));
                     * activeSheet.setValue(2, 5, new Date(2014, 7, 1));
                     * activeSheet.setValue(3, 5, new Date(2014, 5, 1));
                     * activeSheet.setValue(4, 5, new Date(2014, 3, 1));
                     * var sparkline = activeSheet.setSparkline(5, 0, new GCTYPE.Spread.Sheets.Range(0, 0, 5, 5), GCTYPE.Spread.Sheets.Sparklines.DataOrientation.horizontal, GCTYPE.Spread.Sheets.Sparklines.SparklineType.line, setting, new GCTYPE.Spread.Sheets.Range(0, 5, 5, 1), GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.dataOrientation(GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.displayDateAxis(true);
                     * activeSheet.resumePaint();
                     * activeSheet.addSpan(5, 0, 4, 3, null);
                     */
                    dataOrientation(value?: GCTYPE.Spread.Sheets.Sparklines.DataOrientation): any;
                    /**
                     * Gets or sets the date axis data object.
                     * @param {GCTYPE.Spread.Sheets.Range} value The sparkline date axis data.
                     * @returns {GCTYPE.Spread.Sheets.Range | GCTYPE.Spread.Sheets.Sparklines.Sparkline} If no value is set, returns the sparkline date axis data; otherwise, returns the sparkline.
                     * @example
                     * //This example uses the dateAxisData method.
                     * activeSheet.suspendPaint();
                     * activeSheet.setValue(1, 0, 10);
                     * activeSheet.setValue(2, 0, 0);
                     * activeSheet.setValue(3, 0, -3);
                     * activeSheet.setValue(4, 0, -5);
                     * activeSheet.setValue(0, 0, 1);
                     * activeSheet.setValue(0, 1, 2);
                     * activeSheet.setValue(0, 2, 4);
                     * activeSheet.setValue(0, 3, 8);
                     * activeSheet.setValue(0, 4, 6);
                     * activeSheet.setValue(0, 5, new Date(2014, 1, 1));
                     * activeSheet.setValue(1, 5, new Date(2014, 9, 1));
                     * activeSheet.setValue(2, 5, new Date(2014, 7, 1));
                     * activeSheet.setValue(3, 5, new Date(2014, 5, 1));
                     * activeSheet.setValue(4, 5, new Date(2014, 3, 1));
                     * var sparkline = activeSheet.setSparkline(5, 0, new GCTYPE.Spread.Sheets.Range(0, 0, 5, 5), GCTYPE.Spread.Sheets.Sparklines.DataOrientation.horizontal, GCTYPE.Spread.Sheets.Sparklines.SparklineType.line, new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting(), new GCTYPE.Spread.Sheets.Range(0, 5, 5, 1), GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.data(new GCTYPE.Spread.Sheets.Range(0, 0, 5, 5));
                     * sparkline.sparklineType(GCTYPE.Spread.Sheets.Sparklines.SparklineType.line);
                     * sparkline.setting(new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting());
                     * sparkline.dateAxisData(new GCTYPE.Spread.Sheets.Range(0, 5, 5, 1));
                     * sparkline.dataOrientation(GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.dateAxisOrientation(GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.row = 5;
                     * sparkline.column = 0;
                     * sparkline.displayDateAxis(true);
                     * activeSheet.resumePaint();
                     */
                    dateAxisData(value?: GCTYPE.Spread.Sheets.Range): any;
                    /**
                     * Gets or sets the date axis orientation.
                     * @param {GCTYPE.Spread.Sheets.Sparklines.DataOrientation} value The sparkline date axis orientation.
                     * @returns {GCTYPE.Spread.Sheets.Sparklines.DataOrientation | GCTYPE.Spread.Sheets.Sparklines.Sparkline} If no value is set, returns the sparkline date axis orientation; otherwise, returns the sparkline.
                     * @example
                     * //This example uses vertical data with horizontal dates to create a sparkline.
                     * var setting = new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting();
                     * setting.options.showMarkers = true;
                     * setting.options.displayXAxis = true;
                     * activeSheet.suspendPaint();
                     * activeSheet.setValue(1, 0, 10);
                     * activeSheet.setValue(2, 0, 0);
                     * activeSheet.setValue(3, 0, -3);
                     * activeSheet.setValue(4, 0, -5);
                     * activeSheet.setValue(0, 0, 1);
                     * activeSheet.setValue(0, 1, 2);
                     * activeSheet.setValue(0, 2, 4);
                     * activeSheet.setValue(0, 3, 8);
                     * activeSheet.setValue(0, 4, 6);
                     * activeSheet.setValue(0, 5, new Date(2014, 1, 1));
                     * activeSheet.setValue(1, 5, new Date(2014, 9, 1));
                     * activeSheet.setValue(2, 5, new Date(2014, 7, 1));
                     * activeSheet.setValue(3, 5, new Date(2014, 5, 1));
                     * activeSheet.setValue(4, 5, new Date(2014, 3, 1));
                     * activeSheet.setValue(11, 0, new Date(2014, 1, 1));
                     * activeSheet.setValue(11, 1, new Date(2014, 9, 1));
                     * activeSheet.setValue(11, 2, new Date(2014, 7, 1));
                     * activeSheet.setValue(11, 3, new Date(2014, 5, 1));
                     * activeSheet.setValue(11, 4, new Date(2014, 3, 1));
                     * var sparkline = activeSheet.setSparkline(5, 0, new GCTYPE.Spread.Sheets.Range(0, 0, 5, 5), GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.line, setting, new GCTYPE.Spread.Sheets.Range(11, 0, 1, 5), GCTYPE.Spread.Sheets.Sparklines.DataOrientation.horizontal);
                     * sparkline.dataOrientation(GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.dateAxisOrientation(GCTYPE.Spread.Sheets.Sparklines.DataOrientation.horizontal);
                     * sparkline.displayDateAxis(true);
                     * activeSheet.resumePaint();
                     * activeSheet.addSpan(5, 0, 4, 3, null);
                     */
                    dateAxisOrientation(value?: GCTYPE.Spread.Sheets.Sparklines.DataOrientation): any;
                    /**
                     * Gets or sets a value that indicates whether to display the date axis.
                     * @param {boolean} value Whether to display the date axis.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Sparklines.Sparkline} If no value is set, returns whether to display the date axis; otherwise, returns the sparkline.
                     * @example
                     * //This example uses the vertical data and the date range to create the sparkline.
                     * var setting = new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting();
                     * setting.options.showMarkers = true;
                     * setting.options.displayXAxis = true;
                     * activeSheet.suspendPaint();
                     * activeSheet.setValue(1, 0, 10);
                     * activeSheet.setValue(2, 0, 0);
                     * activeSheet.setValue(3, 0, -3);
                     * activeSheet.setValue(4, 0, -5);
                     * activeSheet.setValue(0, 0, 1);
                     * activeSheet.setValue(0, 1, 2);
                     * activeSheet.setValue(0, 2, 4);
                     * activeSheet.setValue(0, 3, 8);
                     * activeSheet.setValue(0, 4, 6);
                     * activeSheet.setValue(0, 5, new Date(2014, 1, 1));
                     * activeSheet.setValue(1, 5, new Date(2014, 9, 1));
                     * activeSheet.setValue(2, 5, new Date(2014, 7, 1));
                     * activeSheet.setValue(3, 5, new Date(2014, 5, 1));
                     * activeSheet.setValue(4, 5, new Date(2014, 3, 1));
                     * var sparkline = activeSheet.setSparkline(5, 0, new GCTYPE.Spread.Sheets.Range(0, 0, 5, 5), GCTYPE.Spread.Sheets.Sparklines.DataOrientation.horizontal, GCTYPE.Spread.Sheets.Sparklines.SparklineType.line, setting, new GCTYPE.Spread.Sheets.Range(0, 5, 5, 1), GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.dataOrientation(GCTYPE.Spread.Sheets.Sparklines.DataOrientation.vertical);
                     * sparkline.displayDateAxis(true);
                     * activeSheet.resumePaint();
                     * activeSheet.addSpan(5, 0, 4, 3, null);
                     */
                    displayDateAxis(value?: boolean): any;
                    /**
                     * Gets or sets the sparkline group.
                     * @param {GCTYPE.Spread.Sheets.Sparklines.SparklineGroup} value The sparkline group.
                     * @returns {GCTYPE.Spread.Sheets.Sparklines.SparklineGroup | GCTYPE.Spread.Sheets.Sparklines.Sparkline} If no value is set, returns the sparkline group; otherwise, returns the sparkline.
                     */
                    group(value?: GCTYPE.Spread.Sheets.Sparklines.SparklineGroup): any;
                    /**
                     * Paints the sparkline in the specified area.
                     * @param {CanvasRenderingContext2D} ctx The canvas's two-dimensional context.
                     * @param {number} x <i>x</i>-coordinate relative to the canvas.
                     * @param {number} y <i>y</i>-coordinate relative to the canvas.
                     * @param {number} w The width of the cell that contains the sparkline.
                     * @param {number} h The height of the cell that contains the sparkline.
                     */
                    paintSparkline(ctx: CanvasRenderingContext2D,  x: number,  y: number,  w: number,  h: number): void;
                    /**
                     * Gets or sets the sparkline setting of the cell.
                     * @param {GCTYPE.Spread.Sheets.Sparklines.SparklineSetting} value The sparkline setting.
                     * @returns {GCTYPE.Spread.Sheets.Sparklines.SparklineSetting  | GCTYPE.Spread.Sheets.Sparklines.Sparkline} If no value is set, returns the sparkline setting; otherwise, returns the sparkline.
                     */
                    setting(value?: GCTYPE.Spread.Sheets.Sparklines.SparklineSetting): any;
                    /**
                     * Gets or sets the type of the sparkline.
                     * @param {GCTYPE.Spread.Sheets.Sparklines.SparklineType} value The sparkline type.
                     * @returns {GCTYPE.Spread.Sheets.Sparklines.SparklineType | GCTYPE.Spread.Sheets.Sparklines.Sparkline} If no value is set, returns the sparkline type; otherwise, returns the sparkline.
                     */
                    sparklineType(value?: GCTYPE.Spread.Sheets.Sparklines.SparklineType): any;
                }

                export class SparklineEx{
                    /**
                     * Represents the base class for the other SparklineEx classes.
                     * @class
                     */
                    constructor();
                    /**
                     * Represents the type name string used for supporting serialization.
                     * @type {string}
                     */
                    typeName: string;
                    /**
                     * Creates a custom function used to provide data and settings for SparklineEx.
                     * @returns {GCTYPE.Spread.CalcEngine.Functions.Function} The created custom function.
                     */
                    createFunction(): GCTYPE.Spread.CalcEngine.Functions.Function;
                    /**
                     * Loads the object state from the specified JSON string.
                     * @param {Object} settings The sparklineEx data from deserialization.
                     */
                    fromJSON(settings: Object): void;
                    /**
                     * Gets the name of SparklineEx.
                     * @returns {string} The SparklineEx's name.
                     */
                    name(): string;
                    /**
                     * Paints the SparklineEx on the canvas.
                     * @param {CanvasRenderingContext2D} context The canvas's two-dimensional context.
                     * @param {object} value The value evaluated by the custom function.
                     * @param {number} x <i>x</i>-coordinate relative to the canvas.
                     * @param {number} y <i>y</i>-coordinate relative to the canvas.
                     * @param {number} width The cell's width.
                     * @param {number} height The cell's height.
                     */
                    paint(context: CanvasRenderingContext2D,  value: any,  x: number,  y: number,  width: number,  height: number): void;
                    /**
                     * Saves the object state to a JSON string.
                     * @returns {Object} The sparklineEx data.
                     */
                    toJSON(): Object;
                }

                export class SparklineGroup{
                    /**
                     * Represents a sparkline group.
                     * @param {GCTYPE.Spread.Sheets.Sparklines.SparklineType} type The type of sparkline.
                     * @param {GCTYPE.Spread.Sheets.Sparklines.SparklineSetting} setting The setting of the sparkline group.
                     * @class
                     */
                    constructor(type: GCTYPE.Spread.Sheets.Sparklines.SparklineType,  setting: GCTYPE.Spread.Sheets.Sparklines.SparklineSetting);
                    /** Indicates the sparkline settings.
                     * @type {GCTYPE.Spread.Sheets.Sparklines.SparklineSetting}
                     */
                    setting: GCTYPE.Spread.Sheets.Sparklines.SparklineSetting;
                    /** Indicates the sparkline type.
                     * @type {GCTYPE.Spread.Sheets.Sparklines.SparklineType}
                     */
                    sparklineType: GCTYPE.Spread.Sheets.Sparklines.SparklineType;
                    /**
                     * Adds a sparkline to the group.
                     * @param {GCTYPE.Spread.Sheets.Sparklines.Sparkline} item The sparkline item.
                     */
                    add(item: GCTYPE.Spread.Sheets.Sparklines.Sparkline): void;
                    /**
                     * Clones the current sparkline group.
                     * @returns {GCTYPE.Spread.Sheets.Sparklines.SparklineGroup} The cloned sparkline group.
                     */
                    clone(): GCTYPE.Spread.Sheets.Sparklines.SparklineGroup;
                    /**
                     * Determines whether the group contains a specific value.
                     * @param {GCTYPE.Spread.Sheets.Sparklines.Sparkline} item The object to locate in the group.
                     * @returns {boolean} <c>true</c> if the item is found in the group; otherwise, <c>false</c>.
                     */
                    contains(item: GCTYPE.Spread.Sheets.Sparklines.Sparkline): boolean;
                    /**
                     * Represents the count of the sparkline group innerlist.
                     * @returns {number} The sparkline count in the group.
                     */
                    count(): number;
                    /**
                     * Represents the date axis data.
                     * @param {GCTYPE.Spread.Sheets.Range} value The date axis data.
                     * @returns {GCTYPE.Spread.Sheets.Range | undefined} If no value is set, returns the date axis data; otherwise, returns undefined.
                     */
                    dateAxisData(value?: GCTYPE.Spread.Sheets.Range): any;
                    /**
                     * Represents the date axis orientation.
                     * @param {GCTYPE.Spread.Sheets.Sparklines.DataOrientation} value The date axis orientation.
                     * @returns {GCTYPE.Spread.Sheets.Sparklines.DataOrientation | undefined} If no value is set, returns the date axis orientation; otherwise, returns undefined.
                     */
                    dateAxisOrientation(value: GCTYPE.Spread.Sheets.Sparklines.DataOrientation): any;
                    /**
                     * Removes the first occurrence of a specific object from the group.
                     * @param {GCTYPE.Spread.Sheets.Sparklines.Sparkline} item The sparkline item.
                     * @returns {Array.<GCTYPE.Spread.Sheets.Sparklines.Sparkline>} The GCTYPE.Spread.Sheets.Sparklines.Sparkline array.
                     */
                    remove(item: GCTYPE.Spread.Sheets.Sparklines.Sparkline): GCTYPE.Spread.Sheets.Sparklines.Sparkline[];
                }

                export class SparklineSetting{
                    /**
                     * Creates the sparkline settings.
                     * @param {GCTYPE.Spread.Sheets.Sparklines.ISparklineSetting} setting The settings.
                     * @class
                     */
                    constructor(setting?: GCTYPE.Spread.Sheets.Sparklines.ISparklineSetting);
                    /**
                     * Indicates the options for the sparkline.<br />
                     * options.axisColor {string} the color of the axis<br />
                     * options.firstMarkerColor {string} the color of the first data point for each sparkline in this sparkline group<br />
                     * options.highMarkerColor {string} the color of the highest data point for each sparkline in this sparkline group<br />
                     * options.lastMarkerColor {string} the color of the last data point for each sparkline in this sparkline group<br />
                     * options.lowMarkerColor {string} the color of the lowest data point for each sparkline in this sparkline group<br />
                     * options.markersColor {string} a value that specifies the color of the data markers for each sparkline in this sparkline group<br />
                     * options.negativeColor {string} a value that specifies the color of the negative data points for each sparkline in this sparkline group<br />
                     * options.seriesColor {string} a value that specifies the color for each sparkline in this sparkline group<br />
                     * options.displayEmptyCellsAs {GCTYPE.Spread.Sheets.Sparklines.EmptyValueStyle} Indicates how to display the empty cells<br />
                     * options.rightToLeft {boolean} Indicates whether each sparkline in the sparkline group is displayed in a right-to-left manner<br />
                     * options.displayHidden {boolean} Indicates whether data in hidden cells is plotted for the sparklines in this sparkline group<br />
                     * options.displayXAxis {boolean} Indicates whether the horizontal axis is displayed for each sparkline in this sparkline group<br />
                     * options.showFirst {boolean} a value that indicates whether the first data point is formatted differently for each sparkline in this sparkline group<br />
                     * options.showHigh {boolean} a value that specifies whether the data points with the highest value are formatted differently for each sparkline in this sparkline group<br />
                     * options.showLast {boolean} a value that indicates whether the last data point is formatted differently for each sparkline in this sparkline group<br />
                     * options.showLow {boolean} a value that specifies whether the data points with the lowest value are formatted differently for each sparkline in this sparkline group<br />
                     * options.showNegative {boolean} a value that specifies whether the negative data points are formatted differently for each sparkline in this sparkline group<br />
                     * options.showMarkers {boolean} a value that specifies whether data markers are displayed for each sparkline in this sparkline group<br />
                     * options.manualMax {number} Indicates the maximum for the vertical axis that is shared across all sparklines in this sparkline group. The axis is zero if maxAxisType does not equal custom<br />
                     * options.manualMin {number} Indicates the minimum for the vertical axis that is shared across all sparklines in this sparkline group. The axis is zero if minAxisType does not equal custom<br />
                     * options.maxAxisType {GCTYPE.Spread.Sheets.Sparklines.SparklineAxisMinMax} Indicates how the vertical axis maximum is calculated for the sparklines in this sparkline group<br />
                     * options.minAxisType {GCTYPE.Spread.Sheets.Sparklines.SparklineAxisMinMax} Indicates how the vertical axis minimum is calculated for the sparklines in this sparkline group<br />
                     * options.groupMaxValue {number} Gets the maximum value of the sparkline group<br />
                     * options.groupMinValue {number} Gets the minimum value of the sparkline group<br />
                     * options.lineWeight {number} Indicates the line weight for each sparkline in the sparkline group, where the line weight is measured in points. The weight must be greater than or equal to zero, and must be less than or equal to 3 (LineSeries only supports line weight values in the range of 0.0-3.0)
                     * @example
                     * var data = new GCTYPE.Spread.Sheets.Range(1, 0, 8, 1);
                     * var setting = new GCTYPE.Spread.Sheets.Sparklines.SparklineSetting();
                     * setting.options.showMarkers = true;
                     * setting.options.lineWeight = 3;
                     * setting.options.displayXAxis = true;
                     * setting.options.showFirst = true;
                     * setting.options.showLast = true;
                     * setting.options.showLow = true;
                     * setting.options.showHigh = true;
                     * setting.options.showNegative = true;
                     * setting.options.seriesColor = "Text 2 1";
                     * setting.options.firstMarkerColor = "Text 2 3";
                     * setting.options.negativeColor = "Accent 2 1";
                     * setting.options.markersColor = "Accent 3 1";
                     * setting.options.lowMarkerColor = "Accent 4 1";
                     * setting.options.highMarkerColor = "Accent 6 1";
                     * setting.options.lastMarkerColor = "Accent 6 6";
                     * setting.options.axisColor ="Text 1 1";
                     * sheet.addSpan(13, 0, 4, 3, null);
                     * sheet.setSparkline(13, 0, data, GCTYPE.Spread.Sheets.Sparklines.DataOrientation.Vertical, GCTYPE.Spread.Sheets.Sparklines.SparklineType.line, setting);
                     * sheet.setValue(1, 0, 1);
                     * sheet.setValue(2, 0, -2);
                     * sheet.setValue(3, 0, -1);
                     * sheet.setValue(4, 0, 6);
                     * sheet.setValue(5, 0, 4);
                     * sheet.setValue(6, 0, -4);
                     * sheet.setValue(7, 0, 3);
                     */
                    options: GCTYPE.Spread.Sheets.Sparklines.ISparklineSetting;
                    /**
                     * Clones sparkline settings.
                     * @returns {GCTYPE.Spread.Sheets.Sparklines.SparklineSetting} The cloned sparkline setting.
                     */
                    clone(): GCTYPE.Spread.Sheets.Sparklines.SparklineSetting;
                }

                export class SpreadSparkline extends SparklineEx{
                    /**
                     * Represents the class for the Spread sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class StackedSparkline extends SparklineEx{
                    /**
                     * Represents the class for the stacked sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class VariSparkline extends SparklineEx{
                    /**
                     * Represents the class for the variance sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class VBarSparkline extends SparklineEx{
                    /**
                     * Represents the class for the VBar sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class WinlossSparkline extends SparklineEx{
                    /**
                     * Represents the class for the winloss sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }

                export class YearSparkline extends SparklineEx{
                    /**
                     * Represents the class for the year sparkline.
                     * @extends GCTYPE.Spread.Sheets.Sparklines.SparklineEx
                     * @class
                     */
                    constructor();
                }
            }

            module StatusBar{
                /**
                 * Gets the StatusBar instance by the host element.
                 * @param {HTMLElement|string} host The host element or the host element id.
                 * @returns {GCTYPE.Spread.Sheets.StatusBar.StatusBar} The StatusBar instance.
                 * @example
                 * var spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                 * var spanItem = new GCTYPE.Spread.Sheets.StatusBar.StatusItem('spanItem', {menuContent: 'current span', value: 'span test'});
                 * var statusBar = new GCTYPE.Spread.Sheets.StatusBar.StatusBar(
                 * document.getElementById('statusBar'),
                 * { items: [spanItem] }
                 * );
                 * statusBar.bind(spread);
                 * var statusBarInstance = GCTYPE.Spread.Sheets.StatusBar.findControl('statusBar');
                 */
                function findControl(host: HTMLElement|string): GCTYPE.Spread.Sheets.StatusBar.StatusBar;

                export interface IStatusBarOptions{
                    items: GCTYPE.Spread.Sheets.StatusBar.StatusItem[];
                }


                export class StatusBar{
                    /**
                     * Represents status bar.
                     * @class
                     * @param {HTMLElement} host The DOM Element.
                     * @param {Object} [options]
                     * @param {Array<GCTYPE.Spread.Sheets.StatusBar.StatusItem>} [options.items] The array of StatusItem.
                     * @example
                     * let statusBar = new GCTYPE.Spread.Sheets.StatusBar.StatusBar(document.getElementById('statusBar'),
                     *   {items: [new GCTYPE.Spread.Sheets.StatusBar.StatusItem('labelItem', {menuContent: 'label'})]});
                     */
                    constructor(host: HTMLElement,  options?: GCTYPE.Spread.Sheets.StatusBar.IStatusBarOptions);
                    /**
                     * Add the item instance to the StatusBar.
                     * @param {GCTYPE.Spread.Sheets.StatusBar.StatusItem} item The instance of the child of StatusItem. The child extends from StatusItem.
                     * @param {number} position The position is items index in all items array. Start from 0. Items display position is also related to align. If position is invalid or undefine, place it by default.
                     * @returns {boolean} Add item result. Return true if add success, else failed.
                     * @example
                     * let StatusItem = GCTYPE.Spread.Sheets.StatusBar.StatusItem;
                     * let spanItem = new StatusItem('spanItemName', {menuContent: 'span', value: 'spanValue'});
                     * let spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                     * let statusBar = new GCTYPE.Spread.Sheets.StatusBar.StatusBar(document.getElementById('statusBar'));
                     * statusBar.bind(spread);
                     * statusBar.add(spanItem);
                     */
                    add(item: GCTYPE.Spread.Sheets.StatusBar.StatusItem,  position: number): boolean;
                    /**
                     * Get all item list.
                     * @return {Array.<GCTYPE.Spread.Sheets.StatusBar.StatusItem>} The item list on statusbar.
                     * @example
                     * let spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                     * let statusBar = new GCTYPE.Spread.Sheets.StatusBar.StatusBar(document.getElementById('statusBar'));
                     * statusBar.bind(spread);
                     * let itemList = statusBar.all();
                     * statusBar.remove(itemList[0]);
                     */
                    all(): GCTYPE.Spread.Sheets.StatusBar.StatusItem[];
                    /**
                     * Bind the context of the StatusBar.
                     * @param {Object} context The context of the StatusBar. The context can trigger the status change of StatusBar. Here the context is the instance of GCTYPE.Spread.Sheets.Workbook.
                     * @example
                     * let spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                     * let statusBar = new GCTYPE.Spread.Sheets.StatusBar.StatusBar(document.getElementById('statusBar'));
                     * statusBar.bind(spread);
                     */
                    bind(context: GCTYPE.Spread.Sheets.Workbook): void;
                    /**
                     * Dispose the StatusBar and unbind all events.
                     * @example
                     * let spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                     * let statusBar = new GCTYPE.Spread.Sheets.StatusBar.StatusBar(document.getElementById('statusBar'));
                     * statusBar.bind(spread);
                     * // do something
                     * statusBar.dispose();
                     */
                    dispose(): void;
                    /**
                     * Get the item by item name.
                     * @param {string} itemName
                     * @returns {GCTYPE.Spread.Sheets.StatusBar.StatusItem} The StatusItem whose itemName is specified.
                     * @example
                     * let StatusItem = GCTYPE.Spread.Sheets.StatusBar.StatusItem;
                     * let spanItemName = 'spanItemName';
                     * let spanItem = new StatusItem(spanItemName, {menuContent: 'span', value: 'spanValue'});
                     * let spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                     * let statusBar = new GCTYPE.Spread.Sheets.StatusBar.StatusBar(document.getElementById('statusBar'));
                     * statusBar.bind(spread);
                     * statusBar.add(spanItem);
                     * let spanItemInstance = statusBar.get(spanItemName);
                     */
                    get(itemName: string): GCTYPE.Spread.Sheets.StatusBar.StatusItem;
                    /**
                     * Remove the item from the StatusBar.
                     * @param {string} itemName The name of the StatusItem.
                     * @returns {boolean} If true means remove success, else failed.
                     * @example
                     * let StatusItem = GCTYPE.Spread.Sheets.StatusBar.StatusItem;
                     * let spanItemName = 'spanItemName';
                     * let spanItem = new StatusItem(spanItemName, {menuContent: 'span', value: 'spanValue'});
                     * let spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                     * let statusBar = new GCTYPE.Spread.Sheets.StatusBar.StatusBar(document.getElementById('statusBar'));
                     * statusBar.bind(spread);
                     * statusBar.add(spanItem);
                     * // do something
                     * statusBar.remove(spanItemName);
                     */
                    remove(itemName: string): boolean;
                    /**
                     * Unbind the context of the StatusBar.
                     * @example
                     * let spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                     * let statusBar = new GCTYPE.Spread.Sheets.StatusBar.StatusBar(document.getElementById('statusBar'));
                     * statusBar.bind(spread);
                     * // do something
                     * statusBar.unbind();
                     */
                    unbind(): void;
                    /**
                     * Update the StatusBar.
                     * @example
                     * let spread = new GCTYPE.Spread.Sheets.Workbook(document.getElementById("ss"));
                     * let statusBar = new GCTYPE.Spread.Sheets.StatusBar.StatusBar(document.getElementById('statusBar'));
                     * statusBar.update();
                     */
                    update(): void;
                }

                export class StatusItem{
                    /**
                     * The base class of status item provides basic value display and related context menu item function.
                     * @class
                     * @param {string} name - The name is the Unique identifier and needed in context menu and statusbar.
                     * @param {Object} options - The object of status item options.
                     * @param {string} [options.menuContent] - The menuContent displayed left on context menu which represent current item.
                     * @param {string} [options.align] - Control the item alignment on statusbar. The value is 'left' or 'right'.
                     * @param {string} [options.tipText] - The tip text displayed when mouse over the item. Show the description for the item.
                     * @param {boolean} [options.visible] - 1.The visibility of current item on statusbar. 2.The checked status of current item on context menu.
                     * @param {boolean} [options.showStatusInContexMenu] - Whether show the status on right of context menu.
                     * @param {Object} [options.value] - The value displayed on status bar and on right of context menu to represent the status of current item.
                     * @example
                     * let StatusItem = GCTYPE.Spread.Sheets.StatusBar.StatusItem;
                     * let labelItem = new StatusItem('labelItem', {menuContent: 'label', value: 'text'});
                     */
                    constructor(name: string,  options?: Object);
                    /**
                     * Bind the Context. Can override to add context related event listener.
                     * @override
                     * @param {GCTYPE.Spread.Sheets.Workbook} context The excute context for the statusbar item.
                     * @example
                     * LabelItem.prototype.onBind = function (context) {
                     *   // do something about context.
                     * }
                     */
                    onBind(context: GCTYPE.Spread.Sheets.Workbook): void;
                    /**
                     * Create the item element on statusbar. Can override for customize item.
                     * @override
                     * @param {HTMLElement} container
                     * @example
                     * let StatusItem = GCTYPE.Spread.Sheets.StatusBar.StatusItem;
                     * function LabelItem (name, options) {
                     *   StatusItem.call(this, name, options);
                     * }
                     * LabelItem.prototype = new StatusItem();
                     * LabelItem.prototype.onCreateItemView = function (container) {
                     *   let item = document.createElement('div');
                     *   item.innerText = this.value;
                     *   container.appendChild(item);
                     *   // add event listener for container
                     * }
                     * statusBar.add(new LabelItem('labelItem', {menuContent: 'label', value: 'options test'}));
                     */
                    onCreateItemView(container: HTMLElement): void;
                    /**
                     * Dispose the statusbar to unbind context, remove all listener and dispose all element.
                     * @override
                     * @example
                     * let StatusItem = GCTYPE.Spread.Sheets.StatusBar.StatusItem;
                     * function LabelItem (name, options) {
                     *   StatusItem.call(this, name, options);
                     * }
                     * LabelItem.prototype = new StatusItem();
                     * LabelItem.prototype.onDispose = function () {
                     *   // dispose current item.
                     *   // then call super dispose.
                     *   StatusItem.prototype.onDispose.call(this);
                     * }
                     */
                    onDispose(): void;
                    /**
                     * Unbind the Context. Can override to remove context related event listener.
                     * @override
                     * @example
                     * LabelItem.prototype.onUnbind = function () {
                     *   // remove event listener related to context.
                     * }
                     */
                    onUnbind(): void;
                    /**
                     * The callback for status bar update. Called when status bar bind or update function, or status bar check changed in context menu.
                     * The update related operations can realize in it. Users also should call onUpdate when current item need update.
                     * The default operations in super is update current item by visible.
                     * @override
                     * @example
                     * let StatusItem = GCTYPE.Spread.Sheets.StatusBar.StatusItem;
                     * function LabelItem (name, options) {
                     *   StatusItem.call(this, name, options);
                     * }
                     * LabelItem.prototype = new StatusItem();
                     * LabelItem.prototype.onUpdate = function () {
                     *   StatusItem.prototype.onUpdate.call(this);
                     *   // update item.
                     */
                    onUpdate(): void;
                }
            }

            module Tables{

                export interface IRowState{
                    row: number;
                    item?: any;
                    originalItem?: any;
                }

                /**
                 * Specifies what data is kept when removing the table.
                 * @enum {number}
                 * @example
                 * activeSheet.tables.add("Table1", 0, 0, 3, 3, GCTYPE.Spread.Sheets.Tables.TableThemes.dark1);
                 * activeSheet.getCell(0,0).text("Name");
                 * activeSheet.getCell(0,1).text("Value");
                 * activeSheet.getCell(0,2).text("T/F");
                 * activeSheet.getCell(1,0).text("AW");
                 * activeSheet.getCell(1,1).text("5");
                 * activeSheet.getCell(1,2).text("T");
                 * //button click
                 * $("#button1").click(function () {
                 *      var table  = activeSheet.tables.find(0,0);
                 *      activeSheet.tables.remove(table, GCTYPE.Spread.Sheets.Tables.TableRemoveOptions.keepData);
                 * });
                 */
                export enum TableRemoveOptions{
                    /**
                     *  Removes data and styles.
                     */
                    none= 0,
                    /**
                     *  Keeps values.
                     */
                    keepData= 1,
                    /**
                     *  Keeps styles.
                     */
                    keepStyle= 2
                }


                export class Table{
                    /**
                     * Represents a table that can be added in a sheet.
                     * @class
                     * @param {string} name The table name.
                     * @param {number} row The table row index.
                     * @param {number} col The table column index.
                     * @param {number} rowCount The table row count.
                     * @param {number} colCount The table column count.
                     * @param {GCTYPE.Spread.Sheets.Tables.TableTheme} style The table style.
                     * @param {Object} options The initialization options of the table.
                     * @param {boolean} [options.showHeader] - Whether to display a header.
                     * @param {boolean} [options.showFooter] - Whether to display a footer.
                     * @param {boolean} [options.useFooterDropDownList] - whether to use the footer dropdown list for a total row.
                     * @param {boolean} [options.showResizeHandle] - Whether to display the resize handle for table.
                     */
                    constructor(name?: string,  row?: number,  col?: number,  rowCount?: number,  colCount?: number,  style?: GCTYPE.Spread.Sheets.Tables.TableTheme);
                    /**
                     * Gets or sets the allowAutoExpandState of the table.
                     * @param {boolean} [allowAutoExpandState] The allowAutoExpandState of the table.
                     * @returns {boolean|GCTYPE.Spread.Sheets.Tables.Table} If there is no allowAutoExpandState set, returns the table allowAutoExpandState; otherwise, returns the table.
                     * @example
                     * table.allowAutoExpand();
                     * table.allowAutoExpand(true);
                     */
                    allowAutoExpand(allowAutoExpandState?: boolean): boolean | GCTYPE.Spread.Sheets.Tables.Table;
                    /**
                     * Gets or sets whether to generate columns automatically while binding to a data source.
                     * @param {boolean} value Whether to generate columns automatically while binding to a data source.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Tables.Table} If no value is set, returns whether to generate columns automatically while binding to a data source; otherwise, returns the table.
                     */
                    autoGenerateColumns(value?: boolean): any;
                    /**
                     * Gets or sets a value that indicates whether to display an alternating column style.
                     * @param {boolean} value Whether to display an alternating column style.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Tables.Table} If no value is set, returns whether to display an alternating column style; otherwise, returns the table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.bandColumns(true);
                     * sTable.bandRows(true);
                     */
                    bandColumns(value?: boolean): any;
                    /**
                     * Gets or sets a value that indicates whether to display an alternating row style.
                     * @param {boolean} value Whether to display an alternating row style.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Tables.Table} If no value is set, returns whether to display an alternating row style; otherwise, returns the table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.bandColumns(true);
                     * sTable.bandRows(true);
                     */
                    bandRows(value?: boolean): any;
                    /**
                     * Gets or sets the dataSource and binding columns and path for the table.
                     * @param {Array} columns The array of table column information with data fields and names. Each item is GCTYPE.Spread.Sheets.Tables.TableColumn.
                     * @param {string} value The binding path for binding in the table.
                     * @param {object} dataSource The data source for the table.
                     * @returns {GCTYPE.Spread.Sheets.Tables.Table} returns the table.
                     */
                    bind(columns: TableColumn[],  path?: string,  dataSource?: object): GCTYPE.Spread.Sheets.Tables.Table;
                    /**
                     * Binds the columns using the specified data fields.
                     * @param {Array.<GCTYPE.Spread.Sheets.Tables.TableColumn>} columns The array of table column information with data fields and names. Each item is GCTYPE.Spread.Sheets.Tables.TableColumn.
                     */
                    bindColumns(columns: GCTYPE.Spread.Sheets.Tables.TableColumn[]): void;
                    /**
                     * Gets or sets the binding path for cell-level binding in the table.
                     * @param {string} value The binding path for cell-level binding in the table.
                     * @returns {string | GCTYPE.Spread.Sheets.Tables.Table} If no value is set, returns the binding path for cell-level binding in the table; otherwise, returns the table.
                     */
                    bindingPath(value?: string): any;
                    /**
                     * Clears the dirty status from the current table.
                     * @example
                     * table.clearPendingChanges();
                     */
                    clearPendingChanges(): void;
                    /**
                     * Gets the cell range for the table data area.
                     * @returns {GCTYPE.Spread.Sheets.Range} The table data range.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableTheme.medium2);
                     * var drange = sTable.dataRange();
                     * alert(drange.row);
                     */
                    dataRange(): GCTYPE.Spread.Sheets.Range;
                    /**
                     * Delete count number columns in the table at the specified table col index.
                     * @param {number} col The index of the first column to delete, based on table index.
                     * @param {number} count The number of columns to delete.
                     * @returns {void}
                     * @example
                     * var table = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableTheme.medium2);
                     * table.deleteColumns(3, 1);
                     */
                    deleteColumns(col: number,  count: number): void;
                    /**
                     * Deletes the rows in this table at the specified table row index.
                     * @param {number} row The index of the first row to delete, based on table index.
                     * @param {number} count The number of rows to delete.
                     * @returns {void}
                     * @example
                     * var table = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableTheme.medium2);
                     * table.deleteRows(3, 1);
                     */
                    deleteRows(row: number,  count: number): void;
                    /**
                     * Gets or sets a value that table expand rows mode in binding case.
                     * @param {boolean} value Whether to expand by sheet or table insert/delete rows.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Tables.Table} If no value is set, returns whether to expand by sheet or table insert/delete rows; otherwise, returns the table.
                     * @example
                     * var spread = GCTYPE.Spread.Sheets.findControl("ss") || GCTYPE.Spread.Sheets.findControl("sampleDiv");
                     * var sheet = spread.getActiveSheet();
                     * var data = {
                     *     name: 'Jones', region: 'East',
                     *     sales: [
                     *         { orderDate: '1/6/2013', item: 'Pencil', units: 95, cost: 1.99 },
                     *         { orderDate: '4/1/2013', item: 'Binder', units: 60, cost: 4.99 },
                     *         { orderDate: '6/8/2013', item: 'Pen Set', units: 16, cost: 15.99 },
                     *         { orderDate: '8/1/2013', item: 'Pencil', units: 20, cost: 24.99 },
                     *         { orderDate: '10/8/2013', item: 'Binder', units: 31, cost: 16.99 }
                     *     ]
                     * };
                     * var table1 = sheet.tables.add('tableRecords', 0, 0, 4, 4);
                     * var table2 = sheet.tables.add('tableBelow', 4, 0, 4, 7);
                     * table1.bindingPath('sales');
                     * var dataSource = new GCTYPE.Spread.Sheets.Bindings.CellBindingSource(data);
                     * table1.expandBoundRows(true);
                     * sheet.setDataSource(dataSource);
                     */
                    expandBoundRows(value?: boolean): any;
                    /**
                     * Gets or sets whether the table column's filter button is displayed.
                     * @param {number} tableColumnIndex The table column index of the filter button.
                     * @param {boolean} value Whether the table column's filter button is displayed.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Tables.Table} The table column's filter button display state.
                     *  If no parameter is set, returns <c>false</c> if all filter buttons are invisible, otherwise, <c>true</c>.
                     *  If only a number is set, returns whether the specified table column' filter button is displayed.
                     *  If only a boolean that indicates whether to display filter buttons is set, applies to all filter buttons and returns the table.
                     *  If two parameters are provided, applies to the specified table columns' filter button and returns the table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableTheme.medium2);
                     * sTable.bandColumns(true);
                     * sTable.bandRows(true);
                     * sTable.filterButtonVisible(2, false);
                     * alert(sTable.filterButtonVisible(2));
                     */
                    filterButtonVisible(tableColumnIndex?: number,  value?: boolean): any;
                    /**
                     * Gets the footer index in the sheet.
                     * @returns {number} The footer index.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableTheme.medium2);
                     * sTable.showFooter(true);
                     * sTable.setColumnName(4, "SUM");
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     * var value = sTable.footerIndex();
                     * alert(value);
                     */
                    footerIndex(): number;
                    /**
                     * Gets the table footer formula with the specified index.
                     * @param {number} tableColumnIndex The column index of the table footer. The index is zero-based.
                     * @returns {string} The table footer formula.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableTheme.medium2);
                     * sTable.showFooter(true);
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     * var value = sTable.getColumnFormula(4);
                     * alert(value);
                     */
                    getColumnFormula(tableColumnIndex: number): string;
                    /**
                     * Gets the table header text with the specified table index.
                     * @param {number} tableColumnIndex The column index of the table header. The index is zero-based.
                     * @returns {string} The header text of the specified column by index.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableTheme.medium2);
                     * sTable.showFooter(true);
                     * sTable.setColumnName(4, "SUM");
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     * var value = sTable.getColumnName(4);
                     * alert(value);
                     */
                    getColumnName(tableColumnIndex: number): string;
                    /**
                     * Gets the table footer value with the specified index.
                     * @param {number} tableColumnIndex The column index of the table footer. The index is zero-based.
                     * @returns {string} The table footer value.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableTheme.medium2);
                     * sTable.showFooter(true);
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     * var value = sTable.getColumnValue(0);
                     * alert(value);
                     */
                    getColumnValue(tableColumnIndex: number): string;
                    /**
                     * Get array of dirty rows.
                     * @returns {Array.<Object>} The dirty rows collection. The item in array contains three properties, row: specifies table row index, item: specifies data item of current row, originalItem: specifies original data item of the row.
                     */
                    getDirtyRows(): GCTYPE.Spread.Sheets.Tables.IRowState[];
                    /**
                     * Gets the header index in the sheet.
                     * @returns {number} The header index.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableTheme.medium2);
                     * var hindex = sTable.headerIndex();
                     * alert(hindex);
                     */
                    headerIndex(): number;
                    /**
                     * Gets or sets a value that indicates whether to highlight the first column.
                     * @param {boolean} value Whether to highlight the first column.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Tables.Table} If no value is set, returns whether to highlight the first column; otherwise, returns the table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.highlightFirstColumn(true);
                     * sTable.highlightLastColumn(true);
                     */
                    highlightFirstColumn(value?: boolean): any;
                    /**
                     * Gets or sets a value that indicates whether to highlight the last column.
                     * @param {boolean} value Whether to highlight the last column.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Tables.Table} If no value is set, returns whether to highlight the last column; otherwise, returns the table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.highlightFirstColumn(true);
                     * sTable.highlightLastColumn(true);
                     */
                    highlightLastColumn(value?: boolean): any;
                    /**
                     * Insert count number columns in this table before the specified table col index.
                     * @param {number} col Column index at which to add the new columns, based on table index.
                     * @param {number} count The number of columns to add.
                     * @param {boolean} isInsertAfter Whether insert columns before the specified column index or after. By default, insert before.
                     * @returns {void}
                     * @example
                     * var table = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableTheme.medium2);
                     * table.insertColumns(3, 1);
                     */
                    insertColumns(col: number,  count: number,  isInsertAfter?: boolean): void;
                    /**
                     * Insert rows in this table before the specified table row index.
                     * @param {number} row The index of the starting row to insert, based on table index.
                     * @param {number} count The number of rows to add.
                     * @param {boolean} isInsertAfter Whether insert rows before the specified row index or after. By default, insert before.
                     * @returns {void}
                     * @example
                     * var table = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableTheme.medium2);
                     * table.insertRows(3, 1);
                     */
                    insertRows(row: number,  count: number,  isInsertAfter?: boolean): void;
                    /**
                     * Gets or sets the table name.
                     * @param {string} value The table name.
                     * @returns {string | GCTYPE.Spread.Sheets.Tables.Table} If no value is set, returns the table name; otherwise, returns the table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableTheme.medium2);
                     * var tname = sTable.name();
                     * alert(tname);
                     */
                    name(value?: string): any;
                    /**
                     * Gets the range for the entire table.
                     * @returns {GCTYPE.Spread.Sheets.Range} The whole table range.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableTheme.medium2);
                     * var drange = sTable.range();
                     * alert(drange.row);
                     */
                    range(): GCTYPE.Spread.Sheets.Range;
                    /**
                     * Gets the row filter for the table.
                     * @returns {GCTYPE.Spread.Sheets.Filter.HideRowFilter} The row filter.
                     */
                    rowFilter(): GCTYPE.Spread.Sheets.Filter.HideRowFilter;
                    /**
                     * Sets a formula to the table's data range with the specified index.
                     * @param {number} tableColumnIndex The column index of the table. The index is zero-based.
                     * @param {string} formula The data range formula.
                     * @returns {GCTYPE.Spread.Sheets.Tables.Table} The table.
                     * @example
                     * //This example uses a structured reference formula in the table.
                     * activeSheet.tables.add("Table1", 0, 0, 4, 3, GCTYPE.Spread.Sheets.Tables.TableTheme.dark1);
                     * activeSheet.getCell(0,0).text("Value1");
                     * activeSheet.getCell(0,1).text("Value2");
                     * activeSheet.getCell(0,2).text("Total");
                     * activeSheet.getCell(1,0).text("1");
                     * activeSheet.getCell(2,0).text("2");
                     * activeSheet.getCell(3,0).text("3");
                     * activeSheet.getCell(1,1).text("5");
                     * activeSheet.getCell(2,1).text("5");
                     * activeSheet.getCell(3,1).text("5");
                     * activeSheet.tables.findByName("Table1").setColumnDataFormula(2, "=[Value1]*[Value2]");
                     */
                    setColumnDataFormula(tableColumnIndex: number,  formula: string): GCTYPE.Spread.Sheets.Tables.Table;
                    /**
                     * Sets the table footer formula with the specified index.
                     * @param {number} tableColumnIndex The column index of the table footer. The index is zero-based.
                     * @param {string} formula The table footer formula.
                     * @returns {GCTYPE.Spread.Sheets.Tables.Table} The table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.showFooter(true);
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     */
                    setColumnFormula(tableColumnIndex: number,  formula: string): GCTYPE.Spread.Sheets.Tables.Table;
                    /**
                     * Sets the table header text with the specified table index.
                     * @param {number} tableColumnIndex The column index of the table header. The index is zero-based.
                     * @param {string} name The header text.
                     * @returns {GCTYPE.Spread.Sheets.Tables.Table} The table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.showFooter(true);
                     * sTable.setColumnName(4, "SUM");
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     */
                    setColumnName(tableColumnIndex: number,  name: string): GCTYPE.Spread.Sheets.Tables.Table;
                    /**
                     * Sets the table footer value with the specified index.
                     * @param {number} tableColumnIndex The column index of the table footer. The index is zero-based.
                     * @param {Object} value The table footer value.
                     * @returns {GCTYPE.Spread.Sheets.Tables.Table} The table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.showFooter(true);
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     */
                    setColumnValue(tableColumnIndex: number,  value: Object): GCTYPE.Spread.Sheets.Tables.Table;
                    /**
                     * Gets or sets a value that indicates whether to display a footer.
                     * @param {boolean} value Whether to display a footer.
                     * @param {boolean} isFooterInserted value decide the way of adding footer, whether insert total row or just override the next row. Remove footer is same.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Tables.Table} If no value is set, returns whether to display a footer; otherwise, returns the table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.showFooter(true);
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     */
                    showFooter(value?: boolean,  isFooterInserted?: boolean): any;
                    /**
                     * Gets or sets a value that indicates whether to display a header.
                     * @param {boolean} value Whether to display a header.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Tables.Table} If no value is set, returns whether to display a header; otherwise, returns the table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.showHeader(true);
                     */
                    showHeader(value?: boolean): any;
                    /**
                     * Gets or sets a value that indicates whether to display the resize handle for table.
                     * @param {boolean} value Whether to display the resize handle for table.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Tables.Table} If no value is set, returns whether to display the resize handle for table, by default is false; otherwise, returns the table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.showResizeHandle(true);
                     */
                    showResizeHandle(value?: boolean): any;
                    /**
                     * Gets or sets a style for the table.
                     * @param {GCTYPE.Spread.Sheets.Tables.TableTheme} value The style for the table.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme | GCTYPE.Spread.Sheets.Tables.Table} If no value is set, returns the table style; otherwise, returns the table.
                     */
                    style(value?: GCTYPE.Spread.Sheets.Tables.TableTheme): any;
                    /**
                     * Gets or sets a value that indicates whether to use the footer dropdown list for a total row.
                     * @param {boolean} value Whether to use the footer dropdown list.
                     * @returns {boolean | GCTYPE.Spread.Sheets.Tables.Table} If no value is set, returns whether to use the footer dropdown list for a total row, by default is false; otherwise, returns the table.
                     * @example
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, GCTYPE.Spread.Sheets.Tables.TableThemes.medium2);
                     * sTable.useFooterDropDownList(true);
                     */
                    useFooterDropDownList(value?: boolean): any;
                }

                export class TableColumn{
                    /**
                     * Represents the table column information.
                     * @class
                     * @param {number} id The table column ID.
                     * @param {string} dataField The table column data field.
                     * @param {string} name The table column name.
                     * @param {string} formatter The table column formatter.
                     * @param {GCTYPE.Spread.Sheets.CellTypes.Base} cellType The table column cellType.
                     * @param {Function} value The table column value convert function.
                     */
                    constructor(id: number,  dataField?: string,  name?: string,  formatter?: string,  cellType?: GCTYPE.Spread.Sheets.CellTypes.Base,  value?: Function);
                    /**
                     * Gets or sets the table column cellType for custom cell type.
                     * @param {GCTYPE.Spread.Sheets.CellTypes.Base} value The table column cellType.
                     * @returns {GCTYPE.Spread.Sheets.CellTypes.Base | GCTYPE.Spread.Sheets.Tables.TableColumn} If no value is set, returns the table column cellType; otherwise, returns the table column.
                     */
                    cellType(value?: GCTYPE.Spread.Sheets.CellTypes.Base): any;
                    /**
                     * Gets or sets the table column data field for accessing the table's data source.
                     * @param {string} value The table column data field.
                     * @returns {string | GCTYPE.Spread.Sheets.Tables.TableColumn} If no value is set, returns the table column data field; otherwise, returns the table column.
                     */
                    dataField(value?: string): any;
                    /**
                     * Gets or sets the table column formatter for format display value.
                     * @param {string} value The table column formatter.
                     * @returns {string | GCTYPE.Spread.Sheets.Tables.TableColumn} If no value is set, returns the table column formatter; otherwise, returns the table column.
                     */
                    formatter(value?: string): any;
                    /**
                     * Gets or sets the table column ID.
                     * @param {number} value The table column ID.
                     * @returns {number | GCTYPE.Spread.Sheets.Tables.TableColumn} If no value is set, returns the table column ID; otherwise, returns the table column.
                     */
                    id(value?: number): any;
                    /**
                     * Gets or sets the table column name for display.
                     * @param {string} value The table column name.
                     * @returns {string | GCTYPE.Spread.Sheets.Tables.TableColumn} If no value is set, returns the table column name; otherwise, returns the table column.
                     */
                    name(value?: string): any;
                    /**
                     * Gets or sets the table column value convert function for display value.
                     * @param {Function} value The table column value convert function.
                     * @returns {Function | GCTYPE.Spread.Sheets.Tables.TableColumn} If no value is set, returns the table column value convert function; otherwise, returns the table column.
                     */
                    value(value?: Function): Function;
                }

                export class TableManager{
                    /**
                     * Represents a table manager that can manage all tables in a sheet.
                     * @class
                     * @param {GCTYPE.Spread.Sheets.Worksheet} sheet The worksheet.
                     */
                    constructor(sheet: GCTYPE.Spread.Sheets.Worksheet);
                    /**
                     * Adds a range table with a specified size to the sheet.
                     * @param {string} name The table name.
                     * @param {number} row The row index.
                     * @param {number} column The column index.
                     * @param {number} rowCount The row count of the table.
                     * @param {number} columnCount The column count of the table.
                     * @param {GCTYPE.Spread.Sheets.Tables.TableTheme} style The style of the table.
                     * @param {Object} options The initialization options of the table.
                     * @param {boolean} [options.showHeader] - Whether to display a header.
                     * @param {boolean} [options.showFooter] - Whether to display a footer.
                     * @returns {GCTYPE.Spread.Sheets.Tables.Table} The new table instance.
                     * @example
                     * //This example adds a table.
                     * activeSheet.tables.add("Table1", 0, 0, 3, 3, GCTYPE.Spread.Sheets.Tables.TableThemes.dark1);
                     * activeSheet.getCell(0,0).text("Name");
                     * activeSheet.getCell(0,1).text("Value");
                     * activeSheet.getCell(0,2).text("T/F");
                     * activeSheet.getCell(1,0).text("AW");
                     * activeSheet.getCell(1,1).text("5");
                     * activeSheet.getCell(1,2).text("T");
                     */
                    add(name?: string,  row?: number,  column?: number,  rowCount?: number,  columnCount?: number,  style?: GCTYPE.Spread.Sheets.Tables.TableTheme): GCTYPE.Spread.Sheets.Tables.Table;
                    /**
                     * Adds a range table with a specified data source to the sheet.
                     * @param {string} name The table name.
                     * @param {number} row The row index.
                     * @param {number} column The column index.
                     * @param {object} dataSource The data source for the table.
                     * @param {GCTYPE.Spread.Sheets.Tables.TableTheme} style The style of the table.
                     * @param {Object} options The initialization options of the table.
                     * @param {boolean} [options.showHeader] - Whether to display a header.
                     * @param {boolean} [options.showFooter] - boolean Whether to display a footer.
                     * @returns {GCTYPE.Spread.Sheets.Tables.Table} The new table instance.
                     * @example
                     * var source = [
                     *                 { LastName: "Freehafer", FirstName: "Nancy", Title: "Sales Representative", Phone: "(123)555-0100"},
                     *                 { LastName: "Cencini", FirstName: "Andrew", Title: "Vice President, Sales", Phone: "(123)555-0101"},
                     *                 { LastName: "Kotas", FirstName: "Jan", Title: "Sales Representative", Phone: "(123)555-0102"},
                     *                 { LastName: "Sergienko", FirstName: "Mariya", Title: "Sales Representative", Phone: "(123)555-0103"},
                     *             ];
                     *  activeSheet.tables.addFromDataSource("Table1", 5, 2, source, GCTYPE.Spread.Sheets.Tables.TableThemes.dark1);
                     */
                    addFromDataSource(name: string,  row: number,  column: number,  dataSource: Object,  style: GCTYPE.Spread.Sheets.Tables.TableTheme): GCTYPE.Spread.Sheets.Tables.Table;
                    /**
                     * Gets all tables of the sheet.
                     * @returns {Array.<GCTYPE.Spread.Sheets.Tables.Table>} The GCTYPE.Spread.Sheets.Tables.Table array of table instances. The array is never null.
                     */
                    all(): GCTYPE.Spread.Sheets.Tables.Table[];
                    /**
                     * Gets the table of the specified cell.
                     * @param {number} row The row index.
                     * @param {number} column The column index.
                     * @returns {GCTYPE.Spread.Sheets.Tables.Table} The table instance if the cell belongs to a table; otherwise, <c>null</c>.
                     * @example
                     * //This example uses the find method.
                     * activeSheet.tables.add("Table1", 0, 0, 3, 3, GCTYPE.Spread.Sheets.Tables.TableThemes.dark1);
                     * activeSheet.getCell(0,0).text("Name");
                     * activeSheet.getCell(0,1).text("Value");
                     * activeSheet.getCell(0,2).text("T/F");
                     * activeSheet.getCell(1,0).text("AW");
                     * activeSheet.getCell(1,1).text("5");
                     * activeSheet.getCell(1,2).text("T");
                     * //button click
                     * $("#button1").click(function () {
                     *      var table  = activeSheet.tables.find(0,0);
                     *      activeSheet.tables.move(table, 3, 3);
                     * });
                     */
                    find(row: number,  column: number): GCTYPE.Spread.Sheets.Tables.Table;
                    /**
                     * Gets the table with a specified name.
                     * @param {string} name The table name.
                     * @returns {GCTYPE.Spread.Sheets.Tables.Table} The table instance if the cell belongs to a table; otherwise, <c>null</c>.
                     * @example
                     * //This example finds the table by name.
                     * var activeSheet = spread.getActiveSheet();
                     * activeSheet.tables.add("Table1", 0, 0, 3, 3, GCTYPE.Spread.Sheets.Tables.TableThemes.dark1);
                     * activeSheet.getCell(0,0).text("Name");
                     * activeSheet.getCell(0,1).text("Value");
                     * activeSheet.getCell(0,2).text("T/F");
                     * activeSheet.getCell(1,0).text("AW");
                     * activeSheet.getCell(1,1).text("5");
                     * activeSheet.getCell(1,2).text("T");
                     * // button click
                     * $("#button1").click(function () {
                     *      var table  = activeSheet.tables.findByName("Table1");
                     *      alert(table);
                     *      activeSheet.tables.move(table, 3, 3);
                     * });
                     */
                    findByName(name: string): GCTYPE.Spread.Sheets.Tables.Table;
                    /**
                     * Changes the table location.
                     * @param {GCTYPE.Spread.Sheets.Tables.Table|string} table The table instance or the table name.
                     * @param {number} row The new row index.
                     * @param {number} column The new column index.
                     * @example
                     * var activeSheet = spread.getActiveSheet();
                     * activeSheet.tables.add("Table1", 0, 0, 3, 3, GCTYPE.Spread.Sheets.Tables.TableThemes.dark1);
                     * activeSheet.getCell(0,0).text("Name");
                     * activeSheet.getCell(0,1).text("Value");
                     * activeSheet.getCell(0,2).text("T/F");
                     * activeSheet.getCell(1,0).text("AW");
                     * activeSheet.getCell(1,1).text("5");
                     * activeSheet.getCell(1,2).text("T");
                     * // button click
                     * $("#button1").click(function () {
                     *      var table  = activeSheet.tables.findByName("Table1");
                     *      alert(table);
                     *      activeSheet.tables.move(table, 3, 3);
                     * });
                     */
                    move(table: GCTYPE.Spread.Sheets.Tables.Table|string,  row: number,  column: number): void;
                    /**
                     * Removes a specified table.
                     * @param {GCTYPE.Spread.Sheets.Tables.Table|string} table The table instance or the table name.
                     * @param {GCTYPE.Spread.Sheets.Tables.TableRemoveOptions} options Specifies what data is kept when removing the table.
                     * @param {number} [options.none] Remove table, keep nothing.
                     * @param {number} [options.keepData] Remove table, keep table data.
                     * @param {number} [options.keepStyle] Remove table, keep table style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.Table}
                     * @example
                     * var table  = activeSheet.tables.find(0,0);
                     * activeSheet.tables.remove(table, GCTYPE.Spread.Sheets.Tables.TableRemoveOptions.keepData);
                     */
                    remove(table: GCTYPE.Spread.Sheets.Tables.Table,  options: GCTYPE.Spread.Sheets.Tables.TableRemoveOptions): GCTYPE.Spread.Sheets.Tables.Table;
                    /**
                     * Changes the table size.
                     * @param {GCTYPE.Spread.Sheets.Tables.Table|string} table The table or the table name.
                     * @param {GCTYPE.Spread.Sheets.Range} range The new table range. The headers must remain in the same row, and the resulting table range must overlap the original table range.
                     * @example
                     * //This example resizes the table.
                     * activeSheet.tables.add("Table1", 0, 0, 3, 3, GCTYPE.Spread.Sheets.Tables.TableThemes.dark1);
                     * activeSheet.getCell(0,0).text("Name");
                     * activeSheet.getCell(0,1).text("Value");
                     * activeSheet.getCell(0,2).text("T/F");
                     * activeSheet.getCell(1,0).text("AW");
                     * activeSheet.getCell(1,1).text("5");
                     * activeSheet.getCell(1,2).text("T");
                     * //button click
                     * $("#button1").click(function () {
                     *      var table  = activeSheet.tables.find(0,0);
                     *      activeSheet.tables.resize(table, new GCTYPE.Spread.Sheets.Range(0,0,4,4));
                     * });
                     */
                    resize(table: GCTYPE.Spread.Sheets.Tables.Table | string,  range: GCTYPE.Spread.Sheets.Range): void;
                }

                export class TableStyle{
                    /**
                     * Represents table style information.
                     * @class
                     * @param {string|GCTYPE.Spread.Sheets.IPatternFill|GCTYPE.Spread.Sheets.IGradientFill|GCTYPE.Spread.Sheets.IGradientPathFill} backColor The background color of the table.
                     * @param {string} foreColor The foreground color of the table.
                     * @param {string} font The font.
                     * @param {GCTYPE.Spread.Sheets.LineBorder} borderLeft The left border line of the table.
                     * @param {GCTYPE.Spread.Sheets.LineBorder} borderTop The top border line of the table.
                     * @param {GCTYPE.Spread.Sheets.LineBorder} borderRight The right border line of the table.
                     * @param {GCTYPE.Spread.Sheets.LineBorder} borderBottom The bottom border line of the table.
                     * @param {GCTYPE.Spread.Sheets.LineBorder} borderHorizontal The horizontal border line of the table.
                     * @param {GCTYPE.Spread.Sheets.LineBorder} borderVertical The vertical border line of the table.
                     * @param {GCTYPE.Spread.Sheets.TextDecorationType} textDecoration The text decoration of the table.
                     * @example
                     * //This example creates a table.
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tableStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle(
                     *     "black",
                     *     "white",
                     *     "bold 11pt arial",
                     *     new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin),
                     *     new GCTYPE.Spread.Sheets.LineBorder("red", GCTYPE.Spread.Sheets.LineStyle.thick),
                     *     new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.thin),
                     *     new GCTYPE.Spread.Sheets.LineBorder("blue", GCTYPE.Spread.Sheets.LineStyle.thick));
                     * tableStyle.headerRowStyle(tableStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    constructor(backColor?: string|GCTYPE.Spread.Sheets.IPatternFill|GCTYPE.Spread.Sheets.IGradientFill|GCTYPE.Spread.Sheets.IGradientPathFill,  foreColor?: string,  font?: string,  borderLeft?: GCTYPE.Spread.Sheets.LineBorder,  borderTop?: GCTYPE.Spread.Sheets.LineBorder,  borderRight?: GCTYPE.Spread.Sheets.LineBorder,  borderBottom?: GCTYPE.Spread.Sheets.LineBorder,  borderHorizontal?: GCTYPE.Spread.Sheets.LineBorder,  borderVertical?: GCTYPE.Spread.Sheets.LineBorder,  textDecoration?: GCTYPE.Spread.Sheets.TextDecorationType);
                    /**
                     * Indicates the background color.
                     * @type {string|GCTYPE.Spread.Sheets.IPatternFill|GCTYPE.Spread.Sheets.IGradientFill|GCTYPE.Spread.Sheets.IGradientPathFill}
                     * @example
                     * //This example creates a table.
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.headerRowStyle(tStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    backColor: string|GCTYPE.Spread.Sheets.IPatternFill|GCTYPE.Spread.Sheets.IGradientFill|GCTYPE.Spread.Sheets.IGradientPathFill;
                    /**
                     * Indicates the bottom border line of the table.
                     * @type {GCTYPE.Spread.Sheets.LineBorder}
                     * @example
                     * //This example creates a table.
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.headerRowStyle(tStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    borderBottom: GCTYPE.Spread.Sheets.LineBorder;
                    /**
                     * Indicates the horizontal border line of the table.
                     * @type {GCTYPE.Spread.Sheets.LineBorder}
                     * @example
                     * //This example sets the borderHorizontal property.
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderHorizontal = new GCTYPE.Spread.Sheets.LineBorder("red", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderVertical = new GCTYPE.Spread.Sheets.LineBorder("blue", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.firstRowStripStyle(tStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    borderHorizontal: GCTYPE.Spread.Sheets.LineBorder;
                    /**
                     * Indicates the left border line of the table.
                     * @type {GCTYPE.Spread.Sheets.LineBorder}
                     * @example
                     * //This example creates a table.
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.headerRowStyle(tStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    borderLeft: GCTYPE.Spread.Sheets.LineBorder;
                    /**
                     * Indicates the right border line of the table.
                     * @type {GCTYPE.Spread.Sheets.LineBorder}
                     * @example
                     * //This example creates a table.
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.headerRowStyle(tStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    borderRight: GCTYPE.Spread.Sheets.LineBorder;
                    /**
                     * Indicates the top border line of the table.
                     * @type {GCTYPE.Spread.Sheets.LineBorder}
                     * @example
                     * //This example creates a table.
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.headerRowStyle(tStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    borderTop: GCTYPE.Spread.Sheets.LineBorder;
                    /**
                     * Indicates the vertical border line of the table.
                     * @type {GCTYPE.Spread.Sheets.LineBorder}
                     * @example
                     * //This example sets the borderHorizontal property.
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderHorizontal = new GCTYPE.Spread.Sheets.LineBorder("red", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderVertical = new GCTYPE.Spread.Sheets.LineBorder("blue", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.firstRowStripStyle(tStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    borderVertical: GCTYPE.Spread.Sheets.LineBorder;
                    /**
                     * Indicates the font.
                     * @type {string}
                     * @example
                     * //This example creates a table.
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.headerRowStyle(tStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    font: string;
                    /**
                     * Indicates the foreground color.
                     * @type {string}
                     * @example
                     * //This example sets the borderHorizontal property.
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderHorizontal = new GCTYPE.Spread.Sheets.LineBorder("red", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderVertical = new GCTYPE.Spread.Sheets.LineBorder("blue", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.firstRowStripStyle(tStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    foreColor: string;
                    /**
                     * Indicates the text decoration of the table.
                     * @type {GCTYPE.Spread.Sheets.TextDecorationType}
                     */
                    textDecoration: GCTYPE.Spread.Sheets.TextDecorationType;
                }

                export class TableTheme{
                    /**
                     * Represents the table style settings.
                     * @class
                     * @example
                     * //This example creates a table.
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tableStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle(
                     *     "black",
                     *     "white",
                     *     "bold 11pt arial",
                     *     new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin),
                     *     new GCTYPE.Spread.Sheets.LineBorder("red", GCTYPE.Spread.Sheets.LineStyle.thick),
                     *     new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.thin),
                     *     new GCTYPE.Spread.Sheets.LineBorder("blue", GCTYPE.Spread.Sheets.LineStyle.thick));
                     * tableStyle.headerRowStyle(tableStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    constructor();
                    /**
                     * Gets or sets the size of the first alternating column.
                     * @param {number} value The size of the first alternating column.
                     * @returns {number | GCTYPE.Spread.Sheets.Tables.TableTheme} If no value is set, returns the size of the first alternating column; otherwise, returns the table theme.
                     * @example
                     * //This example creates a table.
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * //style
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.firstColumnStripSize(2);
                     * tableStyle.firstColumnStripStyle(tStyleInfo);
                     * var sTable = activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     * sTable.bandColumns(true);
                     */
                    firstColumnStripSize(value?: number): any;
                    /**
                     * Gets or sets the style of the first alternating column.
                     * @param {GCTYPE.Spread.Sheets.Tables.TableStyle} value The style of the first alternating column.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableStyle | GCTYPE.Spread.Sheets.Tables.TableTheme} If no value is set, returns the style of the first alternating column; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.firstColumnStripSize(2);
                     * tableStyle.firstColumnStripStyle(tStyleInfo);
                     * var sTable = activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     * sTable.bandColumns(true);
                     */
                    firstColumnStripStyle(value?: GCTYPE.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the style of the first footer cell.
                     * @param {GCTYPE.Spread.Sheets.Tables.TableStyle} value The style of the first footer cell.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableStyle | GCTYPE.Spread.Sheets.Tables.TableTheme} If no value is set, returns the style of the first footer cell; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.lastFooterCellStyle(tStyleInfo);
                     * tableStyle.firstFooterCellStyle(tStyleInfo);
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, tableStyle);
                     * sTable.showFooter(true);
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     * sTable.highlightFirstColumn(true);
                     * sTable.highlightLastColumn(true);
                     */
                    firstFooterCellStyle(value?: GCTYPE.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the style of the first header cell.
                     * @param {GCTYPE.Spread.Sheets.Tables.TableStyle} value The style of the first header cell.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableStyle | GCTYPE.Spread.Sheets.Tables.TableTheme} If no value is set, returns the style of the first header cell; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GCTYPE.Spread.Sheets.TableStyle();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.TableStyleInfo("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.TableStyleInfo();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.firstHeaderCellStyle(tStyleInfo);
                     * tableStyle.lastHeaderCellStyle(tStyleInfo);
                     * var sTable = activeSheet.addTable("table1", 1, 1, 10, 5, tableStyle);
                     * sTable.highlightFirstColumn(true);
                     * sTable.highlightLastColumn(true);
                     */
                    firstHeaderCellStyle(value?: GCTYPE.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the size of the first alternating row.
                     * @param {number} value The size of the first alternating row.
                     * @returns {number | GCTYPE.Spread.Sheets.Tables.TableTheme} If no value is set, returns the size of the first alternating row; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.firstRowStripSize(2);
                     * tableStyle.firstRowStripStyle(tStyleInfo);
                     * activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     */
                    firstRowStripSize(value?: number): any;
                    /**
                     * Gets or sets the first alternating row style.
                     * @param {GCTYPE.Spread.Sheets.Tables.TableStyle} value The first alternating row style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableStyle | GCTYPE.Spread.Sheets.Tables.TableTheme} If no value is set, returns the first alternating row style; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.firstRowStripSize(2);
                     * tableStyle.firstRowStripStyle(tStyleInfo);
                     * activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     */
                    firstRowStripStyle(value?: GCTYPE.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the default style of the footer area.
                     * @param {GCTYPE.Spread.Sheets.Tables.TableStyle} value The default style of the footer area.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableStyle | GCTYPE.Spread.Sheets.Tables.TableTheme} If no value is set, returns the default style of the footer area; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.footerRowStyle(tStyleInfo);
                     * var sTable = activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     * sTable.showFooter(true);
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     */
                    footerRowStyle(value?: GCTYPE.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the default style of the header area.
                     * @param {GCTYPE.Spread.Sheets.Tables.TableStyle} value The default style of the header area.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableStyle | GCTYPE.Spread.Sheets.Tables.TableTheme} If no value is set, returns the default style of the header area; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tableStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle(
                     *     "black",
                     *     "white",
                     *     "bold 11pt arial",
                     *     new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin),
                     *     new GCTYPE.Spread.Sheets.LineBorder("red", GCTYPE.Spread.Sheets.LineStyle.thick),
                     *     new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.thin),
                     *     new GCTYPE.Spread.Sheets.LineBorder("blue", GCTYPE.Spread.Sheets.LineStyle.thick));
                     * tableStyle.headerRowStyle(tableStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    headerRowStyle(value?: GCTYPE.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the style of the first column.
                     * @param {GCTYPE.Spread.Sheets.Tables.TableStyle} value The style of the first column.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableStyle | GCTYPE.Spread.Sheets.Tables.TableTheme} If no value is set, returns the style of the first column; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.highlightFirstColumnStyle(tStyleInfo);
                     * var sTable = activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     * sTable.highlightFirstColumn(true);
                     * sTable.highlightLastColumn(true);
                     */
                    highlightFirstColumnStyle(value?: GCTYPE.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the style of the last column.
                     * @param {GCTYPE.Spread.Sheets.Tables.TableStyle} value The style of the last column.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableStyle | GCTYPE.Spread.Sheets.Tables.TableTheme} If no value is set, returns the style of the last column; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * //style
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.highlightLastColumnStyle(tStyleInfo);
                     * var sTable = activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     * sTable.highlightLastColumn(true);
                     */
                    highlightLastColumnStyle(value?: GCTYPE.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the style of the last footer cell.
                     * @param {GCTYPE.Spread.Sheets.Tables.TableStyle} value The style of the last footer cell.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableStyle | GCTYPE.Spread.Sheets.Tables.TableTheme} If no value is set, returns the style of the last footer cell; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.lastFooterCellStyle(tStyleInfo);
                     * tableStyle.firstFooterCellStyle(tStyleInfo);
                     * var sTable = activeSheet.tables.add("table1", 1, 1, 10, 5, tableStyle);
                     * sTable.showFooter(true);
                     * //set footer value
                     * sTable.setColumnValue(0, "Total");
                     * //set footer formula
                     * sTable.setColumnFormula(4, "SUM(F3:F11)");
                     * sTable.highlightFirstColumn(true);
                     * sTable.highlightLastColumn(true);
                     */
                    lastFooterCellStyle(value?: GCTYPE.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the style of the last header cell.
                     * @param {GCTYPE.Spread.Sheets.Tables.TableStyle} value The style of the last header cell.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableStyle | GCTYPE.Spread.Sheets.Tables.TableTheme} If no value is set, returns the style of the last header cell; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GCTYPE.Spread.Sheets.TableStyle();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.TableStyleInfo("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.TableStyleInfo();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.firstHeaderCellStyle(tStyleInfo);
                     * tableStyle.lastHeaderCellStyle(tStyleInfo);
                     * var sTable = activeSheet.addTable("table1", 1, 1, 10, 5, tableStyle);
                     * sTable.highlightFirstColumn(true);
                     * sTable.highlightLastColumn(true);
                     */
                    lastHeaderCellStyle(value?: GCTYPE.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the name of the style.
                     * @param {string} value The name of the style.
                     * @returns {string | GCTYPE.Spread.Sheets.Tables.TableTheme} If no value is set, returns the name of the style; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GCTYPE.Spread.Sheets.TableStyle();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.TableStyleInfo("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.TableStyleInfo();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.name("tstyle");
                     * tableStyle.firstColumnStripSize(2);
                     * tableStyle.firstColumnStripStyle(tStyleInfo);
                     * var sTable = activeSheet.addTable("Custom", 1, 1, 10, 5, tableStyle);
                     * sTable.bandColumns(true);
                     */
                    name(value?: string): any;
                    /**
                     * Gets or sets the size of the second alternating column.
                     * @param {number} value The size of the second alternating column.
                     * @returns {number | GCTYPE.Spread.Sheets.Tables.TableTheme} If no value is set, returns the size of the second alternating column; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.secondColumnStripSize(2);
                     * tableStyle.secondColumnStripStyle(tStyleInfo);
                     * var sTable = activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     * sTable.bandColumns(true);
                     */
                    secondColumnStripSize(value?: number): any;
                    /**
                     * Gets or sets the style of the second alternating column.
                     * @param {GCTYPE.Spread.Sheets.Tables.TableStyle} value The style of the second alternating column.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableStyle | GCTYPE.Spread.Sheets.Tables.TableTheme} If no value is set, returns the style of the second alternating column; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.secondColumnStripSize(2);
                     * tableStyle.secondColumnStripStyle(tStyleInfo);
                     * var sTable = activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     * sTable.bandColumns(true);
                     */
                    secondColumnStripStyle(value?: GCTYPE.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the size of the second alternating row.
                     * @param {number} value The size of the second alternating row.
                     * @returns {number | GCTYPE.Spread.Sheets.Tables.TableTheme} If no value is set, returns the size of the second alternating row; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.secondRowStripSize(2);
                     * tableStyle.secondRowStripStyle(tStyleInfo);
                     * activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     */
                    secondRowStripSize(value?: number): any;
                    /**
                     * Gets or sets the second alternating row style.
                     * @param {GCTYPE.Spread.Sheets.Tables.TableStyle} value The second alternating row style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableStyle | GCTYPE.Spread.Sheets.Tables.TableTheme} If no value is set, returns the second alternating row style; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle();
                     * tStyleInfo.backColor = "green";
                     * tStyleInfo.foreColor = "red";
                     * tStyleInfo.borderBottom = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderLeft = new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.medium);
                     * tStyleInfo.borderTop = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.borderRight = new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin);
                     * tStyleInfo.font = "bold 11pt arial";
                     * tableStyle.secondRowStripSize(2);
                     * tableStyle.secondRowStripStyle(tStyleInfo);
                     * activeSheet.tables.add("Custom", 1, 1, 10, 5, tableStyle);
                     */
                    secondRowStripStyle(value?: GCTYPE.Spread.Sheets.Tables.TableStyle): any;
                    /**
                     * Gets or sets the default style of the data area.
                     * @param {GCTYPE.Spread.Sheets.Tables.TableStyle} value The default style of the data area.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableStyle | GCTYPE.Spread.Sheets.Tables.TableTheme} If no value is set, returns the default style of the data area; otherwise, returns the table theme.
                     * @example
                     * var tableStyle = new GCTYPE.Spread.Sheets.Tables.TableTheme();
                     * var thinBorder = new GCTYPE.Spread.Sheets.LineBorder("black", GCTYPE.Spread.Sheets.LineStyle.dotted);
                     * tableStyle.wholeTableStyle(new GCTYPE.Spread.Sheets.Tables.TableStyle("aliceblue", "green", "bold 10pt arial", thinBorder, thinBorder, thinBorder, thinBorder, thinBorder, thinBorder));
                     * var tableStyleInfo = new GCTYPE.Spread.Sheets.Tables.TableStyle(
                     *     "black",
                     *     "white",
                     *     "bold 11pt arial",
                     *     new GCTYPE.Spread.Sheets.LineBorder("green", GCTYPE.Spread.Sheets.LineStyle.thin),
                     *     new GCTYPE.Spread.Sheets.LineBorder("red", GCTYPE.Spread.Sheets.LineStyle.thick),
                     *     new GCTYPE.Spread.Sheets.LineBorder("yellow", GCTYPE.Spread.Sheets.LineStyle.thin),
                     *     new GCTYPE.Spread.Sheets.LineBorder("blue", GCTYPE.Spread.Sheets.LineStyle.thick));
                     * tableStyle.headerRowStyle(tableStyleInfo);
                     * var table = activeSheet.tables.add("table1", 1, 1, 5, 5, tableStyle);
                     */
                    wholeTableStyle(value?: GCTYPE.Spread.Sheets.Tables.TableStyle): any;
                }

                export class TableThemes{
                    /**
                     * Represents a built-in table theme collection.
                     * @class
                     */
                    constructor();
                    /**
                     * Gets the dark1 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark1: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark10 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark10: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark11 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark11: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark2 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark2: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark3 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark3: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark4 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark4: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark5 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark5: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark6 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark6: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark7 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark7: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark8 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark8: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the dark9 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static dark9: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light1 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light1: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light10 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light10: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light11 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light11: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light12 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light12: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light13 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light13: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light14 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light14: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light15 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light15: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light16 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light16: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light17 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light17: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light18 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light18: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light19 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light19: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light2 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light2: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light20 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light20: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light21 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light21: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light3 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light3: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light4 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light4: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light5 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light5: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light6 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light6: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light7 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light7: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light8 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light8: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the light9 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static light9: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium1 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium1: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium10 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium10: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium11 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium11: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium12 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium12: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium13 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium13: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium14 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium14: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium15 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium15: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium16 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium16: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium17 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium17: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium18 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium18: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium19 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium19: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium2 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium2: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium20 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium20: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium21 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium21: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium22 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium22: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium23 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium23: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium24 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium24: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium25 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium25: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium26 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium26: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium27 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium27: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium28 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium28: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium3 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium3: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium4 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium4: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium5 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium5: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium6 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium6: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium7 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium7: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium8 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium8: GCTYPE.Spread.Sheets.Tables.TableTheme;
                    /**
                     * Gets the medium9 style.
                     * @returns {GCTYPE.Spread.Sheets.Tables.TableTheme}
                     */
                    static medium9: GCTYPE.Spread.Sheets.Tables.TableTheme;
                }
            }

            module TableSheet{

                export interface IActionButtonsOptions{
                    remove?: GCTYPE.Spread.Sheets.TableSheet.IButtonOptions;
                    save?: GCTYPE.Spread.Sheets.TableSheet.IButtonOptions;
                    reset?: GCTYPE.Spread.Sheets.TableSheet.IButtonOptions;
                }


                export interface IActionColumnOptions{
                    visible?: boolean;
                    title?: string;
                    width?: number;
                    actionButtons?: GCTYPE.Spread.Sheets.TableSheet.IActionButtonsOptions;
                }


                export interface IButtonOptions{
                    visible?: boolean | "auto";
                    title?: string;
                    icon?: GCTYPE.Spread.Sheets.ButtonImageType;
                }


                export interface ITableSheetOptions{
                    allowAddNew?: boolean; //  Whether to allow to add new empty row.
                    alternatingRowStyles?: GCTYPE.Spread.Sheets.Style[]; // Defines the alternating row styles.
                }

                /**
                 * Represents which row action is operated.
                 * @enum {number}
                 */
                export enum ActionType{
                    /**
                     *  The action that removes a row.
                     */
                    remove= 0,
                    /**
                     *  The action that saves a row.
                     */
                    save= 1,
                    /**
                     *  The action that resets a row.
                     */
                    reset= 2,
                    /**
                     *  The action that adds a new empty row.
                     */
                    addNewEmptyRow= 3
                }


                export class ActionColumn{
                    /**
                     * Represents the action column of the table sheet.
                     * @class
                     */
                    constructor();
                    /**
                     * Gets or sets the options of the action column.
                     * @param {Object} newOptions - The options of the action column.
                     * @param {boolean} newOptions.visible - The visible of the action column.
                     * @param {string} newOptions.title - The title of the action column.
                     * @param {number} newOptions.width - The width of the action column.
                     * @param {Object} newOptions.actionButtons - The action buttons of the action column.
                     * @param {Object} newOptions.actionButtons.remove - The remove button of the action column.
                     * @param {boolean} newOptions.actionButtons.remove.visible - The visible of the remove button of the action column, which could be true(always show), false(always hide), "auto"(only show when the button is enabled).
                     * @param {string} newOptions.actionButtons.remove.title - The title of the remove button of the action column.
                     * @param {GCTYPE.Spread.Sheets.ButtonImageType} newOptions.actionButtons.remove.icon - The icon of the remove button of the action column.
                     * @param {Object} newOptions.actionButtons.save - The save button of the action column.
                     * @param {boolean} newOptions.actionButtons.save.visible - The visible of the save button of the action column, which could be true(always show), false(always hide), "auto"(only show when the button is enabled).
                     * @param {string} newOptions.actionButtons.save.title - The title of the save button of the action column.
                     * @param {GCTYPE.Spread.Sheets.ButtonImageType} newOptions.actionButtons.save.icon - The icon of the save button of the action column.
                     * @param {Object} newOptions.actionButtons.reset - The reset button of the action column.
                     * @param {boolean} newOptions.actionButtons.reset.visible - The visible of the reset button of the action column, which could be true(always show), false(always hide), "auto"(only show when the button is enabled).
                     * @param {string} newOptions.actionButtons.reset.title - The title of the reset button of the action column.
                     * @param {GCTYPE.Spread.Sheets.ButtonImageType} newOptions.actionButtons.reset.icon - The icon of the reset button of the action column.
                     * @returns {Object} Returns the options of the action column when it is invoked without any arguments, which has same structure of above newOptions parameter.
                     * @example
                     * //This example changes the width and button titles of the action column.
                     * tableSheet.actionColumn.options({
                     *     visible: true,
                     *     title: "Actions",
                     *     width: 90,
                     *     actionButtons: {
                     *         remove: {
                     *             visible: true,
                     *             title: "",
                     *             icon: GCTYPE.Spread.Sheets.ButtonImageType.minus
                     *         },
                     *         save: {
                     *             visible: true,
                     *             title: "",
                     *             icon: GCTYPE.Spread.Sheets.ButtonImageType.ok
                     *         },
                     *         reset: {
                     *             visible: true,
                     *             title: "",
                     *             icon: GCTYPE.Spread.Sheets.ButtonImageType.clear
                     *         }
                     *     }
                     * });
                     */
                    options(newOptions?: GCTYPE.Spread.Sheets.TableSheet.IActionColumnOptions): GCTYPE.Spread.Sheets.TableSheet.IActionColumnOptions;
                }

                export class TableSheet{
                    /**
                     * Represents a table sheet with the specified name, data view and options setting.
                     * @class
                     * @param {string} [name] - The table sheet name.
                     * @param {GCTYPE.Data.View} [dataView] - The table sheet data view.
                     * @param {Object} [options] - The initialization options.<br />
                     * @param {boolean} [options.allowAddNew] - Whether to allow to add new empty row.<br />
                     * @param {Array<GCTYPE.Spread.Sheets.Style>} [options.alternatingRowStyles] - Defines the alternating row styles.<br />
                     * @example
                     * //This example creates a empty TableSheet.
                     * var tableSheet = new GCTYPE.Spread.Sheets.TableSheet.TableSheet();
                     * spread.addSheetTab(0, tableSheet);
                     *
                     * //This example creates a TableSheet with name.
                     * var tableSheet = new GCTYPE.Spread.Sheets.TableSheet.TableSheet("TableSheet1");
                     * spread.addSheetTab(0, tableSheet);
                     *
                     * //This example creates a TableSheet with name and data source.
                     * var dataManager = new GCTYPE.Data.DataManager();
                     * var myTable = dataManager.addTable("myTable", {
                     *     remote: {
                     *         read: {
                     *             url: 'https://demodata.grapecity.com/northwind/api/v1/Orders'
                     *         }
                     *     }
                     * });
                     * myTable.fetch().then(function() {
                     *     var myView = myTable.addView("myView");
                     *     var tableSheet = new GCTYPE.Spread.Sheets.TableSheet.TableSheet("TableSheet1", myView);
                     *     spread.addSheetTab(0, tableSheet);
                     * });
                     *
                     * //This example creates a TableSheet with name and options.
                     * var alternatingRowStyles = [];
                     * var tableSheet = new GCTYPE.Spread.Sheets.TableSheet.TableSheet("TableSheet1", null, {allowAddNew: false, alternatingRowStyles: alternatingRowStyles});
                     * spread.addSheetTab(0, tableSheet);
                     */
                    constructor(name?: string,  dataView?: GCTYPE.Data.View,  options?: GCTYPE.Spread.Sheets.TableSheet.ITableSheetOptions);
                    /**
                     * Represents the action column of the table sheet.
                     * @type {GCTYPE.Spread.Sheets.TableSheet.ActionColumn}
                     * @example
                     * //This example changes a TableSheet's action column options.
                     * var options = tableSheet.actionColumn.options();
                     * options.visible = false;
                     * tableSheet.actionColumn.options(options);
                     */
                    actionColumn: GCTYPE.Spread.Sheets.TableSheet.ActionColumn;
                    /**
                     * Represents the options of the table sheet.
                     * @type {Object}
                     * @property {boolean} allowAddNew - Whether to allow to add new empty row.<br />
                     * @property {Array<GCTYPE.Spread.Sheets.Style>} alternatingRowStyles - Defines the alternating row styles.<br />
                     * @example
                     * //This example changes a TableSheet's options.
                     * tableSheet.options.allowAddNew = false;
                     * tableSheet.options.alternatingRowStyles = [new GCTYPE.Spread.Sheets.Style("lightyellow"), new GCTYPE.Spread.Sheets.Style("lightgreen")];
                     */
                    options: GCTYPE.Spread.Sheets.TableSheet.ITableSheetOptions;
                    /**
                     * Add a specific column state rule with a specific style. The old state rule will be replaced when add a same new state rule.
                     * @param {GCTYPE.Spread.Sheets.StatesType} state - The column state. The state dosen't support "invalid", "dirty" and "edit".
                     * @param {GCTYPE.Spread.Sheets.Style} style - The style for the specific state.
                     * @returns {void}
                     * @example
                     * //This example adds column hover state.
                     * tableSheet.addColumnStateRule(GCTYPE.Spread.Sheets.StatesType.hover, new GCTYPE.Spread.Sheets.Style("lightgreen"));
                     */
                    addColumnStateRule(state: GCTYPE.Spread.Sheets.StatesType,  style: GCTYPE.Spread.Sheets.Style): void;
                    /**
                     * Adds a new row to table sheet.
                     * @param {Object} rowData - The row data.
                     * @returns {void}
                     * @example
                     * //This example adds a new row with data.
                     * tableSheet.addRow({id: 8, name: "grapecity"});
                     */
                    addRow(rowData: any): void;
                    /**
                     * Add a specific row state rule with a specific style. The old state rule will be replaced when add a same new state rule.
                     * @param {GCTYPE.Spread.Sheets.StatesType} state - The row state. The state dosen't support "invalid", "readonly" and "edit".
                     * @param {GCTYPE.Spread.Sheets.Style} style - The style for the specific state.
                     * @returns {void}
                     * @example
                     * //This example adds row hover state.
                     * tableSheet.addRowStateRule(GCTYPE.Spread.Sheets.StatesType.hover, new GCTYPE.Spread.Sheets.Style("lightgreen"));
                     */
                    addRowStateRule(state: GCTYPE.Spread.Sheets.StatesType,  style: GCTYPE.Spread.Sheets.Style): void;
                    /**
                     * Cancels the changes of data manager in batch mode.
                     * @example
                     * //This example cancel changes manually in batch mode.
                     * tableSheet.cancelChanges();
                     */
                    cancelChanges(): void;
                    /**
                     * Gets the data view of table sheet.
                     * @returns {GCTYPE.Data.View} Returns the data view.
                     * @example
                     * //This example gets the data source.
                     * tableSheet.getDataView();
                     */
                    getDataView(): GCTYPE.Data.View;
                    /**
                     * Gets or sets the print information for the table sheet.
                     * @param {GCTYPE.Spread.Sheets.Print.PrintInfo} [value] The print information for the table sheet.
                     * @returns {GCTYPE.Spread.Sheets.Print.PrintInfo | GCTYPE.Spread.Sheets.TableSheet.TableSheet} If no value is set, returns the print information for the table sheet; otherwise, returns the table sheet.
                     * @example
                     * //This example sets print info.
                     * var printInfo = tableSheet.printInfo();
                     * printInfo.bestFitRows(true);
                     * printInfo.bestFitColumns(true);
                     * tableSheet.printInfo(printInfo);
                     */
                    printInfo(value?: GCTYPE.Spread.Sheets.Print.PrintInfo): any;
                    /**
                     * Remove the specific column state rule.
                     * @param {GCTYPE.Spread.Sheets.StatesType} state - The column state. The state dosen't support "invalid", "dirty" and "edit".
                     * @returns {void}
                     * @example
                     * //This example removes column hover state.
                     * tableSheet.removeColumnStateRule(GCTYPE.Spread.Sheets.StatesType.hover);
                     */
                    removeColumnStateRule(state: GCTYPE.Spread.Sheets.StatesType): void;
                    /**
                     * Removes the specified row from table sheet.
                     * @param {number} row - The row index.
                     * @returns {void}
                     * @example
                     * //This example removes a row by specified index.
                     * tableSheet.removeRow(8);
                     */
                    removeRow(row: number): void;
                    /**
                     * Remove the specific row state rule.
                     * @param {GCTYPE.Spread.Sheets.StatesType} state - The row state. The state dosen't support "invalid", "readonly" and "edit".
                     * @returns {void}
                     * @example
                     * //This example removes row hover state.
                     * tableSheet.removeRowStateRule(GCTYPE.Spread.Sheets.StatesType.hover);
                     */
                    removeRowStateRule(state: GCTYPE.Spread.Sheets.StatesType): void;
                    /**
                     * Resets the changes of the specified row of table sheet.
                     * @param {number} row - The row index.
                     * @returns {void}
                     * @example
                     * //This example resets a row by specified index.
                     * tableSheet.resetRow(8);
                     */
                    resetRow(row: number): void;
                    /**
                     * Saves the changes of the specified row of table sheet to data manager, including updated row or and inserted row.
                     * @param {number} row - The row index.
                     * @returns {void}
                     * @example
                     * //This example saves a row by specified index.
                     * tableSheet.saveRow(8);
                     */
                    saveRow(row: number): void;
                    /**
                     * Sets the data view of table sheet.
                     * @param {GCTYPE.Data.View} dataView - The data view to bind.
                     * @example
                     * //This example sets the data source.
                     * var dataManager = new GCTYPE.Data.DataManager();
                     * var myTable = dataManager.addTable("myTable", {
                     *     remote: {
                     *         read: {
                     *             url: 'https://demodata.grapecity.com/northwind/api/v1/Orders'
                     *         }
                     *     }
                     * });
                     * myTable.fetch().then(function() {
                     *     var myView = myTable.addView("myView");
                     *     tableSheet.setDataView(myView);
                     * });
                     */
                    setDataView(dataView: GCTYPE.Data.View): void;
                    /**
                     * Sets the default height in pixels for the all rows in the viewport area.
                     * @param {number} value The height in pixels.
                     * @param {GCTYPE.Spread.Sheets.SheetArea} [sheetArea] The sheet area.
                     * @example
                     * //This example sets the default row height in pixels.
                     * tableSheet.setDefaultRowHeight(50);
                     */
                    setDefaultRowHeight(value: number,  sheetArea?: GCTYPE.Spread.Sheets.SheetArea): void;
                    /**
                     * Submits the changes of data manager to server in batch mode, including updated rows, inserted rows and deleted rows.
                     * @example
                     * //This example submit changes manually in batch mode.
                     * tableSheet.submitChanges();
                     */
                    submitChanges(): void;
                    /**
                     * Pin or unpin columns with specified column index array.
                     * @param {number} index - The array of column indexes to do pin or unpin.
                     * @returns {number} Returns the count of the pinned columns.
                     * @example
                     * //This example pin several columns.
                     * tableSheet.togglePinnedColumns([1,2,4]);
                     */
                    togglePinnedColumns(index: number[]): void;
                    /**
                     * Pin or unpin rows with specified row index array.
                     * @param {number} index - The array of row indexes to do pin or unpin.
                     * @returns {number} Returns the count of the pinned rows.
                     * @example
                     * //This example pin several rows.
                     * tableSheet.togglePinnedRows([1,2,4]);
                     */
                    togglePinnedRows(indexes: number[]): void;
                }
            }

            module Touch{

                export class TouchToolStrip{
                    /**
                     * Represents a toolbar.
                     * @class
                     * @param {GCTYPE.Spread.Sheets.Workbook} workbook The Spread object.
                     * @param {HTMLElement} host The host DOM element.
                     */
                    constructor(workbook: GCTYPE.Spread.Sheets.Workbook,  host: HTMLElement);
                    /**
                     * Adds an item to the touch toolbar.
                     * @param {GCTYPE.Spread.Sheets.Touch.TouchToolStripSeparator | GCTYPE.Spread.Sheets.Touch.TouchToolStripItem} item The item to be added.
                     * @remarks The item to be added can be a toolbar item or a line separator.
                     * @example
                     * //This example adds a custom item.
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripItem("C", "Delete", "tsoutline.png", function(){ }))
                     * spread.touchToolStrip.getItem("C").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.imageAreaHeight(30);
                     * spread.touchToolStrip.itemHeight(80);
                     * spread.touchToolStrip.itemWidth(50);
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    add(item: GCTYPE.Spread.Sheets.Touch.TouchToolStripSeparator | GCTYPE.Spread.Sheets.Touch.TouchToolStripItem): void;
                    /**
                     * Clears all items in the toolbar.
                     * @example
                     * //This example uses the clear method.
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripItem("C", "Delete", "tsoutline.png", function(){ }))
                     * spread.touchToolStrip.getItem("C").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.imageAreaHeight(30);
                     * spread.touchToolStrip.itemHeight(80);
                     * spread.touchToolStrip.itemWidth(50);
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripSeparator());
                     * spread.touchToolStrip.clear();
                     */
                    clear(): void;
                    /**
                     * Closes the toolbar.
                     */
                    close(): void;
                    /**
                     * Gets the item with the specified name.
                     * @param {string} name The item name.
                     * @returns {GCTYPE.Spread.Sheets.Touch.TouchToolStripSeparator|GCTYPE.Spread.Sheets.Touch.TouchToolStripItem} If the item exists in the toolbar, the item is returned; otherwise, returns undefined.
                     * @example
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripItem("Cut", "Delete", "cut.png", function(){ }))
                     * spread.touchToolStrip.getItem("Cut").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    getItem(name: string): any;
                    /**
                     * Gets all the items that belong to the toolbar.
                     * @returns {Array.<GCTYPE.Spread.Sheets.Touch.TouchToolStripSeparator>|Array.<GCTYPE.Spread.Sheets.Touch.TouchToolStripItem>} An array that contains all the items in the toolbar.
                     */
                    getItems(): any;
                    /**
                     * Gets or sets the image area height.
                     * @param {number} height The image area height.
                     * @returns {number | GCTYPE.Spread.Sheets.Touch.TouchToolStrip} If no value is set, returns the image area height; otherwise, returns the toolbar.
                     * @example
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripItem("C", "Delete", "tsoutline.png", function(){ }))
                     * spread.touchToolStrip.getItem("C").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.imageAreaHeight(30);
                     * spread.touchToolStrip.itemHeight(80);
                     * spread.touchToolStrip.itemWidth(50);
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    imageAreaHeight(height?: number): any;
                    /**
                     * Gets or sets the toolbar item height.
                     * @param {number} height The toolbar item height.
                     * @returns {number | GCTYPE.Spread.Sheets.Touch.TouchToolStrip} If no value is set, returns the toolbar item height; otherwise, returns the toolbar.
                     * @example
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripItem("C", "Delete", "tsoutline.png", function(){ }))
                     * spread.touchToolStrip.getItem("C").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.imageAreaHeight(30);
                     * spread.touchToolStrip.itemHeight(80);
                     * spread.touchToolStrip.itemWidth(50);
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    itemHeight(height?: number): any;
                    /**
                     * Gets or sets the toolbar item width.
                     * @param {number} width The toolbar item width.
                     * @returns {number | GCTYPE.Spread.Sheets.Touch.TouchToolStrip} If no value is set, returns the toolbar item width; otherwise, returns the toolbar.
                     * @example
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripItem("C", "Delete", "tsoutline.png", function(){ }))
                     * spread.touchToolStrip.getItem("C").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.imageAreaHeight(30);
                     * spread.touchToolStrip.itemHeight(80);
                     * spread.touchToolStrip.itemWidth(50);
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    itemWidth(width?: number): any;
                    /**
                     * Opens a toolbar in a specific position relative to the touch point.
                     * @param {number} x The <i>x</i>-coordinate.
                     * @param {number} y The <i>y</i>-coordinate.
                     */
                    open(x: number,  y: number): void;
                    /**
                     * Removes the toolbar item with the specified name.
                     * @param {string} name The name of the item to be removed.
                     * @returns {GCTYPE.Spread.Sheets.Touch.TouchToolStripItem} The removed item.
                     * @example
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripItem("Cut", "Delete", "cut.png", function(){ }))
                     * spread.touchToolStrip.getItem("Cut").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripSeparator());
                     * spread.touchToolStrip.remove("Cut");
                     * activeSheet.resumePaint();
                     * activeSheet.repaint();
                     */
                    remove(name: string): GCTYPE.Spread.Sheets.Touch.TouchToolStripItem;
                    /**
                     * Gets or sets the toolbar separator height.
                     * @param {number} height The toolbar separator height.
                     * @returns {number | GCTYPE.Spread.Sheets.Touch.TouchToolStrip} If no value is set, returns the toolbar separator height; otherwise, returns the toolbar.
                     * @example
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripItem("Cut", "Delete", "cut.png", function(){ }))
                     * spread.touchToolStrip.getItem("Cut").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.separatorHeight(33);
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    separatorHeight(height?: number): any;
                }

                export class TouchToolStripItem{
                    /**
                     * Represents an item in the toolbar.
                     * @class
                     * @param {string} name The name of the item.
                     * @param {string} text The item text.
                     * @param {string} image The item image source.
                     * @param {Object} command Defines the executive function that occurs when the user taps the item.
                     * @param {Object} canExecute Defines when to show the item by a function. If returns <c>true</c>, display the item; otherwise, hide the item.
                     * @example
                     * //This example adds a delete image with red text.
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripItem("Cut", "Delete", "cut.png", function(){ }))
                     * spread.touchToolStrip.getItem("Cut").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    constructor(name: string,  text: string,  image: string,  command?: any,  canExecute?: Function);
                    /**
                     * Gets or sets the font of the item text.
                     * @param {string} value The font of the toolbar item text.
                     * @returns {string | GCTYPE.Spread.Sheets.Touch.TouchToolStripItem} If no value is set, returns the font of the item text; otherwise, returns the toolbar item.
                     * @example
                     * //This example adds a delete image with red text.
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripItem("Cut", "Delete", "cut.png", function(){ }))
                     * spread.touchToolStrip.getItem("Cut").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    font(value?: string): any;
                    /**
                     * Gets or sets the color of the item text.
                     * @param {string} value The color of the toolbar item text.
                     * @returns {string | GCTYPE.Spread.Sheets.Touch.TouchToolStripItem} If no value is set, returns the color of the item text; otherwise, returns the toolbar item.
                     * @example
                     * //This example adds a delete image with red text.
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripItem("Cut", "Delete", "cut.png", function(){ }))
                     * spread.touchToolStrip.getItem("Cut").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    foreColor(value?: string): any;
                    /**
                     * Gets or sets the source of the item image.
                     * @param {string} value The path and filename for the item image source.
                     * @returns {string | GCTYPE.Spread.Sheets.Touch.TouchToolStripItem} If no value is set, returns the source of the item image; otherwise, returns the toolbar item.
                     * @example
                     * //This example adds a delete image with red text.
                     * var tts = new GCTYPE.Spread.Sheets.Touch.TouchToolStripItem();
                     * tts.image("cut.png");
                     * tts.name("C");
                     * tts.text("Delete");
                     * spread.touchToolStrip.add(tts, function(){ });
                     * spread.touchToolStrip.getItem("C").font("15px Arial").foreColor("red");
                     */
                    image(value?: string): any;
                    /**
                     * Gets or sets the name of the item.
                     * @param {string} value The name of the toolbar item.
                     * @returns {string | GCTYPE.Spread.Sheets.Touch.TouchToolStripItem} If no value is set, returns the name of the item; otherwise, returns the toolbar item.
                     * @example
                     * //This example adds a delete image with red text.
                     * var tts = new GCTYPE.Spread.Sheets.Touch.TouchToolStripItem();
                     * tts.image("cut.png");
                     * tts.name("C");
                     * tts.text("Delete");
                     * spread.touchToolStrip.add(tts, function(){ });
                     * spread.touchToolStrip.getItem("C").font("15px Arial").foreColor("red");
                     */
                    name(value?: string): any;
                    /**
                     * Gets or sets the text of the item.
                     * @param {string} value The text of the toolbar item.
                     * @returns {string | GCTYPE.Spread.Sheets.Touch.TouchToolStripItem} If no value is set, returns the text of the item; otherwise, returns the toolbar item.
                     * @example
                     * //This example adds a delete image with red text.
                     * var tts = new GCTYPE.Spread.Sheets.Touch.TouchToolStripItem();
                     * tts.image("cut.png");
                     * tts.name("C");
                     * tts.text("Delete");
                     * spread.touchToolStrip.add(tts, function(){ });
                     * spread.touchToolStrip.getItem("C").font("15px Arial").foreColor("red");
                     */
                    text(value?: string): any;
                }

                export class TouchToolStripSeparator{
                    /**
                     * Represents a separator in the toolbar.
                     * @class
                     * @param {Object} canExecute - Defines when to display the separator with a function. If returns <c>true</c>, display the separator; otherwise, hide the separator.
                     * @example
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripItem("Cut", "Delete", "cut.png", function(){ }))
                     * spread.touchToolStrip.getItem("Cut").font("15px Arial").foreColor("red");
                     * spread.touchToolStrip.add(new GCTYPE.Spread.Sheets.Touch.TouchToolStripSeparator());
                     */
                    constructor(canExecute?: Function);
                    /**
                     * Gets the name of the separator.
                     * @returns {string} Returns the current separator name.
                     */
                    name(): string;
                }
            }

        }

        module Slicers{

            export interface ISlicerConditional{
                exclusiveRowIndexes?: number[];
                ranges?: ISlicerRangeConditional[];
            }


            export interface ISlicerData{
                getColumnIndex(columnName: string): number;
                getData(columnName: string, range?: ISlicerRangeConditional): any[];
                getExclusiveData(columnName: string): any[];
                getRowIndexes(columnName: string, exclusiveRowIndex: number): number[];
                getExclusiveRowIndex(columnName: string, rowIndex: number): number;
                getFilteredIndexes(columnName: string, isPreview?: boolean): number[];
                getFilteredOutIndexes(columnName: string, filteredOutDataType: GCTYPE.Spread.Slicers.FilteredOutDataType, isPreview?: boolean): number[];
                getFilteredRanges(columnName: string): ISlicerRangeConditional[];
                getFilteredOutRanges(columnName: string): ISlicerRangeConditional[];
                attachListener(listener: ISlicerListener): void;
                detachListener(listener: ISlicerListener): void;
                doFilter(columnName: string, slicerConditional: ISlicerConditional, isPreview?: boolean): void;
                doUnfilter(columnName: string): void;
                clearPreview():void;
            }


            export interface ISlicerDataItem{
                columnName: string;
                rowIndex: number;
                data: any;
            }


            export interface ISlicerFiltedData{
                isPreview: boolean;
                rowIndexes: number[];
            }


            export interface ISlicerListener{
                onFiltered(data: ISlicerFiltedData): void;
                onDataChanged(data: ISlicerDataItem[]): void;
                onRowsChanged(rowIndex: number, rowCount: number, isAdd: boolean): void;
                onColumnNameChanged(oldName: string, newName: string): void;
                onColumnRemoved(columnName: string): void;
            }


            export interface ISlicerRangeConditional{
                min: number;
                max: number;
            }

            /**
             * Represents the kind of filtered out exclusive data index that should be included in the result.
             * @enum {number}
             */
            export enum FilteredOutDataType{
                /**
                 * Indicates all of the filtered out data.
                 */
                all= 0,
                /**
                 * Indicates the data was filtered out based on the current column.
                 */
                byCurrentColumn= 1,
                /**
                 * Indicates the data was filtered out based on other columns.
                 */
                byOtherColumns= 2
            }

            /**
             * Represents the aggregate type.
             * @enum {number}
             */
            export enum SlicerAggregateType{
                /**
                 *  Calculates the average of the specified numeric values.
                 */
                average= 1,
                /**
                 *  Calculates the number of data that contain numbers.
                 */
                count= 2,
                /**
                 *  Calculates the number of data that contain non-null values.
                 */
                counta= 3,
                /**
                 *  Calculates the maximum value, the greatest value, of all the values.
                 */
                max= 4,
                /**
                 *  Calculates the minimum value, the least value, of all the values.
                 */
                min= 5,
                /**
                 *  Multiplies all the arguments and returns the product.
                 */
                product= 6,
                /**
                 *  Calculates the standard deviation based on a sample.
                 */
                stdev= 7,
                /**
                 *  Calculates the standard deviation of a population based on the entire population using the numbers in a column of a list or database that match the specified conditions.
                 */
                stdevp= 8,
                /**
                 *  Calculates the sum of the specified numeric values.
                 */
                sum= 9,
                /**
                 *  Calculates the variance based on a sample of a population, which uses only numeric values.
                 */
                vars= 10,
                /**
                 *  Calculates the variance based on a sample of a population, which includes numeric, logical, or text values.
                 */
                varp= 11
            }


            export class GeneralSlicerData{
                /**
                 * Represents general slicer data.
                 * @class GCTYPE.Spread.Slicers.GeneralSlicerData
                 * @param {Array.<Array.<Object>>} data The slicer data; it is a matrix array.
                 * @param {Array} columnNames The column names of the slicer data.
                 */
                constructor(data: any[][],  columnNames: string[]);
                /**
                 * Indicates the column names for the general slicer data.
                 * @type {Array.<string>}
                 */
                columnNames: string[];
                /**
                 * Indicates the data source for general slicer data.
                 * @type {{Array.<Array.<Object>>}}
                 */
                data: any[][];
                /**
                 * Aggregates the data by the specified column name.
                 * @param {string} columnName The column name.
                 * @param {GCTYPE.Spread.Slicers.SlicerAggregateType} aggregateType The aggregate type.
                 * @param {Object} range The specific range.
                 * range.min: number type, the minimum value.
                 * range.max: number type, the maximum value.
                 * @returns {number} The aggregated data.
                 */
                aggregateData(columnName: string,  aggregateType: GCTYPE.Spread.Slicers.SlicerAggregateType,  range?: GCTYPE.Spread.Slicers.ISlicerRangeConditional): number;
                /**
                 * Attaches the listener.
                 * @param {GCTYPE.Spread.Slicers.ISlicerListener} listener The listener.
                 */
                attachListener(listener: GCTYPE.Spread.Slicers.ISlicerListener): void;
                /**
                 * Clears the preview filter state.
                 */
                clearPreview(): void;
                /**
                 * Detaches the listener.
                 * @param {Object} listener The listener.
                 */
                detachListener(listener: GCTYPE.Spread.Slicers.ISlicerListener): void;
                /**
                 * Filters the data that corresponds to the specified column name and exclusive data indexes.
                 * @param {string} columnName The column name.
                 * @param {Object} conditional The conditional filter.
                 * conditional.exclusiveRowIndexes: number array type, visible exclusive row indexes
                 * conditional.ranges: {min:number, max:number} array type, visible ranges.
                 * @param {boolean} isPreview Indicates whether preview is set.
                 */
                doFilter(columnName: string,  conditional: GCTYPE.Spread.Slicers.ISlicerConditional,  isPreview?: boolean): void;
                /**
                 * Unfilters the data that corresponds to the specified column name.
                 * @param {string} columnName The column name.
                 */
                doUnfilter(columnName: string): void;
                /**
                 * Gets the column index by the specified column name.
                 * @param {string} columnName The column name.
                 * @returns {number} The column index.
                 */
                getColumnIndex(columnName: string): number;
                /**
                 * Gets the data by the specified column name.
                 * @param {string} columnName The column name.
                 * @param {Object} range The specific range.
                 * range.min: number type, the minimum value.
                 * range.max: number type, the maximum value.
                 * @returns {Array.<string>} The data that corresponds to the specified column name.
                 */
                getData(columnName: string,  range?: GCTYPE.Spread.Slicers.ISlicerRangeConditional): string[];
                /**
                 * Gets the exclusive data by the specified column name.
                 * @param {string} columnName The column name.
                 * @returns {Array} The exclusive data that corresponds to the specified column name.
                 */
                getExclusiveData(columnName: string): any[];
                /**
                 * Gets the exclusive data index by the specified column name and data index.
                 * @param {string} columnName The column name.
                 * @param {number} rowIndex The index of the data.
                 * @returns {number} The exclusive data index that corresponds to the specified column name and data index.
                 */
                getExclusiveRowIndex(columnName: string,  rowIndex: number): number;
                /**
                 * Gets the filtered exclusive data indexes by the specified column name.
                 * @param {string} columnName The column name.
                 * @returns {Array.<number>} The filtered exclusive data indexes that correspond to the specified column name.
                 */
                getFilteredIndexes(columnName: string): number[];
                /**
                 * Gets the filtered out exclusive data indexes by the specified column name.
                 * @param {string} columnName The column name.
                 * @param {GCTYPE.Spread.Slicers.FilteredOutDataType} filteredOutDataType Indicates the kind of filtered out exclusive data index that should be included in the result.
                 * @returns {Array.<number>} The filtered out exclusive data indexes that correspond to the specified column name.
                 */
                getFilteredOutIndexes(columnName: string,  filteredOutDataType: GCTYPE.Spread.Slicers.FilteredOutDataType): number[];
                /**
                 * Gets the filtered out ranges by other columns.
                 * @param {string} columnName The column name.
                 * @returns {Array.<Object>} The filtered out ranges by other columns that correspond to the specified column name.
                 */
                getFilteredOutRanges(columnName: string): GCTYPE.Spread.Slicers.ISlicerRangeConditional[];
                /**
                 * Gets the filtered out row indexes.
                 * @returns {Array} The filtered out row indexes.
                 */
                getFilteredOutRowIndexes(): number[];
                /**
                 * Gets the filtered ranges by the specified column name.
                 * @param {string} columnName The column name.
                 * @returns {Array.<Object>} The filtered ranges that correspond to the specified column name.
                 */
                getFilteredRanges(columnName: string): GCTYPE.Spread.Slicers.ISlicerRangeConditional[];
                /**
                 * Gets the filtered row indexes.
                 * @returns {Array} The filtered row indexes.
                 */
                getFilteredRowIndexes(): number[];
                /**
                 * Gets the data indexes by the specified column name and exclusive data index.
                 * @param {string} columnName The column name.
                 * @param {number} exclusiveRowIndex The index of the exclusive data.
                 * @returns {Array} The data indexes that correspond to the specified column name and exclusive data index.
                 */
                getRowIndexes(columnName: string,  exclusiveRowIndex: number): number[];
                /**
                 * Gets whether the slicer is in the preview state.
                 */
                inPreview(): boolean;
                /**
                 * Changes a column name for the general slicer data.
                 * @param {string} oldName The old name of the column.
                 * @param {string} newName The new name of the column.
                 */
                onColumnNameChanged(oldName: string,  newName: string): void;
                /**
                 * Removes columns of the general slicer data.
                 * @param {number} colIndex The index of the starting column.
                 * @param {number} colCount The number of columns to remove.
                 */
                onColumnsRemoved(colIndex: number,  colCount: number): void;
                /**
                 * Changes data items in the data source of the general slicer data.
                 * @param {GCTYPE.Spread.Slicers.ISlicerDataItem} changedData The changed data item in the data source.
                 */
                onDataChanged(changedDataItems: GCTYPE.Spread.Slicers.ISlicerDataItem): void;
                /**
                 * Occurs after the slicer data has been filtered.
                 * @param {Array} filteredIndexes The filtered exclusive data indexes.
                 * @param {boolean} isPreview Indicates whether the slicer is in preview mode.
                 */
                onFiltered(): void;
                /**
                 * Adds rows in the data source of the general slicer data.
                 * @param {number} rowIndex The index of the starting row.
                 * @param {number} rowCount The number of rows to add.
                 */
                onRowsAdded(rowIndex: number,  rowCount: number): void;
                /**
                 * Removes rows in the data source of the general slicer data.
                 * @param {number} rowIndex The index of the starting row.
                 * @param {number} rowCount The number of rows to remove.
                 */
                onRowsRemoved(rowIndex: number,  rowCount: number): void;
                /**
                 * Resumes the onFiltered event.
                 */
                resumeFilteredEvents(): void;
                /**
                 * Suspends the onFiltered event.
                 */
                suspendFilteredEvents(): void;
            }
        }

    }

}
